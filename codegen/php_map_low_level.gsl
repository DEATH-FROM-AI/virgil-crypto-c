.template 0
#   Copyright (C) 2015-2019 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Functions for PHP primitives generation: protocol, class, enum, etc.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level (in_module, in_php_project, out_low_level, in_type)
    check_arguments (my, "in_module, in_php_project, out_low_level, in_type", my)

    my.out_low_level.name = "$(my.in_module.name:c)"
    my.out_low_level.name0 = "$(my.in_module.name:c)"

    my._t = "$(my.in_php_project.prefix:)_$(my.out_low_level.name0:)"
    my.out_low_level.constant = "$(my._t:UPPER)_PHP_RES_NAME[]"

    new include to my.out_low_level
        . = format_left("#include \"$(my.in_php_project.prefix:)_$(my.out_low_level.name0:).h\"", 0)
    endnew

    new registered_resource to my.out_low_level
        . = format_left("int le_$(my.in_php_project.prefix:)_$(my.out_low_level.name0:);", 0)
    endnew

    new constant to my.out_low_level
        . = format_left("const char $(my.out_low_level.constant:) = \"$(my._t:)_t\";", 0)
    endnew

    new init_func_def_dtor to my.out_low_level
        . = format_left("\
            static void $(my._t:)_dtor_php(zend_resource *rsrc) {
                $(my._t:)_delete(($(my._t:)_t *)rsrc->ptr);
            }
            ", 0)
    endnew

    new init_func_def_list_destr to my.out_low_level
        . = format_left("\
            le_$(my._t:) = zend_register_list_destructors_ex($(my._t:)_dtor_php, NULL, $(my._t:UPPER)_PHP_RES_NAME, module_number);
            ", 0)
    endnew

    my._constant = ""

    for my.in_module.interface as interface0
        for interface0.method as method0
            copy method0 to my.in_module
        endfor
    endfor

    if my.in_type <> "interface"
        php_map_low_level_constructor_destructor (my.in_module, my.out_low_level)
    endif

    for my.in_module.method as method0 where method0.visibility = "public" & method0.declaration = "public" & method0.scope = "public"
        new function to my.out_low_level

            .prefix0 = "$(my.in_module.c_prefix:c)"
            .entity0 = "$(my.in_module.name:c)"

            if my.in_type = "interface"
                .name = ""
                .name0 = ""
            else 
                .name0 = php_derive_low_level_function_name(0, method0)
                .name = "$(0.name0:)_php"
            endif

            .num_arguments = 0

            my._method_arguments = ""
            my._function_arguments = ""

            new def_func_entry to function
                . = format_left("PHP_FE($(function.name:)_php, arginfo_$(function.name:)_php)", 0)
            endnew

            for method0.argument as argument0
                my._d = ""
                if ! last()
                    my._d = ", "
                endif

                my._declare_input_arguments = ""

                new argument to function
                    php_map_low_level_argument (argument0, my.in_php_project, argument, function)
                endnew
            endfor

            php_map_low_level_return (method0, my.in_php_project, function)

            new wrapper to function
                new arg_info to wrapper

                    my._num_arguments = 1 # ctx

                    for function.argument as argument0 where argument0.type0 <> "error"
                        my._num_arguments = my._num_arguments + 1
                    endfor

                    my._c = php_format_extension_comment("Wrap method: $(function.name0:)")

                    my._h = format_left("\
                        ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                                arginfo_$(function.name0:)_php, 
                                0 /*return_reference*/,
                                $(my._num_arguments:) /*required_num_args*/,
                                $(function.return_zend_type:) /*type*/,
                                0 /*allow_null*/)
                        ZEND_END_ARG_INFO()
                    ", 0)
                    . = my._c + my._h
                endnew

                new header to wrapper
                    . = format_left("PHP_FUNCTION($(function.name:)) {", 0)
                endnew

                new declare_input_arguments to wrapper
                    my._c = php_format_extension_comment("Declare input argument")
                    my._h1 = format_left("zval *in_ctx = NULL;")
                    my._h2 = ""

                    for function.argument as argument0 where argument0.type <> "vsc_buffer"
                        if argument0.type0 <> "error"
                            if argument0.zend_type = "IS_STRING"
                                my._h2 += format_left("\
                                    char *in_$(argument0.name:) = NULL;
                                    size_t in_$(argument0.name:)_len = 0;
                                    ", 0)
                            elsif argument0.zend_type = "IS_LONG"
                                # TODO Need to be checked
                                my._h2 += format_left("\
                                    int *in_$(argument0.name:) = 0;
                                    ", 0)
                            elsif argument0.zend_type = "IS_RESOURCE"
                                # TODO Need to be checked
                                my._h2 += format_left("\
                                    vscf_impl_t *in_$(argument0.name:) = NULL;
                                    ", 0)
                            elsif argument0.zend_type = "IS_BOOLEAN"
                                # TODO Need to be checked
                                my._h2 += format_left("\
                                    bool *in_$(argument0.name:) = NULL;
                                    ", 0)
                            else
                                echo_debug_item(argument0)
                                echo_debug_item(function)
                                echo_fatal("Not implemented. Code: 700")
                            endif
                        endif
                    endfor

                    my._res = my._c + my._h1 + my._h2

                    . = format_left(my._res, 1)
                endnew

                new parse_arguments to wrapper
                    my._c = php_format_extension_comment("Parse arguments")
                    my._h1 = format_left("ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, $(my._num_arguments:), $(my._num_arguments:))", 0)
                    my._h2 = format_left("Z_PARAM_RESOURCE_EX(in_ctx, 1, 0)", 1)
                    my._h3 = ""
                    for function.argument as argument0 where argument0.type <> "vsc_data"
                        if argument0.type0 <> "error"
                            if argument0.zend_type = "IS_STRING"
                                my._h3 += format_left("Z_PARAM_STRING_EX(in_$(argument0.name:), in_$(argument0.name:)_len, 1 /*check_null*/, 0 /*separate*/)", 1)
                            elsif argument0.zend_type = "IS_LONG"
                                my._h3 += format_left("Z_PARAM_LONG_EX(in_$(argument0.name:), 0 /*is_null*/, 1 /*check_null*/, 0 /*separate*/)", 1)
                            elsif argument0.zend_type = "IS_RESOURCE"
                                # TODO!!!
                                my._h3 += format_left("Z_PARAM_RESOURCE_EX(in_$(argument0.name:), 1 /*check_null*/, 0 /*separate*/)", 1)
                            elsif argument0.zend_type = "IS_BOOLEAN"
                                # TODO!!!
                                my._h3 += format_left("Z_PARAM_BOOL_EX(in_$(argument0.name:), 0 /*is_null*/, 1 /*check_null*/, 0 /*separate*/)", 1)
                            else
                                echo_debug_item(argument0)
                                echo_fatal("Not implemented (701)")
                            endif
                        endif
                    endfor
                    my._h4 = format_left("ZEND_PARSE_PARAMETERS_END();", 0)
                    my._res = my._c + my._h1 + my._h2 + my._h3 + my._h4

                    . = format_left(my._res, 1)
                endnew

                new proxy_call to wrapper
                    my._c = php_format_extension_comment("Proxy call")
                    my._h1 = format_left("\
                        $(my._t:)_t *$(my.out_low_level.name0:) = zend_fetch_resource_ex(in_ctx, $(my._t:UPPER)_PHP_RES_NAME, le_$(my._t:));
                        $(my.in_php_project.prefix:UPPER)_ASSERT_PTR($(my.out_low_level.name0:));
                        ", 0)
                    my._h2 = ""
                    for function.argument as argument0
                        if argument0.zend_type = "IS_STRING"
                            my._h2 += format_left("vsc_data_t $(argument0.name:) = vsc_data((const byte*)in_$(argument0.name:), in_$(argument0.name:)_len);", 0)
                        elsif argument0.zend_type = "IS_LONG"
                            # TODO Need to be checked!
                            my._h2 += format_left("", 0)
                        elsif argument0.zend_type = "IS_RESOURCE"
                            # TODO Need to be checked!
                            my._h2 += format_left("", 0)
                        elsif argument0.zend_type = "IS_BOOLEAN"
                            # TODO Need to be checked!
                            my._h2 += format_left("", 0)
                        else
                            echo_debug_item(argument0)
                            echo_fatal("Not implemented (702)")
                        endif
                    endfor
                    my._res = my._c + my._h1 + "\n" + my._h2

                    . = format_left(my._res, 1)
                endnew

                new allocate_output_buffer to wrapper
                    my._res = ""
                    for function.return_argument as return_argument0

                        my._n = ""
                        if ! last()
                            my._n = "\n"
                        endif

                        if ! defined (return_argument0.type)
                            echo_debug_item(function)
                            echo_debug_item(return_argument0)
                            echo_fatal("Not implemented (14001)", my)
                        endif

                        if return_argument0.type = "buffer"
                            my._c = php_format_extension_comment("Allocate output buffer for output '$(return_argument0.name:)'")

                            if return_argument0.length_type = "constant"
                                my._l = "$(return_argument0.length:)"
                            elsif return_argument0.length_type = "method"
                                my._l = "$(return_argument0.length:)($(function.entity0:))"
                            else 
                                echo_debug_item(return_argument0)
                                echo_fatal("Not implemented (1001)")
                            endif

                            my._h1 = format_left("\
                                zend_string *out_$(return_argument0.name:) = zend_string_alloc($(my._l), 0);
                                vsc_buffer_t *$(return_argument0.name:) = vsc_buffer_new();
                                vsc_buffer_use($(return_argument0.name:), (byte *)ZSTR_VAL(out_$(return_argument0.name:)), ZSTR_LEN(out_$(return_argument0.name:)));
                                ", 0)
                            my._res += my._c + my._h1 + "\n" + my._n
                        endif
                    endfor
                    . = format_left(my._res, 1)
                endnew

                new call_main_function to wrapper
                    my._return = ""
                    my._args = "("
                    my._args += function.entity0

                    for function.return_argument as return_argument0 where return_argument0.type <> "buffer"
                        if return_argument0.type = "enum"
                            if return_argument0.name = "status"
                                my._return = "$(function.prefix0:)_status_t status = "
                            else
                                # TODO!!!
                                my._return = "enum $(return_argument0.name:) = "
                            endif
                        elsif return_argument0.type = "size"
                            my._return = "size_t $(return_argument0.name:) = "
                        elsif return_argument0.type = "interface"
                            my._return = "vscf_impl_t $(return_argument0.name:) = "
                        elsif return_argument0.type = "class"
                            # TODO!!!
                            my._return = "vscf_$(return_argument0.name:)_t $(return_argument0.name:) = "
                        elsif return_argument0.type = "boolean"
                            # TODO!!!
                            my._return = "boolen $(return_argument0.name:) = "
                        else
                            echo_debug_item(return_argument0)
                            echo_fatal("Not implemented (1004)", my)
                        endif
                    endfor

                    for function.argument as argument0
                        my._args += ", $(argument0.name:)"
                    endfor

                    my._args += ");"

                    my._func = "$(function.name:)"

                    my._res = my._return + my._func + my._args

                    . = format_left(my._res, 1)
                endnew

                new handle_error to wrapper
                    if function.throw_exception = 1
                        my._c = php_format_extension_comment("Handle error")
                        my._h1 = format_left("$(function.prefix0:UPPER)_HANDLE_STATUS (status);", 0)

                        my._res = my._c + my._h1

                        . = format_left(my._res, 1)
                    else 
                        . = ""
                    endif
                endnew

                new correct_string_length to wrapper
                    my._res = ""

                    for function.return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                        if return_argument0.type = "buffer"
                            my._res += format_left("ZSTR_LEN(out_$(return_argument0.name:)) = vsc_buffer_len($(return_argument0.name:));", 0)
                        elsif return_argument0.type = "size"

                        elsif return_argument0.type = "interface"

                        elsif return_argument0.type = "class"

                        elsif return_argument0.type = "boolean"

                        else
                            echo_debug_item(return_argument0)
                            echo_fatal("Not implemented (1100)", my)
                        endif
                    endfor

                    if my._res <> ""
                        my._c = php_format_extension_comment("Correct string length to the actual")
                        my._res = my._c + my._res
                    endif

                    . = format_left(my._res, 1)
                endnew

                new write_returned_result to wrapper
                    my._res = ""

                    if function.return_zend_type = "IS_STRING"
                        for function.return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                            my._res += format_left("RETVAL_STR(out_$(return_argument0.name:));", 0)
                        endfor
                    elsif function.return_zend_type = "IS_ARRAY"
                        my._res += format_left("array_init(return_value);", 0)
                        for function.return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                            if return_argument0.type = "buffer"
                                my._res += format_left("add_next_index_str(return_value, out_$(return_argument0.name:));", 0)
                            else 
                                echo_debug_item(return_argument0)
                                echo_fatal("Not implemented (1201)", my)
                            endif
                        endfor
                    elsif function.return_zend_type = "IS_LONG"
                        for function.return_argument as return_argument0 where return_argument0.name <> "status" & return_argument0.type <> "enum"
                            my._res += format_left("RETVAL_LONG($(return_argument0.name:));", 0)
                        endfor
                    elsif function.return_zend_type = "IS_VOID"

                    elsif function.return_zend_type = "IS_RESOURCE"

                    elsif function.return_zend_type = "IS_BOOLEAN"

                    else
                        echo_debug_item(function)
                        echo_fatal("Not implemented (12001)", my)
                    endif

                    if my._res <> ""
                        my._c = php_format_extension_comment("Write returned result")
                        my._res = my._c + my._res
                    endif

                    . = format_left(my._res, 1)
                endnew

                my._fail = ""
                my._success = ""

                new fail_success to wrapper
                    my._res = ""

                    if function.return_zend_type = "IS_VOID" | function.return_zend_type = "IS_LONG"
                        my._res = format_left("\
                            goto sucess;

                        fail:
                            RETURN_FALSE;
                        success:
                            RETURN_TRUE;
                        ", 0)
                    elsif function.return_zend_type = "IS_STRING" | function.return_zend_type = "IS_ARRAY"
                        for function.return_argument where return_argument.name <> "status" & return_argument.type <> "enum"
                            my._fail += format_left("zend_string_free(out_$(return_argument.name:));", 1)
                            my._success += format_left("vsc_buffer_destroy(&$(return_argument.name:));", 1)
                        endfor

                        my._p1 = format_left("goto success;", 1)
                        my._p2 = format_left("fail:", 0)
                        my._p3 = format_left("success:", 0)

                        my._res = my._p1 + "\n" + my._p2 + my._fail + my._p3 + my._success
                    elsif function.return_zend_type = "IS_RESOURCE"
                        my._res = format_left("\
                            goto sucess;

                        fail:
                            RETURN_FALSE;
                        success:
                            RETURN_TRUE;
                        ", 0)
                    # TODO!!!
                    elsif function.return_zend_type = "IS_BOOLEAN"
                        my._res = format_left("\
                            goto sucess;

                        fail:
                            RETURN_FALSE;
                        success:
                            RETURN_TRUE;
                        ", 0)
                    else
                        echo_debug_item(return_argument0)
                        echo_fatal("Not implemented (13001)", my)
                    endif

                    . = format_left(my._res, 0)
                endnew
            endnew
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
# 
# ---------------------------------------------------------------------------
function php_map_low_level_constructor_destructor (in_module, out_low_level)
    check_arguments (my, "in_module, out_low_level", my)

    new function to my.out_low_level
        .name0 = "$(my.in_module.c_prefix:)_$(my.in_module.name:c)_new"
        .name = "$(0.name0:)_php"
        .prefix0 = "$(my.in_module.c_prefix:)"
        .entity0 = "$(my.in_module.name:)"
        .return_type0 = ""
        .return_type = "IS_RESOURCE"
        .return_data = ""
        .instance = 0
        .throw_exception = 0
        .num_arguments = 0

        my._a = "$(0.prefix0:)_$(0.entity0)"

        new def_func_entry to function
            . = format_left("PHP_FE($(function.name0:)_php, arginfo_$(function.name0:)_php)", 0)
        endnew

        new wrapper to function
            new arg_info to wrapper
                my._c = php_format_extension_comment("Wrap method: $(function.name0:)")

                my._h = format_left("\
                    ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$(function.name0:)_php, 
                            0 /*return_reference*/,
                            $(function.num_arguments:) /*required_num_args*/,
                            $(function.return_type:) /*type*/,
                            0 /*allow_null*/)
                    ZEND_END_ARG_INFO()
                    ", 0)

                my._res = my._c + my._h
                . = my._res
            endnew

            new custom_code to wrapper
                my._custom_code = format_left("\
                    PHP_FUNCTION($(function.name0:)) {
                        $(my._a:)_t *$(function.entity0:) =$(function.name0:)();
                        zend_resource *$(function.entity0:)_res = zend_register_resource($(function.entity0:), le_$(my._a:);
                        RETVAL_RES($(function.entity0:)_res);
                    }
                    ", 0)
                . = my._custom_code
            endnew
        endnew
    endnew

    new function to my.out_low_level
        .name0 = "$(my.in_module.c_prefix:)_$(my.in_module.name:c)_delete"
        .name = "$(0.name0:)_php"
        .prefix0 = "$(my.in_module.c_prefix:)"
        .entity0 = "$(my.in_module.name:)"
        .return_type0 = ""
        .return_type = "IS_VOID"
        .return_data = ""
        .instance = 0
        .throw_exception = 0
        .num_arguments = 1

        my._a = "$(0.prefix0:)_$(0.entity0)"

        new def_func_entry to function
            . = format_left("PHP_FE($(function.name0:)_php, arginfo_$(function.name0:)_php)", 0)
        endnew

        new wrapper to function
            new arg_info to wrapper
                my._c = php_format_extension_comment("Wrap method: $(function.name0:)")

                my._h = format_left("\
                    ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$(function.name0:)_php, 
                            0 /*return_reference*/,
                            $(function.num_arguments:) /*required_num_args*/,
                            $(function.return_type:) /*type*/,
                            0 /*allow_null*/)
                    ZEND_END_ARG_INFO()
                    ", 0)

                my._res = my._c + my._h
                . = my._res
            endnew

            new custom_code to wrapper
                my._custom_code = format_left("\
                    PHP_FUNCTION($(function.name0:)_php) {
                        //
                        // Declare input arguments
                        //
                        zval *in_ctx = NULL;

                        //
                        // Parse arguments
                        //
                        ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, 1, 1)
                            Z_PARAM_RESOURCE_EX(in_ctx, 1, 0)
                        ZEND_PARSE_PARAMETERS_END();

                        //
                        // Fetch for type checking and then release
                        //
                        $(my._a:)_t *$(function.entity0:) = zend_fetch_resource_ex(in_ctx, $(my._a:UPPER)_PHP_RES_NAME, le_$(my._a:));
                        $(function.prefix0:UPPER)_ASSERT_PTR($(function.entity0:));
                        zend_list_close(Z_RES_P(in_ctx));
                        RETURN_TRUE;
                    }
                    ", 0)

                . = my._custom_code
            endnew
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_argument (in_argument, in_php_project, out_php_argument, out_function)
    check_arguments (my, "in_argument, in_php_project, out_php_argument, out_function", my)

    my.out_php_argument.name = "$(my.in_argument.name:c)"

    my._type0 = "NOT IMPLEMENTED"
    my._type = "NOT IMPLEMENTED"
    my._zend_type = "NOT IMPLEMENTED"
    my._instance = 0

    if defined (my.in_argument.class)
        if string_in(my.in_argument.class, "data, buffer") 
            my._type0 = "string"
            my._type = "vsc_$(my.in_argument.class:)"
            my._zend_type = "IS_STRING"
        elsif my.in_argument.class = "error"
            my._type0 = "error"
            # TODO
            my._type = "vscf_error_t"
            my._zend_type = "IS_RESOURCE"
        else
            my._type0 = "class"
            # TODO
            my._type = "vscf_$(my.in_argument.class:c)_t"
            my._zend_type = "IS_RESOURCE"
            my._instance = 1
        endif
    endif

    if defined (my.in_argument.interface)
        my._type0 = "interface"
        # TODO!!!
        my._type = "vscf_impl_t"
        my._zend_type = "IS_RESOURCE"
        my._instance = 1
    endif

    if defined (my.in_argument.type)
        if string_in(my.in_argument.type, "size, integer, unsigned")
            my._type0 = my.in_argument.type
            my._type = "int"
            my._zend_type = "IS_LONG"
        elsif my.in_argument.type = "byte"
            my._type0 = my.in_argument.type
            my._type = "string"
            my._zend_type = "IS_STRING"
        elsif my.in_argument.type = "boolean"
            my._type0 = my.in_argument.type
            my._type = "bool"
            my._zend_type = "IS_BOOLEAN"
        else
            # TODO
            echo_debug_item(my.in_argument)
            echo_fatal("Not implemented (601)", my)
        endif
    endif

    if defined (my.in_argument.enum)
        my._type0 = "enum"
        # TODO
        my._type = "$(my.in_argument.enum:c)"
        my._zend_type = "IS_STRING"
        my._instance = 1
    endif

    if defined (my.in_argument.impl)
        my._type0 = "impl"
        my._type = "vscf_$(my.in_argument.impl:c)_t"
        my._zend_type = "IS_RESOURCE"
        my._instance = 1
    endif

    my.out_php_argument.type0 = my._type0
    my.out_php_argument.type = my._type
    my.out_php_argument.zend_type = my._zend_type
    my.out_php_argument.instance = my._instance

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_return (in_method, in_php_project, out_function)
    check_arguments (my, "in_method, in_php_project, out_function", my)

    my._return_type0 = ""
    my._return_type = "IS_VOID"
    my._return_zend_type = "IS_VOID"
    my._return_data = ""
    my._instance = 0
    my._throw_exception = 0
    my._argument_buffer_count = 0

    for my.in_method.argument as argument0 where defined (argument0.class)
        if argument0.class = "buffer"
            my._argument_buffer_count = my._argument_buffer_count + 1
            new return_argument to my.out_function
                .name = "$(argument0.name:c)"
                .type = "buffer"

                my._prefix = my.out_function.prefix0
                my._entity = my.out_function.entity0

                if defined (argument0->length.class)
                    my._class = argument0->length.class
                    my._constant = "$(argument0->length.constant:c)"
                    my._constant = "$(my._constant:UPPER)"
                    .length = "$(my._prefix:c)_$(my._class:c)_$(my._constant:)"
                    .length_type = "constant"
                elsif defined (argument0->length.method)
                    my._method = "$(argument0->length.method:c)"
                    my._function = "$(my._prefix:)_$(my._entity:)_$(argument0->length.method:c)"
                    .length = my._function
                    .length_type = "method"
                else 
                    # TODO!!!
                    .length = "none"
                    .length_type = "constant"
                endif
            endnew
        endif
    endfor

    if my._argument_buffer_count = 1
        my._return_type = "IS_STRING"
        my._return_zend_type = "IS_STRING"
    elsif my._argument_buffer_count > 1
        my._return_type = "IS_ARRAY"
        my._return_zend_type = "IS_ARRAY"
    endif

    for my.in_method.return as return0

        if defined (return0.type)
            if return0.type = "size" | return0.type = "integer" | return0.type = "unsigned"
                my._return_type0 = return0.type
                my._return_type = "int"
                my._return_zend_type = "IS_LONG"
            elsif return0.type = "boolean"
                my._return_type0 = return0.type
                my._return_type = "bool"
                my._return_zend_type = "IS_BOOLEAN"
            elsif return0.type = "byte"
                my._return_type0 = return0.type
                my._return_type = "string"
                my._return_zend_type = "IS_STRING"
            else
                # TODO
                echo_debug_item(my.in_method)
                echo_debug_item(return0)
                echo_fatal("Not implemented (801)", my)
            endif

            if return0.type = "size"
                new return_argument to my.out_function
                    .name = "$(return0.type:c)"
                    .type = "$(return0.type:c)"
                endnew
            else
                new return_argument to my.out_function
                    # TODO!!!
                    .name = "$(return0.type:c)"
                    .type = "boolean"
                endnew
            endif
        endif

        my._r = ""

        if defined (return0.class)
            if return0.class = "data"
                my._return_type0 = return0.class
                my._return_type = "string"
                my._return_zend_type = "IS_STRING"
            else
                my._return_type0 = return0.class
                my._return_type = return0.class
                my._return_zend_type = "IS_RESOURCE"
            endif

            new return_argument to my.out_function
                .name = "----------> $(return0.class:c)_CLASS"
                .type = "class"
            endnew
        elsif defined (return0.interface)
            my._return_type0 = return0.interface
            my._return_type = return0.interface
            my._return_zend_type = "IS_RESOURCE"

            new return_argument to my.out_function
                .name = "----------> vscf_impl_t $(return0.interface:c)"
                .type = "interface"
            endnew
        endif

        if defined (return0.enum)
            if return0.enum = "status"
                my._throw_exception = 1

                new return_argument to my.out_function
                    .name = "$(return0.enum:c)"
                    .type = "enum"
                endnew
            else
                my._return_type0 = return0.enum
                my._return_type = return0.enum
                # TODO!!!
                my._return_zend_type = "IS_STRING"

                new return_argument to my.out_function
                    .name = "--------> $(return0.enum:c)_ENUM"
                    .type = "enum"
                endnew
            endif
        endif
    endfor

    my.out_function.return_type0 = my._return_type0
    my.out_function.return_type = my._return_type
    my.out_function.return_zend_type = my._return_zend_type
    my.out_function.return_data = my._return_data
    my.out_function.instance = my._instance
    my.out_function.throw_exception = my._throw_exception

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_extension (in_php_project, out_php_module)
    check_arguments (my, "in_php_project, out_php_module", my)

    my._include = ""
    my._registered_resources = ""
    my._constants = ""
    my._init_func_def_dtor = ""
    my._init_func_def_list_destr = ""
    my._def_func_entries = ""
    my._func_wrapping = ""

    my._ext_name0 = "$(my.in_php_project.prefix:)_$(my.in_php_project.name:)_php"

    for my.in_php_project.php_module as php_module0 where string_in(php_module0.type, "class, implementation, interface")
        if ! defined (php_module0->low_level->include)
            echo_debug_item(php_module0->low_level)
            echo_fatal("adfdgdg", my)
        endif
        my._include += php_module0->low_level->include.
        my._registered_resources += php_module0->low_level->registered_resource.
        my._constants += php_module0->low_level->constant.
        my._init_func_def_dtor += php_module0->low_level->init_func_def_dtor.
        my._init_func_def_list_destr += php_module0->low_level->init_func_def_list_destr.

        for php_module0->low_level.function as function0
            my._func_wrapping += format_left(function0->wrapper->arg_info., 0)
            my._def_func_entries += function0->def_func_entry.

            if defined(function0->wrapper->custom_code)
                my._func_wrapping += "\n" + format_left(function0->wrapper->custom_code., 0)
            else
                my._1 = "\n" + function0->wrapper->header.
                my._2 = "\n" + function0->wrapper->declare_input_arguments.
                my._3 = "\n" + function0->wrapper->parse_arguments.
                my._4 = "\n" + function0->wrapper->proxy_call.
                my._5 = "\n" + function0->wrapper->allocate_output_buffer.
                my._6 = "\n" + function0->wrapper->call_main_function.
                my._7 = "\n" + function0->wrapper->handle_error
                my._8 = "\n" + function0->wrapper->correct_string_length.
                my._9 = "\n" + function0->wrapper->write_returned_result.
                my._10 = "\n" + function0->wrapper->fail_success.
                my._11 = format_left("}", 0)

                my._func_wrapping += my._1 + my._2 + my._3 + my._4 + my._5 + my._6 + my._7 + my._8 + my._9 + my._10 + my._11
            endif

            my._func_wrapping += "\n"
        endfor
    endfor

    new licence to my.out_php_module
        my._res = php_format_extension_comment (my.in_php_project->license)
        . = my._res
    endnew

    new include to my.out_php_module
        my._res = format_left("\
            #include <php.h>
            #include <zend_exceptions.h>
            #include <zend_list.h>
            #include \"vsce_assert.h\"
            #include \"vsce_phe_common.h\"
            #include \"status.c\"
            ", 0)

        my._res = my._res + my._include

        . = my._res
    endnew

    new constants to my.out_php_module

        my._ext_name = "$(my._ext_name0:UPPER)"

        my._c = php_format_extension_comment ("Constants")
        my._h = format_left("\
            const char $(my._ext_name:)_VERSION[] = \"$(my.in_php_project.version:)\";
            const char $(my._ext_name:)_EXTNAME[] = \"$(my._ext_name0:)\"; 
            ", 0)
        my._res = my._c + my._h + my._constants
        . = my._res
    endnew

    new registered_resources to my.out_php_module
        my._c = php_format_extension_comment ("Registered resources")
        my._res = my._c + my._registered_resources
        . = my._res
    endnew

    new init_func_declaration to my.out_php_module

        my._c = php_format_extension_comment ("Extension init functions declaration")
        my._h = format_left("\
            PHP_MINIT_FUNCTION($(my._ext_name0:));
            PHP_MSHUTDOWN_FUNCTION($(my._ext_name0:));
            ", 0)
        my._res = my._c + my._h
        . = my._res
    endnew

    new func_wrapping to my.out_php_module
        my._c = php_format_extension_comment ("Functions wrapping")
        my._h = my._func_wrapping
        my._res = my._c + my._h
        . = my._res
    endnew

    new define_all_func_entries to my.out_php_module
        my._c = php_format_extension_comment ("Define all function entries")

        my._h1 = format_left("static zend_function_entry $(my._ext_name0:)_functions[] = {", 0)
        my._h2 = format_left("$(my._def_func_entries:)", 1)
        my._h3 = format_left("\
                PHP_FE_END
            };
            ", 0)

        my._res = my._c + my._h1 + my._h2 + my._h3

        . = my._res
    endnew

    new module_definitions to my.out_php_module
        my._c = php_format_extension_comment ("Extension module definition")
        my._h = format_left("\
            zend_module_entry $(my._ext_name0:)_module_entry = {
            #if ZEND_MODULE_API_NO >= 20010901
                STANDARD_MODULE_HEADER,
            #endif
                $(my._ext_name0:UPPER)_EXTNAME,
                $(my._ext_name0:)_functions,
                PHP_MINIT($(my._ext_name0:)),
                PHP_MSHUTDOWN($(my._ext_name0:)),
                NULL,
                NULL,
                NULL,
            #if ZEND_MODULE_API_NO >= 20010901
                $(my._ext_name0:UPPER)_VERSION,
            #endif
                STANDARD_MODULE_PROPERTIES
            };

            ZEND_GET_MODULE($(my._ext_name0:))
            ", 0)

        my._res = my._c + my._h
        . = my._res
    endnew

    new init_func_definitions to my.out_php_module
        my._c = php_format_extension_comment ("Extension init functions definition")

        my._h1 = format_left("$(my._init_func_def_dtor:)", 0)
        my._h2 = format_left("PHP_MINIT_FUNCTION($(my._ext_name0:)) {", 0)
        my._h3 = format_left("$(my._init_func_def_list_destr:)", 1)

        my._h4 = format_left("\
                return SUCCESS;
            }
            ", 0)

        my._h5 = format_left("\
            PHP_MSHUTDOWN_FUNCTION($(my._ext_name0:)) {
                return SUCCESS;
            }
            ", 0)

        my._res = my._c + my._h1 + my._h2 + my._h3 + my._h4 + my._h5

        . = my._res
    endnew

endfunction
.endtemplate

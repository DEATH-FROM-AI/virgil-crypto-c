.template 0
#   Copyright (C) 2015-2019 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Functions for PHP primitives generation: protocol, class, enum, etc.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level (in_module, in_php_project, out_low_level, in_type)
    check_arguments (my, "in_module, in_php_project, out_low_level, in_type", my)

    my.out_low_level.name = "$(my.in_module.name:c)"
    my.out_low_level.name0 = "$(my.in_module.name:c)"

    my._t = "$(my.in_php_project.prefix:)_$(my.out_low_level.name0:)"
    my.out_low_level.constant = "$(my._t:UPPER)_PHP_RES_NAME[]"

    new include to my.out_low_level
        . = format_left("#include \"$(my.in_php_project.prefix:)_$(my.out_low_level.name0:).h\"", 0)
    endnew

    new registered_resource to my.out_low_level
        . = format_left("int le_$(my.in_php_project.prefix:)_$(my.out_low_level.name0:);", 0)
    endnew

    new constant to my.out_low_level
        . = format_left("const char $(my.out_low_level.constant:) = \"$(my._t:)_t\";", 0)
    endnew

    new init_func_def_dtor to my.out_low_level
        . = format_left("\
            static void $(my._t:)_dtor_php(zend_resource *rsrc) {
                $(my._t:)_delete(($(my._t:)_t *)rsrc->ptr);
            }
            ", 0)
    endnew

    new init_func_def_list_destr to my.out_low_level
        . = format_left("\
            le_$(my._t:) = zend_register_list_destructors_ex($(my._t:)_dtor_php, NULL, $(my._t:UPPER)_PHP_RES_NAME, module_number);
            ", 0)
    endnew

    my._interface_methods = XML.new()
    my._constant = ""

    for my.in_module.interface as interface0

        echo_debug_item(interface0)
        echo_warning("Not implemented. Code: 400")

        for interface0.constant as constant0
            echo_debug_item(constant0)
            echo_warning("Not implemented. Code: 401")
        endfor
    endfor

    if my.in_type <> "interface"
        php_map_low_level_constructor_destructor (my.in_module, my.out_low_level)
    endif

    for my.in_module.method as method0 where method0.visibility = "public" & method0.declaration = "public" & method0.scope = "public"
        new function to my.out_low_level

            .prefix0 = "$(my.in_module.c_prefix:c)"
            .entity0 = "$(my.in_module.name:c)"

            if my.in_type = "interface"
                .name = ""
                .name0 = ""
            else 
                .name0 = php_derive_low_level_function_name(0, method0)
                .name = "$(0.name0:)_php"
            endif

            .num_arguments = 0

            my._method_arguments = ""
            my._function_arguments = ""

            new def_func_entry to function
                . = format_left("PHP_FE($(function.name:)_php, arginfo_$(function.name:)_php)", 0)
            endnew

            for method0.argument as argument0
                my._d = ""
                if ! last()
                    my._d = ", "
                endif

                new argument to function
                    php_map_low_level_argument (argument0, my.in_php_project, argument, function)
                endnew
            endfor

            php_map_low_level_return (method0, my.in_php_project, function)

            new wrapper to function
                new arg_info to wrapper
                    my._c = php_format_extension_comment("Wrap method: $(function.name0:)")

                    my._h = format_left("\
                        ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                                arginfo_$(function.name0:)_php, 
                                0 /*return_reference*/,
                                $(function.num_arguments:) /*required_num_args*/,
                                $(function.return_zend_type:) /*type*/,
                                0 /*allow_null*/)
                        ZEND_END_ARG_INFO()
                    ", 0)
                    . = my._c + my._h
                endnew

                new header to wrapper
                    . = format_left("PHP_FUNCTION($(function.name:)) {", 0)
                endnew
            endnew
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
# 
# ---------------------------------------------------------------------------
function php_map_low_level_constructor_destructor (in_module, out_low_level)
    check_arguments (my, "in_module, out_low_level", my)

    new function to my.out_low_level
        .name0 = "$(my.in_module.c_prefix:)_$(my.in_module.name:c)_new"
        .name = "$(0.name0:)_php"
        .prefix0 = "$(my.in_module.c_prefix:)"
        .entity0 = "$(my.in_module.name:)"
        .return_type0 = ""
        .return_type = "IS_RESOURCE"
        .return_data = ""
        .instance = 0
        .throw_exception = 0
        .num_arguments = 0

        my._a = "$(0.prefix0:)_$(0.entity0)"

        new def_func_entry to function
            . = format_left("PHP_FE($(function.name0:)_php, arginfo_$(function.name0:)_php)", 0)
        endnew

        new wrapper to function
            new arg_info to wrapper
                my._c = php_format_extension_comment("Wrap method: $(function.name0:)")

                my._h = format_left("\
                    ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$(function.name0:)_php, 
                            0 /*return_reference*/,
                            $(function.num_arguments:) /*required_num_args*/,
                            $(function.return_type:) /*type*/,
                            0 /*allow_null*/)
                    ZEND_END_ARG_INFO()
                    ", 0)

                my._res = my._c + my._h
                . = my._res
            endnew

            new custom_code to wrapper
                my._custom_code = format_left("\
                    PHP_FUNCTION($(function.name0:)) {
                        $(my._a:)_t *$(function.entity0:) =$(function.name0:)();
                        zend_resource *$(function.entity0:)_res = zend_register_resource($(function.entity0:), le_$(my._a:);
                        RETVAL_RES($(function.entity0:)_res);
                    }
                    ", 0)
                . = my._custom_code
            endnew
        endnew
    endnew

    new function to my.out_low_level
        .name0 = "$(my.in_module.c_prefix:)_$(my.in_module.name:c)_delete"
        .name = "$(0.name0:)_php"
        .prefix0 = "$(my.in_module.c_prefix:)"
        .entity0 = "$(my.in_module.name:)"
        .return_type0 = ""
        .return_type = "IS_VOID"
        .return_data = ""
        .instance = 0
        .throw_exception = 0
        .num_arguments = 1

        my._a = "$(0.prefix0:)_$(0.entity0)"

        new def_func_entry to function
            . = format_left("PHP_FE($(function.name0:)_php, arginfo_$(function.name0:)_php)", 0)
        endnew

        new wrapper to function
            new arg_info to wrapper
                my._c = php_format_extension_comment("Wrap method: $(function.name0:)")

                my._h = format_left("\
                    ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(
                            arginfo_$(function.name0:)_php, 
                            0 /*return_reference*/,
                            $(function.num_arguments:) /*required_num_args*/,
                            $(function.return_type:) /*type*/,
                            0 /*allow_null*/)
                    ZEND_END_ARG_INFO()
                    ", 0)

                my._res = my._c + my._h
                . = my._res
            endnew

            new custom_code to wrapper
                my._custom_code = format_left("\
                    PHP_FUNCTION($(function.name0:)_php) {
                        //
                        // Declare input arguments
                        //
                        zval *in_ctx = NULL;

                        //
                        // Parse arguments
                        //
                        ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, 1, 1)
                            Z_PARAM_RESOURCE_EX(in_ctx, 1, 0)
                        ZEND_PARSE_PARAMETERS_END();

                        //
                        // Fetch for type checking and then release
                        //
                        $(my._a:)_t *$(function.entity0:) = zend_fetch_resource_ex(in_ctx, $(my._a:UPPER)_PHP_RES_NAME, le_$(my._a:));
                        $(function.prefix0:UPPER)_ASSERT_PTR($(function.entity0:));
                        zend_list_close(Z_RES_P(in_ctx));
                        RETURN_TRUE;
                    }
                    ", 0)

                . = my._custom_code
            endnew
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_argument (in_argument, in_php_project, out_php_argument, out_function)
    check_arguments (my, "in_argument, in_php_project, out_php_argument, out_function", my)

    my.out_php_argument.name = "$(my.in_argument.name:c)"

    my._type0 = "NOT IMPLEMENTED"
    my._type = "NOT IMPLEMENTED"
    my._zend_type = "NOT IMPLEMENTED"
    my._instance = 0
    my._count = 1 # ctx

    if defined (my.in_argument.class)
        if string_in(my.in_argument.class, "data, buffer") 
            my._type0 = "string"
            my._type = "vsc_$(my.in_argument.class:)"
            my._zend_type = "IS_STRING"
            my._count = my._count + 1
        else
            my._type0 = "class"
            my._type = "$(my.in_argument.class:c)"
            my._instance = 1
            my._count = my._count + 1
        endif
    endif

    if defined (my.in_argument.interface)
        my._type0 = "interface"
        my._type = "$(my.in_argument.interface:c)"
        my._instance = 1
        my._count = my._count + 1
    endif

    if defined (my.in_argument.type)
        if string_in(my.in_argument.type, "size, integer, unsigned")
            my._type0 = my.in_argument.type
            my._type = "int"
            my._zend_type = "IS_LONG"
            my._count = my._count + 1
        elsif my.in_argument.type = "byte"
            my._type0 = my.in_argument.type
            my._type = "string"
            my._zend_type = "IS_STRING"
            my._count = my._count + 1
        elsif my.in_argument.type = "boolean"
            my._type0 = my.in_argument.type
            my._type = "bool"
            my._zend_type = "IS_BOOLEAN"
            my._count = my._count + 1
        else
            # TODO
            echo_debug_item(my.in_argument)
            echo_fatal("Not implemented. Code: 601", my)
        endif
    endif

    if defined (my.in_argument.enum)
        my._type0 = "enum"
        my._type = "$(my.in_argument.enum:c)"
        my._instance = 1
        my._count = my._count + 1
    endif

    my.out_php_argument.type0 = my._type0
    my.out_php_argument.type = my._type
    my.out_php_argument.zend_type = my._zend_type
    my.out_php_argument.instance = my._instance
    my.out_function.num_arguments = my._count

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_return (in_method, in_php_project, out_php_method)
    check_arguments (my, "in_method, in_php_project, out_php_method", my)

    my._return_type0 = ""
    my._return_type = "IS_VOID"
    my._return_zend_type = "NOT IMPLEMENTED"
    my._return_data = ""
    my._instance = 0
    my._throw_exception = 0
    my._argument_buffer_count = 0

    for my.in_method.argument as argument0 where defined (argument0.class)
        if argument0.class = "buffer"
            my._argument_buffer_count = my._argument_buffer_count + 1
        endif
    endfor

    if my._argument_buffer_count = 1
        my._return_type = "IS_STRING"
    elsif my._argument_buffer_count > 1
        my._return_type = "IS_ARRAY"
    endif

    for my.in_method.return as return0

        if defined (return0.type)
            if return0.type = "size" | return0.type = "integer" | return0.type = "unsigned"
                my._return_type0 = return0.type
                my._return_type = "int"
                my._return_zend_type = "IS_LONG"
            elsif return0.type = "boolean"
                my._return_type0 = return0.type
                my._return_type = "bool"
                my._return_zend_type = "IS_BOOLEAN"
            elsif return0.type = "byte"
                my._return_type0 = return0.type
                my._return_type = "string"
                my._return_zend_type = "IS_STRING"
            else
                # TODO
                echo_debug_item(my.in_method)
                echo_debug_item(return0)
                echo_fatal("Not implemented (101)", my)
            endif
        endif

        my._r = ""

        if defined (return0.class)
            if return0.class = "data"
                my._return_type0 = return0.class
                my._return_type = "string"
            else
                my._r = return0.class
                my._instance = 1
            endif
        elsif defined (return0.interface)
            my._r = return0.interface
            my._instance = 1
        endif

        if (defined (return0.class) & return0.class <> "data") | defined (return0.interface)
            my._return_type = "$(my._r:c)"
        endif

        if defined (return0.enum)
            if return0.enum = "status"
                my._throw_exception = 1
            else
                my._return_type = "$(return0.enum:c)"
                my._instance = 1
            endif
        endif
    endfor

    my.out_php_method.return_type0 = my._return_type0
    my.out_php_method.return_type = my._return_type
    my.out_php_method.return_zend_type = my._return_zend_type
    my.out_php_method.return_data = my._return_data
    my.out_php_method.instance = my._instance
    my.out_php_method.throw_exception = my._throw_exception

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_low_level_extension (in_php_project, out_php_module)
    check_arguments (my, "in_php_project, out_php_module", my)

    my._include = ""
    my._registered_resources = ""
    my._constants = ""
    my._init_func_def_dtor = ""
    my._init_func_def_list_destr = ""
    my._def_func_entries = ""
    my._func_wrapping = ""

    my._ext_name0 = "$(my.in_php_project.prefix:)_$(my.in_php_project.name:)_php"

    for my.in_php_project.php_module as php_module0 where string_in(php_module0.type, "class, implementation, interface")
        my._include += php_module0->low_level->include.
        my._registered_resources += php_module0->low_level->registered_resource.
        my._constants += php_module0->low_level->constant.
        my._init_func_def_dtor += php_module0->low_level->init_func_def_dtor.
        my._init_func_def_list_destr += php_module0->low_level->init_func_def_list_destr.

        for php_module0->low_level.function as function0
            my._func_wrapping += format_left(function0->wrapper->arg_info., 0)
            my._def_func_entries += function0->def_func_entry.

            if defined(function0->wrapper->custom_code)
                my._func_wrapping += "\n" + format_left(function0->wrapper->custom_code., 0)
            else
                my._func_wrapping += "\n" + function0->wrapper->header.
            endif

            my._func_wrapping += "\n"
        endfor
    endfor

    new licence to my.out_php_module
        my._res = php_format_extension_comment (my.in_php_project->license)
        . = my._res
    endnew

    new include to my.out_php_module
        my._res = format_left("\
            #include <php.h>
            #include <zend_exceptions.h>
            #include <zend_list.h>
            #include \"vsce_assert.h\"
            #include \"vsce_phe_common.h\"
            ", 0)

        my._res = my._res + my._include

        . = my._res
    endnew

    new constants to my.out_php_module

        my._ext_name = "$(my._ext_name0:UPPER)"

        my._c = php_format_extension_comment ("Constants")
        my._h = format_left("\
            const char $(my._ext_name:)_VERSION[] = \"$(my.in_php_project.version:)\";
            const char $(my._ext_name:)_EXTNAME[] = \"$(my._ext_name0:)\"; 
            ", 0)
        my._res = my._c + my._h + my._constants
        . = my._res
    endnew

    new registered_resources to my.out_php_module
        my._c = php_format_extension_comment ("Registered resources")
        my._res = my._c + my._registered_resources
        . = my._res
    endnew

    new init_func_declaration to my.out_php_module

        my._c = php_format_extension_comment ("Extension init functions declaration")
        my._h = format_left("\
            PHP_MINIT_FUNCTION($(my._ext_name0:));
            PHP_MSHUTDOWN_FUNCTION($(my._ext_name0:));
            ", 0)
        my._res = my._c + my._h
        . = my._res
    endnew

    new func_wrapping to my.out_php_module
        my._c = php_format_extension_comment ("Functions wrapping")
        my._h = my._func_wrapping
        my._res = my._c + my._h
        . = my._res
    endnew

    new define_all_func_entries to my.out_php_module
        my._c = php_format_extension_comment ("Define all function entries")

        my._h1 = format_left("static zend_function_entry $(my._ext_name0:)_functions[] = {", 0)
        my._h2 = format_left("$(my._def_func_entries:)", 1)
        my._h3 = format_left("\
                PHP_FE_END
            };
            ", 0)

        my._res = my._c + my._h1 + my._h2 + my._h3

        . = my._res
    endnew

    new module_definitions to my.out_php_module
        my._c = php_format_extension_comment ("Extension module definition")
        my._h = format_left("\
            zend_module_entry $(my._ext_name0:)_module_entry = {
            #if ZEND_MODULE_API_NO >= 20010901
                STANDARD_MODULE_HEADER,
            #endif
                $(my._ext_name0:UPPER)_EXTNAME,
                $(my._ext_name0:)_functions,
                PHP_MINIT($(my._ext_name0:)),
                PHP_MSHUTDOWN($(my._ext_name0:)),
                NULL,
                NULL,
                NULL,
            #if ZEND_MODULE_API_NO >= 20010901
                $(my._ext_name0:UPPER)_VERSION,
            #endif
                STANDARD_MODULE_PROPERTIES
            };

            ZEND_GET_MODULE($(my._ext_name0:))
            ", 0)

        my._res = my._c + my._h
        . = my._res
    endnew

    new init_func_definitions to my.out_php_module
        my._c = php_format_extension_comment ("Extension init functions definition")

        my._h1 = format_left("$(my._init_func_def_dtor:)", 0)
        my._h2 = format_left("PHP_MINIT_FUNCTION($(my._ext_name0:)) {", 0)
        my._h3 = format_left("$(my._init_func_def_list_destr:)", 1)

        my._h4 = format_left("\
                return SUCCESS;
            }
            ", 0)

        my._h5 = format_left("\
            PHP_MSHUTDOWN_FUNCTION($(my._ext_name0:)) {
                return SUCCESS;
            }
            ", 0)

        my._res = my._c + my._h1 + my._h2 + my._h3 + my._h4 + my._h5

        . = my._res
    endnew

endfunction
.endtemplate

.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Define names that are are used for creating 'Interface' and / or
#   'Implementation' modules.
#
#   Private function prefix is: L17.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"
gsl from "c_formatter.gsl"

function _L17_resolve_names_scope (names_scope)
    if ! defined (my.names_scope)
        my.names_scope = XML.new ("names")
    endif

    return my.names_scope
endfunction


function _L17_add_link (links, name, uid)
    check_argument (my, "links")
    check_argument (my, "name")

    if ! defined (my.uid)
        my.uid = c_format_name (my.name)
        echo_debug ("Derived <uid = \"$(my.uid:)\"/> from the <name = \"$(my.name)\"/>.", my)
    endif

    new link to my.links
        .name = c_format_name (my.name)
        .uid = my.uid
        .ref = ref (my.uid)
        .c_ref = c_ref (my.uid)
    endnew
endfunction

function _L17_add_link_by_name (links, name)
    check_argument (my, "links")
    check_argument (my, "name")

    _L17_add_link (my.links, my.name, c_format_name (my.name))
endfunction

# ###########################################################################
#   NAMEs
# ###########################################################################

function c_names_create (names_scope)
    my.names_scope = _L17_resolve_names_scope (my.names_scope)

    scope my.names_scope
        .class_api = "api"
        .class_impl = "impl"
        .class_library = "library"

        .module_api = .class_api
        .module_api_private = cat (.module_api, "private")
        .module_impl = .class_impl
        .module_impl_private = cat (.module_impl, "private")
        .module_library = .class_library

        .struct_info = "info"
        .struct_context = "context"

        .method_api = "api"
        .method_cleanup = "cleanup"
        .method_destroy = "destroy"

        .enum_tag = "tag"
        .enum_value_begin = "begin"
        .enum_value_end = "end"

        .argument_api_tag = "api tag"
        .argument_impl = "impl"

        .property_info = "info"
        .property_api_tag = "api tag"
        .property_api_array = "api array"
        .property_impl_tag = "impl tag"
        .property_context = "context"
    endscope

    return my.names_scope
endfunction


function c_names_update_with_interface (names, interface)
    check_argument (my, "names")
    check_argument (my, "interface")

    assert_attribute (my.names, "class_api", my)

    scope my.names
        .class_interface = my.interface.name
        .class_interface_api = cat (my.interface.name, .class_api)

        .module_interface = .class_interface
        .module_interface_api = cat (.class_interface_api, "private")

        .property_interface = .class_interface

        .argument_interface = .class_interface
        .argument_interface_api = cat (my.interface.name, .class_api)
    endscope
endfunction


function c_names_update_with_dependency (names, dependency)
    check_argument (my, "names")
    check_argument (my, "dependency")

    assert_attribute (my.names, "class_api", my)

    if defined (my.dependency.interface)
        my.dependency_class = my.dependency.interface
    else
        my.dependency_dump = my.dependency.string ()
        echo_fatal ("Unsupported dependency: $(my.dependency_dump:)", my)
    endif

    scope my.names
        .class_dependency = my.dependency_class
        .property_dependency = .class_dependency
        .property_dependency_ownership = cat (.property_dependency, "ownership")
    endscope
endfunction


function c_names_update_with_implementation (names, implementation)
    check_argument (my, "names")
    check_argument (my, "implementation")

    my.name = is_true (my.implementation.is_default) ?? my.implementation.name ? \
                my.implementation.full_name

    scope my.names
        .class_implementation = my.name
        .module_implementation = .class_implementation

        .class_implementation_private = .class_implementation
        .module_implementation_private = cat (.class_implementation_private, "private")
    endscope
endfunction


function c_names_update_with_implemented_interface (names, implementated_interface)
    check_argument (my, "names")
    check_argument (my, "implementated_interface")

    assert_attribute (my.names, "class_implementation", my)
    assert_attribute (my.names, "module_implementation", my)

    scope my.names
        .class_implemented_interface = \
                cat (0.class_implementation, my.implementated_interface.name)

        .module_implemented_interface = \
                cat (0.class_implementation, my.implementated_interface.name)
    endscope
endfunction


function c_names_update_with_inherited_interface (names, inherit)
    check_argument (my, "names")
    check_argument (my, "inherit")

    assert_attribute (my.names, "class_api", my)

    scope my.names
        .class_inherited_interface = cat (my.inherit.interface, .class_api)
        .property_inherited_interface = cat (my.inherit.interface, .class_api)
    endscope
endfunction

# ###########################################################################
#   UIDs
# ###########################################################################

function _L17_add_argument_links (links, names)
    check_argument (my, "links")
    check_argument (my, "names")

    _L17_add_link_by_name (my.links, cat ("argument", my.names.argument_impl))

    _L17_add_link_by_name (my.links, cat ("argument", my.names.argument_api_tag))

    if defined (my.names.argument_interface_api)
        _L17_add_link (my.links, "argument interface api", c_format_name ( \
                "argument", my.names.argument_interface_api))
    endif
endfunction


function _L17_add_property_links (links, names)
    check_argument (my, "links")
    check_argument (my, "names")

    _L17_add_link_by_name (my.links, cat ("property", my.names.property_info))

    _L17_add_link_by_name (my.links, cat ("property", my.names.property_api_tag))

    _L17_add_link_by_name (my.links, cat ("property", my.names.property_api_array))

    _L17_add_link_by_name (my.links, cat ("property", my.names.property_impl_tag))

    _L17_add_link_by_name (my.links, cat ("property", my.names.property_context))

    _L17_add_link_by_name (my.links, \
            cat ("property", "self", my.names.method_cleanup, "cb"))

    _L17_add_link_by_name (my.links, \
            cat ("property", "self", my.names.method_destroy, "cb"))

    if defined (my.names.property_inherited_interface)
        _L17_add_link (my.links, "property inherited interface", c_format_name ( \
                "property", my.names.property_inherited_interface))
    endif

    if defined (my.names.property_interface)
        _L17_add_link (my.links, "property interface", c_format_name ( \
                "property", my.names.property_interface))
    endif

    if defined (my.names.property_dependency)
        _L17_add_link (my.links, "property dependency", c_format_name ( \
                "property", my.names.property_dependency))
    endif

    if defined (my.names.property_dependency_ownership)
        _L17_add_link (my.links, "property dependency ownership", c_format_name ( \
                "property", my.names.property_dependency_ownership))
    endif
endfunction


function _L17_add_type_links (links, names)
    check_argument (my, "links")
    check_argument (my, "names")

    assert_attribute (my.names, "class_api", my)
    assert_attribute (my.names, "class_impl", my)
    assert_attribute (my.names, "struct_info", my)
    assert_attribute (my.names, "enum_tag", my)
    assert_attribute (my.names, "enum_value_begin", my)
    assert_attribute (my.names, "enum_value_end", my)

    _L17_add_link (my.links, "type api", c_format_name ( \
            "class", my.names.class_api, \
            "struct"))

    _L17_add_link (my.links, "type impl", c_format_name ( \
            "class", my.names.class_impl, \
            "struct"))

    _L17_add_link (my.links, "type api tag", c_format_name ( \
            "class", my.names.class_api, \
            "enum", my.names.enum_tag))

    _L17_add_link (my.links, "constant api tag begin", c_format_name ( \
            "class", my.names.class_api, \
            "enum", my.names.enum_tag, \
            "value", my.names.enum_value_begin))

    _L17_add_link (my.links, "constant api tag end", c_format_name ( \
            "class", my.names.class_api, \
            "enum", my.names.enum_tag, \
            "value", my.names.enum_value_end))

    _L17_add_link (my.links, "type impl tag", c_format_name ( \
            "class", my.names.class_impl, \
            "enum", my.names.enum_tag))

    _L17_add_link (my.links, "constant impl tag begin", c_format_name ( \
            "class", my.names.class_impl, \
            "enum", my.names.enum_tag, \
            "value", my.names.enum_value_begin))

    _L17_add_link (my.links, "constant impl tag end", c_format_name ( \
            "class", my.names.class_impl, \
            "enum", my.names.enum_tag, \
            "value", my.names.enum_value_end))

    _L17_add_link (my.links, "type impl info", c_format_name ( \
            "class", my.names.class_impl, \
            "struct", my.names.struct_info))

    if defined (my.names.class_interface)
        assert_attribute (my.names, "class_interface_api")

        _L17_add_link (my.links, "type interface api", c_format_name ( \
                "class", my.names.class_interface_api, \
                "struct"))

        _L17_add_link (my.links, "constant interface tag", c_format_name (\
                "class", my.names.class_api, \
                "enum", my.names.enum_tag, \
                "value", my.names.class_interface))
    endif

    if defined (my.names.class_implementation)
        assert_attribute (my.names, "struct_context", my)

        _L17_add_link (my.links, "type implementation", c_format_name ( \
                "class", my.names.class_implementation, \
                "struct"))

        _L17_add_link (my.links, "type implementation context", c_format_name ( \
                "class", my.names.class_implementation_private, \
                "struct", my.names.struct_context))
    endif

    if defined (my.names.class_inherited_interface)
        _L17_add_link (my.links, "type inherited interface", c_format_name ( \
                "class", my.names.class_inherited_interface, \
                "struct"))
    endif

    if defined (my.names.class_dependency)
        _L17_add_link (my.links, "type dependency", c_format_name ( \
                "class", my.names.class_impl, \
                "struct"))
    endif

endfunction


function _L17_add_method_links (links, names)
    check_argument (my, "links")
    check_argument (my, "names")

    _L17_add_link (my.links, "method impl api", c_format_name ( \
            "class", my.names.class_impl, \
            "method", my.names.method_api))

    if defined (my.names.class_interface)
        _L17_add_link (my.links, "method interface api", c_format_name ( \
                "class", my.names.class_interface, \
                "method", my.names.method_api))
    endif
endfunction


function c_links_create (names)
    check_argument (my, "names")

    my.links = XML.new ("links")

    _L17_add_argument_links (my.links, my.names)
    _L17_add_property_links (my.links, my.names)
    _L17_add_type_links (my.links, my.names)
    _L17_add_method_links (my.links, my.names)

    return my.links
endfunction

function c_links_update_with_implementation (links, implementation, names)
    check_argument (my, "links")
    check_argument (my, "implementation")
    check_argument (my, "names")

    _L17_add_link (my.links, "type implementation", c_format_name ( \
            "class", my.names.class_implementation, \
            "struct"))

    _L17_add_link (my.links, "type implementation context", c_format_name ( \
            "class", my.names.class_implementation_private, \
            "struct", my.names.struct_context))

    _L17_add_link (my.links, "constant implementation $(constant.name)", c_format_name ( \
            my.implementation_uid, "enum", my.names.enum_tag, "value", constant.name))
endfunction


function c_uids_create (names)
    check_argument (my, "names")

    my.links = c_links_create (my.names)
    my.uids = XML.new ("uids")

    for my.links.link
        my.uids.$(link.name:) = link.uid
    endfor

    return my.uids
endfunction


function c_refs_create (names)
    check_argument (my, "names")

    my.links = c_links_create (my.names)
    my.refs = XML.new ("refs")

    for my.links.link
        my.refs.$(link.name:) = link.ref
        my.refs.c_$(link.name:) = link.c_ref
    endfor

    return my.refs
endfunction

.endtemplate

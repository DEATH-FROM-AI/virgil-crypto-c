.template 0
#   Copyright (C) 2015-2019 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

gsl from "common.gsl"
gsl from "wrapper_helpers.gsl"
gsl from "wasm_format.gsl"
gsl from "wasm_derive.gsl"
gsl from "wasm_codegen.gsl"


# ===========================================================================
#   Map types.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Derive Swift type from the <instance/> type attributes.
# ---------------------------------------------------------------------------
function wasm_derive_instance_type(instance)
    check_arguments(my, "instance", my)

    if defined(my.instance.type)
        if my.instance.type = "nothing"
            my.primitive_type = "undefined"

        elsif my.instance.type = "boolean"
            my.primitive_type = "boolean"

        elsif my.instance.type = "char"
            my.primitive_type = "string"

        else
            my.primitive_type = "number"
        endif

        if count(my.instance.array)
            my.primitive_type = "object"
        endif

        return my.primitive_type

    elsif defined(my.instance.class)

        if my.instance.class = "data" | my.instance.class = "buffer"
            return "Uint8Array"
        else
            return "function"
        endif

    elsif defined(my.instance.impl)
            return "function"

    elsif defined(my.instance.interface)
            return "function"

    elsif defined(my.instance.enum)
            return "function"

    else
        my.instance_dump = component_instance_dump(my.instance)
        echo_warning("Unreachable code, component_resolve_instance() must handle this. $(my.instance_dump:)", my)
        return "Unknown"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <wasm_instance type=""/> attributes.
# ---------------------------------------------------------------------------
function wasm_map_instance_type(instance, wasm_instance)
    check_arguments(my, "instance, wasm_instance", my)

    my.wasm_instance.type = wasm_derive_instance_type(my.instance)
    wrapper_map_instance_type_info(my.instance, my.wasm_instance)
endfunction


# ===========================================================================
#   Component creation.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Create class <wasm_constant/> from the entity <constant/>.
# ---------------------------------------------------------------------------
function wasm_create_class_constant(constant, wasm_class)
    check_arguments(my, "constant, wasm_class", my)

    assert_attributes(my.constant, "name, value", my)

    new wasm_constant to my.wasm_class
        . = wasm_format_description(my.constant) ?
        .name = wasm_derive_constant_name(my.constant)
        .value = my.constant.value
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create enumeration <wasm_constant/> from the entity <constant/>
# ---------------------------------------------------------------------------
function wasm_create_enum_constant(constant, constant_value, wasm_enum)
    check_arguments(my, "constant, constant_value, wasm_enum", my)

    assert_attribute(my.constant, "name", my)

    new wasm_constant to my.wasm_enum
        . = wasm_format_description(my.constant) ?
        .name = wasm_derive_constant_name(my.constant)
        .value = my.constant_value
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class default constructor.
# ---------------------------------------------------------------------------
function wasm_create_class_default_constructor(class, wasm_class)
    check_arguments(my, "class, wasm_class", my)

    new wasm_constructor to my.wasm_class
        . = "\
            /**
             * Create object with underlying C context.
             *
             * Note. Parameter 'ctxPtr' SHOULD be passed from the generated code only.
             */
        "

        new wasm_argument to wasm_constructor
            .name = "ctxPtr"
            .default = "undefined"
        endnew

        new wasm_code to wasm_constructor
            . = "\
                this.name = '$(my.wasm_class.name:)';

                if (typeof ctxPtr === 'undefined') {
                    this.ctxPtr = Module._$(class_derive_c_constructor(my.class))();
                } else {
                    this.ctxPtr = ctxPtr;
                }
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class constructors with given C context.
# ---------------------------------------------------------------------------
function wasm_create_class_constructors_with_c_context(class, wasm_class)
    check_arguments(my, "class, wasm_class", my)

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by making it's shallow copy.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndUseCContext"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"
        endnew

        new wasm_code to wasm_method
            . = "\
                // assert(typeof ctxPtr === 'number');
                return new $(my.wasm_class.name:)(Module._$(class_derive_c_method_shallow_copy(my.class))(ctxPtr));
            "
        endnew
    endnew

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by taking it ownership.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndTakeCContext"
        .default="undefined"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"
        endnew

        new wasm_code to wasm_method
            . = "\
                // assert(typeof ctxPtr === 'number');
                return new $(my.wasm_class.name:)(ctxPtr);
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class default destructor.
# ---------------------------------------------------------------------------
function wasm_create_class_destructor(class, wasm_class)
    check_arguments(my, "class, wasm_class", my)

    new wasm_method to my.wasm_class
        . = "
            /**
             * Release underlying C context.
             */
        "
        .name = "delete"

        new wasm_code to wasm_method
            . = "\
                if (typeof this.ctxPtr !== 'undefined' && this.ctxPtr !== null) {
                    Module._$(class_derive_c_destructor(my.class))(this.ctxPtr);
                    this.ctxPtr = null;
                }
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class custom constructor.
# ---------------------------------------------------------------------------
function wasm_create_class_constructor(class, constructor, wasm_class)
    check_arguments(my, "class, constructor, wasm_class", my)

    #   TODO: Implement me.
endfunction

# ---------------------------------------------------------------------------
#   Add dependency setter as <wasm_method/>.
# ---------------------------------------------------------------------------
function wasm_create_class_dependency_method(dependency, class, wasm_class, wasm_project)
    check_arguments(my, "dependency, class, wasm_class, wasm_project", my)

    new wasm_method to my.wasm_class
        . = wasm_format_description(my.dependency) ?
        .name = wasm_derive_method_name_str(my.dependency.name)
        .is_setter = "1"

        my.arg_name = wasm_derive_method_argument_name(my.dependency)

        new wasm_argument to wasm_method
            .name = my.arg_name
        endnew

        new wasm_code to wasm_method
            if my.dependency.has_observers & my.dependency.is_observers_return_status
                my.result_var = "const proxyStatus = "
                my.enum_status = wasm_derive_error_class_name(my.wasm_project)
                my.impl_handle_status = "$(my.enum_status:).handleStatusCode(proxyStatus)"
            endif

            . = format_left("\
                Module._$(class_derive_c_method_release_dependency(my.class, my.dependency))(this.ctxPtr)
                $(my.result_var?:)Module._$(class_derive_c_method_use_dependency(my.class, my.dependency))(this.ctxPtr,\
                        $(my.arg_name:).ctxPtr)
                $(my.impl_handle_status?:)
            ")
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_primitive_type(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)
        .code_precondition = "// assert(typeof $(wasm_argument.name:) === '$(wasm_argument.type:)')"
        my.wasm_method.c_arg_list += 0.name + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_data(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)

        .name = wasm_derive_method_argument_name(my.argument)

        .code_precondition = "// assert(typeof $(wasm_argument.name:) === 'Uint8Array')"

        .code_initialize = "\
            //  Copy bytes from JS memory to the WASM memory.
            const $(0.name:)Size = $(0.name:).length * $(0.name:).BYTES_PER_ELEMENT;
            const $(0.name:)Ptr = Module._malloc($(0.name:)Size);
            Module.HEAP8.set($(0.name:), $(0.name:)Ptr);

            //  Create C structure vsc_data_t.
            const $(0.name:)CtxSize = Module._vsc_data_ctx_size();
            const $(0.name:)CtxPtr = Module._malloc($(0.name:)CtxSize);

            //  Point created vsc_data_t object to the copied bytes.
            Module._vsc_data($(0.name:)CtxPtr, $(0.name:)Ptr, $(0.name:)Size);
        "

        .code_finalize = "\
            Module._free($(0.name:)Ptr);
            Module._free($(0.name:)CtxPtr);
        "

        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_writeonly_buffer(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_return)
        .name = wasm_derive_method_argument_name(my.argument)

        .code_initialize = "\
            const $(0.name:)Size = $(wasm_derive_buffer_length_getter(my.argument, my.wasm_class));
            const $(0.name:)CtxPtr = Module._vsc_buffer_new_with_capacity($(0.name:)Size);
        "

        .code_on_success = "\
            const $(0.name:)Ptr = Module._vsc_buffer_bytes($(0.name:)CtxPtr);
            const $(0.name:) = Module.HEAPU8.slice($(0.name:)Ptr, $(0.name:)Ptr + $(0.name:)Size);
        "

        .code_finalize = "\
            Module._vsc_buffer_delete($(0.name:)CtxPtr);
        "

        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_readwrite_buffer(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)

        .code_precondition = "// assert(typeof $(wasm_argument.name:) === 'Uint8Array')"

        .code_initialize = "\
            //  Copy bytes from JS memory to the WASM memory.
            const $(0.name:)Size = $(0.name:).length * $(0.name:).BYTES_PER_ELEMENT;
            const $(0.name:)Ptr = Module._malloc($(0.name:)Size);
            Module.HEAP8.set($(0.name:), $(0.name:)Ptr);

            //  Create C structure vsc_buffer_t.
            const $(0.name:)CtxPtr = Module._vsc_buffer_new();

            //  Point created vsc_buffer_t object to the copied bytes.
            Module._vsc_buffer_use($(0.name:)CtxPtr, $(0.name:)Ptr, $(0.name:)Size);
        "

        .code_finalize = "\
            Module._vsc_buffer_delete($(0.name:)CtxPtr);
        "

        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_return)
        .name = "$(wasm_derive_method_argument_name(my.argument))Result"

        .code_on_success = "\
            const $(0.name:)Ptr = Module._vsc_buffer_bytes($(0.name:)CtxPtr);
            const $(0.name:)Result = Module.HEAPU8.slice($(0.name:)Ptr, $(0.name:)Ptr + $(0.name:)Size);
        "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_class(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)

        my.wasm_method.c_arg_list += "$(0.name:).ctxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_interface(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)

        my.wasm_method.c_arg_list += "$(0.name:).ctxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_enum(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)

        my.wasm_method.c_arg_list += "$(0.name:)" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_primitive_type(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.return, wasm_return)

        if wasm_return.type = "boolean"
            wasm_return.name = "booleanResult"
            wasm_return.code_on_success = "\
                const booleanResult = !!proxyResult;
            "
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_data(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.return, wasm_return)
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_disown_buffer(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.return, wasm_return)
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_class(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.return, wasm_return)
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_interface(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.return, wasm_return)
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_enum(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.return, wasm_return)
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Create class method as <wasm_method/>.
# ---------------------------------------------------------------------------
function wasm_create_class_method(method, class, wasm_class, wasm_project)
    check_arguments(my, "method, class, wasm_class, wasm_project", my)

    new wasm_method to my.wasm_class
        . = wasm_format_description(my.method) ?
        .name = wasm_derive_method_name(my.method)
        .interface = my.method.interface ? #   When method comes from an interface.

        .c_method = "Module._$(class_derive_c_method(my.class, my.method))"
        .c_arg_list = ""

        if is_false(my.method.is_static)
            wasm_method.c_arg_list += "this.ctxPtr, "
        endif

        if ! defined(my.method.interface)
            #   Method can be static only if it doesn't come from an interface.
            .is_static = my.method.is_static ?
        endif

        #
        #   Wrap arguments:
        #       - [x] Wrap primitive types.
        #       - [x] Wrap class "data"
        #       - [x] Wrap class "buffer"
        #           - [x] writeonly
        #           - [x] readwrite
        #       - [x] Wrap class
        #           - [x] readonly
        #           - [x] readwrite
        #           - [ ] disown
        #       - [x] Wrap impl
        #           - [x] readonly
        #           - [x] readwrite
        #           - [ ] disown
        #       - [x] Wrap interface
        #           - [x] readonly
        #           - [x] readwrite
        #           - [ ] disown
        #       - [x] Wrap enum
        #           - [x] readonly
        #       - [ ] Wrap class "error"
        #           - [ ] readwrite
        #
        for my.method.argument
            if defined(argument.type) & is_false(argument.is_reference)
                wasm_create_method_argument_for_primitive_type(argument, wasm_method, my.wasm_class)

            elsif string_equal(argument.class, "data")
                wasm_create_method_argument_for_data(argument, wasm_method, my.wasm_class)

            elsif string_equal(argument.class, "buffer") & argument.access = "writeonly"
                wasm_create_method_argument_for_writeonly_buffer(argument, wasm_method, my.wasm_class)

            elsif string_equal(argument.class, "buffer") & argument.access = "readwrite"
                wasm_create_method_argument_for_readwrite_buffer(argument, wasm_method, my.wasm_class)

            elsif string_equal(argument.class, "buffer") & argument.access = "readonly"
                echo_fatal("Buffers with readonly access are prohibited.", my)

            elsif defined(argument.class) | defined(argument.impl)
                wasm_create_method_argument_for_class(argument, wasm_method, my.wasm_class)

            elsif defined(argument.interface)
                wasm_create_method_argument_for_interface(argument, wasm_method, my.wasm_class)

            elsif defined(argument.enum)
                wasm_create_method_argument_for_enum(argument, wasm_method, my.wasm_class)
            else
                my.argument_dump = component_instance_dump(argument)
                echo_fatal("Unexpected argument:  $(my.argument_dump:)", my)
            endif
        endfor

        #
        #   Wrap return:
        #       [ ] Wrap primitive type
        #       [ ] Wrap class "data"
        #       [ ] Wrap class "buffer"
        #           - [ ] disown
        #       [ ] Wrap class
        #       [ ] Wrap impl
        #       [ ] Wrap interface
        #       [x] Wrap enum "status"
        #
        for my.method.return where ! wrapper_instance_is_status(return)
            if defined(return.type)
                wasm_create_method_return_for_primitive_type(return, wasm_method, my.wasm_class)

            elsif string_equal(return.class, "data")
                wasm_create_method_return_for_data(return, wasm_method, my.wasm_class)

            elsif string_equal(return.class, "buffer") & return.access = "disown"
                wasm_create_method_return_for_disown_buffer(return, wasm_method, my.wasm_class)

            elsif defined(return.class) | defined(return.impl)
                wasm_create_method_return_for_class(return, wasm_method, my.wasm_class)

            elsif defined(return.interface)
                wasm_create_method_return_for_interface(return, wasm_method, my.wasm_class)

            elsif defined(return.enum)
                wasm_create_method_return_for_enum(return, wasm_method, my.wasm_class)
            else
                my.return_dump = component_instance_dump(return)
                echo_fatal("Unexpected return:  $(my.return_dump:)", my)
            endif
        endfor

        #
        #   Create method body.
        #

        #   Initialize locals.
        my.code = ""
        for wasm_method.wasm_argument where defined(wasm_argument.code_precondition)
            my.code += format_left(wasm_argument.code_precondition)
        endfor

        for wasm_method.wasm_argument where defined(wasm_argument.code_initialize)
            my.code += terminator + format_left(wasm_argument.code_initialize)
        endfor

        for wasm_method.wasm_return where defined(wasm_return.code_initialize)
            my.code += terminator + format_left(wasm_return.code_initialize)
        endfor

        my.c_arg_list = string_rtrim_symbol(wasm_method.c_arg_list, ",")
        my.return_statement = count(my.method.return) ?? "const proxyResult = " ?

        #   Proxy invocation.
        my.has_finalizer = count(wasm_method.wasm_argument, defined(wasm_argument.code_finalize)) + \
                           count(wasm_method.wasm_return, defined(wasm_return.code_finalize))

        my.proxy_indent = my.has_finalizer ?? 1 ? 0

        if my.has_finalizer
            my.code += terminator + format_left("try {")
        endif
        my.code += format_left("\
            $(my.return_statement?:)$(wasm_method.c_method:)($(my.c_arg_list:));
        ", my.proxy_indent)

        #   Handle errors.
        my.status_return = my.method->return(string_equal(return.enum, "status")) ?
        if defined(my.status_return)
            my.class_error_name = wasm_derive_error_class_name_from_instance(my.status_return, my.wasm_project)
            my.code += format_left("
                $(my.class_error_name:).handleStatusCode(proxyResult)
            ", my.proxy_indent)
        endif

        for wasm_method.wasm_return where defined(wasm_return.code_on_success)
            my.code += terminator + format_left(wasm_return.code_on_success, my.proxy_indent)
        endfor

        #   Return result.
        for wasm_method.wasm_return
            my.return_list ?= ""
            my.return_list += wasm_return.name ? "proxyResult"
            if ! last()
                my.return_list += ", "
            endif
        endfor

        if count(wasm_method.wasm_return) = 1
            my.code += format_left("return $(my.return_list:);", my.proxy_indent)
        elsif count(wasm_method.wasm_return) > 1
            my.code += format_left("return { $(my.return_list:) };", my.proxy_indent)
        endif

        #   Cleanup.
        if my.has_finalizer
            my.code += format_left("} finally {")

            for wasm_method.wasm_argument where defined(wasm_argument.code_finalize)
                my.code += format_left(wasm_argument.code_finalize, my.proxy_indent)
            endfor

            for wasm_method.wasm_return where defined(wasm_return.code_finalize)
                my.code += format_left(wasm_return.code_finalize, my.proxy_indent)
            endfor

            my.code += format_left("}")
        endif

        #   Assign code.
        new wasm_code to wasm_method
            . = (my.code = "") ?? "//  TODO: Implement me." ? my.code
        endnew
    endnew
endfunction

# ===========================================================================
#   Module creation.
# ===========================================================================

#  --------------------------------------------------------------------------
function wasm_resolve_wrapper(wrapper)
    check_arguments(my, "wrapper", my)

endfunction

#  --------------------------------------------------------------------------
function wasm_create_project_module(project, wrapper)
    check_arguments(my, "project, wrapper", my)

    new wasm_project to my.wrapper
        . = my.project. ?
        .name = my.project.name
        .prefix = my.project.prefix
        .source_dir = cat_path(my.wrapper.source_dir, 0.name)

        copy my.project->license to wasm_project

        return wasm_project
    endnew
endfunction

#  --------------------------------------------------------------------------
function wasm_create_custom_modules(source, wasm_project, meta)
    check_arguments(my, "source, wasm_project, meta", my)

endfunction

#  --------------------------------------------------------------------------
function wasm_create_interface_module(interface, wasm_project, meta)
    check_arguments(my, "interface, wasm_project, meta", my)

endfunction

# ---------------------------------------------------------------------------
#   Create language specific module that will represent implementation.
# ---------------------------------------------------------------------------
function wasm_create_implementation_module(impl, wasm_project, meta)
    check_arguments(my, "impl, wasm_project, meta", my)

    assert_attribute(my.impl, "name", my)

    echo_info("Create <wasm_module/> from implementation: '$(my.impl.name:)'", my)

    new wasm_module to my.wasm_project
        .name = wasm_derive_module_name(my.impl)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_class to wasm_module
            . = wasm_format_description(my.impl) ?
            .name = wasm_derive_class_name(my.impl)

            for my.impl.constant where wrapper_should_wrap_class_constant(constant)
                wasm_create_class_constant(constant, wasm_class)
            endfor

            if my.impl.context <> "none" & my.impl.lifecycle <> "none"
                wasm_create_class_default_constructor(my.impl, wasm_class)
                wasm_create_class_constructors_with_c_context(my.impl, wasm_class)
                wasm_create_class_destructor(my.impl, wasm_class)

                for my.impl.constructor where wrapper_should_wrap_method(constructor)
                    wasm_create_class_constructor(my.impl, constructor, wasm_class)
                endfor
            endif

            for my.impl.dependency
                wasm_create_class_dependency_method(dependency, my.impl, wasm_class, my.wasm_project)
            endfor

            for my.impl.interface
                for interface.constant
                    wasm_create_class_constant(constant, wasm_class)
                endfor

                for interface.method
                    wasm_create_class_method(method, my.impl, wasm_class, my.wasm_project)
                endfor
            endfor

            for my.impl.method where wrapper_should_wrap_method(method)
                wasm_create_class_method(method, my.impl, wasm_class, my.wasm_project)
            endfor
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create language specific module that will represent class.
# ---------------------------------------------------------------------------
function wasm_create_class_module(class, wasm_project, meta)
    check_arguments(my, "class, wasm_project, meta", my)

    assert_attribute(my.class, "name", my)

    if string_in(my.class.name, "error")
        #   Do not generate classes that can be mapped to the built-in types.
        return
    endif

    echo_info("Create <wasm_module/> from class: '$(my.class.name:)'", my)

    new wasm_module to my.wasm_project
        .name = wasm_derive_module_name(my.class)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_class to wasm_module
            . = wasm_format_description(my.class) ?
            .name = wasm_derive_class_name(my.class)

            for my.class.constant where wrapper_should_wrap_class_constant(constant)
                wasm_create_class_constant(constant, wasm_class)
            endfor

            if my.class.context <> "none" & my.class.lifecycle <> "none"
                wasm_create_class_default_constructor(my.class, wasm_class)
                wasm_create_class_constructors_with_c_context(my.class, wasm_class)
                wasm_create_class_destructor(my.class, wasm_class)

                for my.class.constructor where wrapper_should_wrap_method(constructor)
                    wasm_create_class_constructor(my.class, constructor, wasm_class)
                endfor
            endif

            for my.class.dependency
                wasm_create_class_dependency_method(dependency, my.class, wasm_class, my.wasm_project)
            endfor

            for my.class.method where wrapper_should_wrap_method(method)
                wasm_create_class_method(method, my.class, wasm_class, my.wasm_project)
            endfor
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module with WebAssembly error from the "status" enum.
# ---------------------------------------------------------------------------
function wasm_create_error_module(enum, wasm_project, meta)
    check_arguments(my, "enum, wasm_project, meta", my)

    echo_info("Create <wasm_module/> with errors from enum: '$(my.enum.name:)'", my)

    assert_attribute(my.enum, "name", my)

    new wasm_module to my.wasm_project
        .name = wasm_derive_error_module_name(my.wasm_project)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_class to wasm_module
            . = wasm_format_description(my.enum) ?
            .name = wasm_derive_error_class_name(my.wasm_project)
            .extends = "Error"

            new wasm_constructor to wasm_class
                new wasm_argument to wasm_constructor
                    .name = "message"
                endnew

                new wasm_code to wasm_constructor
                    . = "\
                        super(message);
                        this.name = '$(wasm_class.name:)';
                        this.message = message;
                    "
                endnew
            endnew

            new wasm_method to wasm_class
                . = "\
                    /**
                     * Throw exception of this class with a message that corresponds to the given status code.
                     */
                "
                .name = "handleStatusCode"
                .is_static = "1"

                new wasm_argument to wasm_method
                    .name = "statusCode"
                endnew

                new wasm_code to wasm_method
                    for my.enum.constant where 0.name <> "success"
                        my.status_check ?= ""
                        my.status_check += terminator + format_left("\
                            if (statusCode == $(constant.value:)) {
                                throw new $(wasm_class.name:)(\"$(enum_constant_format_oneline_description(constant))\");
                            }
                        ")
                    endfor
                    . = my.status_check
                endnew
            endnew
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module with WebAssembly enum from the abstract 'enum' notion.
# ---------------------------------------------------------------------------
function wasm_create_enum_module(enum, wasm_project, meta)
    check_arguments(my, "enum, wasm_project, meta", my)

    echo_info("Create <wasm_module/> from enum: '$(my.enum.name:)'", my)

    assert_attribute(my.enum, "name", my)

    if my.enum.name = "status"
        wasm_create_error_module(my.enum, my.wasm_project, my.meta)
        return
    endif

    new wasm_module to my.wasm_project
        .name = wasm_derive_module_name(my.enum)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_enum to wasm_module
            . = wasm_format_description(my.enum) ?
            .name = wasm_derive_enum_name(my.enum)

            for my.enum.constant
                my.constant_value ?= "0"
                if defined(my.constant.value)
                    my.constant_value = my.constant.value
                endif

                wasm_create_enum_constant(constant, my.constant_value, wasm_enum)

                if ! defined(my.constant.value)
                    my.constant_value += 1
                endif
            endfor
        endnew
    endnew
endfunction

#  --------------------------------------------------------------------------
function wasm_finalize_custom_modules(source, wasm_project, meta)
    check_arguments(my, "source, wasm_project, meta", my)

endfunction

#  --------------------------------------------------------------------------
function wasm_module_resolve(wasm_module, wasm_project)
    check_arguments(my, "wasm_module, wasm_project", my)

endfunction

#  --------------------------------------------------------------------------
function wasm_create_toplevel_modules(wrapper)
    check_arguments(my, "wrapper", my)

endfunction


.endtemplate

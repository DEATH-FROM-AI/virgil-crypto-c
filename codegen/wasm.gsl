.template 0
#   Copyright (C) 2015-2019 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

gsl from "common.gsl"
gsl from "wrapper_helpers.gsl"
gsl from "wasm_format.gsl"
gsl from "wasm_derive.gsl"
gsl from "wasm_codegen.gsl"


# ===========================================================================
#   Map types.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Derive Swift type from the <instance/> type attributes.
# ---------------------------------------------------------------------------
function wasm_derive_instance_type(instance)
    check_arguments(my, "instance", my)

    if defined(my.instance.type)
        if my.instance.type = "nothing"
            my.primitive_type = "undefined"

        elsif my.instance.type = "boolean"
            my.primitive_type = "boolean"

        elsif my.instance.type = "char"
            my.primitive_type = "string"

        else
            my.primitive_type = "number"
        endif

        if count(my.instance.array)
            my.primitive_type = "object"
        endif

        return my.primitive_type

    elsif defined(my.instance.class)

        if my.instance.class = "data" | my.instance.class = "buffer"
            return "Uint8Array"
        else
            return "function"
        endif

    elsif defined(my.instance.impl)
            return "function"

    elsif defined(my.instance.interface)
            return "function"

    elsif defined(my.instance.enum)
            return "function"

    else
        my.instance_dump = component_instance_dump(my.instance)
        echo_warning("Unreachable code, component_resolve_instance() must handle this. $(my.instance_dump:)", my)
        return "Unknown"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <wasm_instance type=""/> attributes.
# ---------------------------------------------------------------------------
function wasm_map_instance_type(instance, wasm_instance)
    check_arguments(my, "instance, wasm_instance", my)

    my.wasm_instance.type = wasm_derive_instance_type(my.instance)
    wrapper_map_instance_type_info(my.instance, my.wasm_instance)
endfunction


# ===========================================================================
#   Component creation.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Create class <wasm_constant/> from the entity <constant/>.
# ---------------------------------------------------------------------------
function wasm_create_class_constant(constant, wasm_class)
    check_arguments(my, "constant, wasm_class", my)

    assert_attributes(my.constant, "name, value", my)

    new wasm_constant to my.wasm_class
        . = wasm_format_description(my.constant) ?
        .name = wasm_derive_constant_name(my.constant)
        .value = my.constant.value
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create enumeration <wasm_constant/> from the entity <constant/>
# ---------------------------------------------------------------------------
function wasm_create_enum_constant(constant, constant_value, wasm_enum)
    check_arguments(my, "constant, constant_value, wasm_enum", my)

    assert_attribute(my.constant, "name", my)

    new wasm_constant to my.wasm_enum
        . = wasm_format_description(my.constant) ?
        .name = wasm_derive_constant_name(my.constant)
        .value = my.constant_value
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class default constructor.
# ---------------------------------------------------------------------------
function wasm_create_class_default_constructor(class, wasm_class)
    check_arguments(my, "class, wasm_class", my)

    new wasm_constructor to my.wasm_class
        . = "\
            /**
             * Create object with underlying C context.
             *
             * Note. Parameter 'ctxPtr' SHOULD be passed from the generated code only.
             */
        "

        new wasm_argument to wasm_constructor
            .name = "ctxPtr"
        endnew

        new wasm_code to wasm_constructor
            . = "\
                this.name = '$(my.wasm_class.name:)';

                if (typeof ctxPtr === 'undefined') {
                    this.ctxPtr = Module._$(class_derive_c_constructor(my.class))();
                } else {
                    this.ctxPtr = ctxPtr;
                }
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class constructors with given C context.
# ---------------------------------------------------------------------------
function wasm_create_class_constructors_with_c_context(class, wasm_class)
    check_arguments(my, "class, wasm_class", my)

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by making it's shallow copy.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndUseCContext"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"
        endnew

        new wasm_code to wasm_method
            . = "\
                // assert(typeof ctxPtr === 'number');
                return new $(my.wasm_class.name:)(Module._$(class_derive_c_method_shallow_copy(my.class))(ctxPtr));
            "
        endnew
    endnew

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by taking it ownership.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndTakeCContext"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"
        endnew

        new wasm_code to wasm_method
            . = "\
                // assert(typeof ctxPtr === 'number');
                return new $(my.wasm_class.name:)(ctxPtr);
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class constructors with given C context.
# ---------------------------------------------------------------------------
function wasm_create_custom_interface_class_constructors(source, wasm_class, wasm_project)
    check_arguments(my, "source, wasm_class, wasm_project", my)

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by taking it ownership.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndTakeCContext"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"
        endnew

        my.code_switch_statement_begin = format_left("\
            const implTag = vscf_impl_tag(ctxPtr);
            switch(implTag) {
        ")

        my.code_switch_statement_end = terminator + format_left("\
                default:
                    throw new Error('Unexpected implementation tag found: ' + implTag);
            }
        ")

        for my.source.implementation as impl
            my.code_switch_statement_cases ?= ""
            my.code_switch_statement_cases += terminator + format_left("\
                case $(my.wasm_project.impl_tag_enum_name:).$(wasm_derive_constant_name_str(impl.name)):
                    return modules.$(wasm_derive_class_name(impl)).newAndTakeCContext(ctxPtr);
            ", 1)
        endfor

        new wasm_code to wasm_method
            . = my.code_switch_statement_begin + my.code_switch_statement_cases + my.code_switch_statement_end
        endnew
    endnew

    new wasm_method to my.wasm_class
        . = "
            /**
             * Acquire C context by making it's shallow copy.
             *
             * Note. This method is used in generated code only, and SHOULD NOT be used in another way.
             */
        "
        .name = "newAndUseCContext"
        .is_static = "1"

        new wasm_argument to wasm_method
            .name = "ctxPtr"
        endnew

        new wasm_code to wasm_method
            . = "\
                return new modules.$(my.wasm_class.name:).newAndTakeCContext(Module._$(interface_derive_c_method_shallow_copy())(ctxPtr));
            "
        endnew
    endnew

endfunction

# ---------------------------------------------------------------------------
#   Create class default destructor.
# ---------------------------------------------------------------------------
function wasm_create_class_destructor(class, wasm_class)
    check_arguments(my, "class, wasm_class", my)

    new wasm_method to my.wasm_class
        . = "
            /**
             * Release underlying C context.
             */
        "
        .name = "delete"

        new wasm_code to wasm_method
            . = "\
                if (typeof this.ctxPtr !== 'undefined' && this.ctxPtr !== null) {
                    Module._$(class_derive_c_destructor(my.class))(this.ctxPtr);
                    this.ctxPtr = null;
                }
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create class custom constructor.
# ---------------------------------------------------------------------------
function wasm_create_class_constructor(class, constructor, wasm_class)
    check_arguments(my, "class, constructor, wasm_class", my)

    #   TODO: Implement me.
endfunction

# ---------------------------------------------------------------------------
#   Add dependency setter as <wasm_method/>.
# ---------------------------------------------------------------------------
function wasm_create_class_dependency_method(dependency, class, wasm_class, wasm_project)
    check_arguments(my, "dependency, class, wasm_class, wasm_project", my)

    new wasm_method to my.wasm_class
        . = wasm_format_description(my.dependency) ?
        .name = wasm_derive_method_name_str(my.dependency.name)
        .is_setter = "1"

        my.arg_name = wasm_derive_method_argument_name(my.dependency)

        new wasm_argument to wasm_method
            .name = my.arg_name
        endnew

        new wasm_code to wasm_method
            if my.dependency.has_observers & my.dependency.is_observers_return_status
                my.result_var = "const proxyStatus = "
                my.impl_handle_status = "modules.$(my.wasm_project.error_class_name:).handleStatusCode(proxyStatus)"
            endif

            . = format_left("\
                Module._$(class_derive_c_method_release_dependency(my.class, my.dependency))(this.ctxPtr)
                $(my.result_var?:)Module._$(class_derive_c_method_use_dependency(my.class, my.dependency))(this.ctxPtr,\
                        $(my.arg_name:).ctxPtr)
                $(my.impl_handle_status?:)
            ")
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_primitive_type(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)
        .code_precondition = "// assert(typeof $(wasm_argument.name:) === '$(wasm_argument.type:)')"
        my.wasm_method.c_arg_list += 0.name + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_data(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)

        .name = wasm_derive_method_argument_name(my.argument)

        .code_precondition = "// assert(typeof $(wasm_argument.name:) === 'Uint8Array')"

        .code_on_initialize = "\
            //  Copy bytes from JS memory to the WASM memory.
            const $(0.name:)Size = $(0.name:).length * $(0.name:).BYTES_PER_ELEMENT;
            const $(0.name:)Ptr = Module._malloc($(0.name:)Size);
            Module.HEAP8.set($(0.name:), $(0.name:)Ptr);

            //  Create C structure vsc_data_t.
            const $(0.name:)CtxSize = Module._vsc_data_ctx_size();
            const $(0.name:)CtxPtr = Module._malloc($(0.name:)CtxSize);

            //  Point created vsc_data_t object to the copied bytes.
            Module._vsc_data($(0.name:)CtxPtr, $(0.name:)Ptr, $(0.name:)Size);
        "

        .code_on_finalize = "\
            Module._free($(0.name:)Ptr);
            Module._free($(0.name:)CtxPtr);
        "

        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_writeonly_buffer(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_return)
        .name = wasm_derive_method_argument_name(my.argument)

        .code_on_initialize = "\
            const $(0.name:)Size = $(wasm_derive_buffer_length_getter(my.argument, my.wasm_class));
            const $(0.name:)CtxPtr = Module._vsc_buffer_new_with_capacity($(0.name:)Size);
        "

        .code_on_success = "\
            const $(0.name:)Ptr = Module._vsc_buffer_bytes($(0.name:)CtxPtr);
            const $(0.name:) = Module.HEAPU8.slice($(0.name:)Ptr, $(0.name:)Ptr + $(0.name:)Size);
        "

        .code_on_finalize = "\
            Module._vsc_buffer_delete($(0.name:)CtxPtr);
        "

        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_readwrite_buffer(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)

        .code_precondition = "// assert(typeof $(wasm_argument.name:) === 'Uint8Array')"

        .code_on_initialize = "\
            //  Copy bytes from JS memory to the WASM memory.
            const $(0.name:)Size = $(0.name:).length * $(0.name:).BYTES_PER_ELEMENT;
            const $(0.name:)Ptr = Module._malloc($(0.name:)Size);
            Module.HEAP8.set($(0.name:), $(0.name:)Ptr);

            //  Create C structure vsc_buffer_t.
            const $(0.name:)CtxPtr = Module._vsc_buffer_new();

            //  Point created vsc_buffer_t object to the copied bytes.
            Module._vsc_buffer_use($(0.name:)CtxPtr, $(0.name:)Ptr, $(0.name:)Size);
        "

        .code_on_finalize = "\
            Module._vsc_buffer_delete($(0.name:)CtxPtr);
        "

        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew

    new wasm_return to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_return)
        .name = "$(wasm_derive_method_argument_name(my.argument))Result"

        .code_on_success = "\
            const $(0.name:)Ptr = Module._vsc_buffer_bytes($(0.name:)CtxPtr);
            const $(0.name:)Result = Module.HEAPU8.slice($(0.name:)Ptr, $(0.name:)Ptr + $(0.name:)Size);
        "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_class(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)

        my.wasm_method.c_arg_list += "$(0.name:).ctxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_interface(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)

        my.wasm_method.c_arg_list += "$(0.name:).ctxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_enum(argument, wasm_method, wasm_class)
    check_arguments(my, "argument, wasm_method, wasm_class", my)

    new wasm_argument to my.wasm_method
        wasm_map_instance_type(my.argument, wasm_argument)
        .name = wasm_derive_method_argument_name(my.argument)

        my.wasm_method.c_arg_list += "$(0.name:)" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_argument_for_class_error(argument, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "argument, wasm_method, wasm_class, wasm_project", my)

    new wasm_argument to my.wasm_method
        .name = wasm_derive_method_argument_name(my.argument)
        .is_local = "1"

        .code_on_initialize = "\
            const $(0.name:)CtxSize = Module.$(class_error_derive_c_method_ctx_size())();
            const $(0.name:)CtxPtr = Module._malloc($(0.name:)CtxSize);
        "

        .code_on_success = "\
            const $(0.name:)Status = Module.$(class_error_derive_c_method_status())($(0.name:)CtxPtr);
            modules.$(my.wasm_project.error_class_name:).handleStatusCode($(0.name:)Status);
        "
        .code_on_finalize = "\
            Module._free($(0.name:)CtxPtr);
        "
        my.wasm_method.c_arg_list += "$(0.name:)CtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_primitive_type(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        .name = "proxyResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "\
            let proxyResult;
        "

        if wasm_return.type = "boolean"
            wasm_return.name = "booleanResult"
            wasm_return.code_on_success = "\
                const booleanResult = !!proxyResult;
            "
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_data(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        .name = "dataResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "\
            //  Create C structure vsc_data_t.
            const dataResultCtxSize = Module._vsc_data_ctx_size();
            const dataResultCtxPtr = Module._malloc(dataResultCtxSize);
        "

        wasm_return.code_on_success = "\
            const dataResultSize = Module._vsc_data_len(dataResultCtxPtr);
            const dataResultPtr = Module._vsc_data_bytes(dataResultCtxPtr);
            const dataResult = Module.HEAPU8.slice(dataResultPtr, dataResultPtr + dataResultSize);
        "

        wasm_return.code_on_finalize = "\
            Module._free(dataResultCtxPtr);
        "

        my.wasm_method.c_arg_list += "dataResultCtxPtr" + ", "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_disown_buffer(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)
    .name = "bufferResult"

    new wasm_return to my.wasm_method
        .name = "bufferResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "\
            let proxyResult;
        "

        wasm_return.code_on_success = "\
            const bufferResultSize = Module._vsc_buffer_len(proxyResult);
            const bufferResultPtr = Module._vsc_buffer_bytes(proxyResult);
            const bufferResult = Module.HEAPU8.slice(bufferResultPtr, bufferResultPtr + bufferResultSize);
        "

        wasm_return.code_on_finalize = "\
            Module._vsc_buffer_delete(proxyResult);
        "
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_class(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        .name = "jsResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "\
            let proxyResult;
        "

        my.instance_class = wasm_derive_instance_class(my.return)
        if string_in(my.return.access, "disown, retain")
            wasm_return.code_on_success = "\
                const jsResult = modules.$(my.instance_class:).newAndTakeCContext(proxyResult);
            "
        else
            wasm_return.code_on_success = "\
                const jsResult = modules.$(my.instance_class:).newAndUseCContext(proxyResult);
            "
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_interface(return, wasm_method, wasm_class, wasm_project)
    check_arguments(my, "return, wasm_method, wasm_class, wasm_project", my)

    new wasm_return to my.wasm_method
        .name = "jsResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "\
            let proxyResult;
        "

        my.instance_class = wasm_derive_interface_wrapper_class_name(my.return, my.wasm_project)
        if string_in(my.return.access, "disown, retain")
            wasm_return.code_on_success = "\
                const jsResult = modules.$(my.instance_class:).newAndTakeCContext(proxyResult);
            "
        else
            wasm_return.code_on_success = "\
                const jsResult = modules.$(my.instance_class:).newAndUseCContext(proxyResult);
            "
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
function wasm_create_method_return_for_enum(return, wasm_method, wasm_class)
    check_arguments(my, "return, wasm_method, wasm_class", my)

    new wasm_return to my.wasm_method
        .name = "proxyResult"

        wasm_map_instance_type(my.return, wasm_return)

        wasm_return.code_on_initialize = "\
            let proxyResult;
        "
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Create class method as <wasm_method/>.
# ---------------------------------------------------------------------------
function wasm_create_class_method(method, class, wasm_class, wasm_project)
    check_arguments(my, "method, class, wasm_class, wasm_project", my)

    new wasm_method to my.wasm_class
        . = wasm_format_description(my.method) ?
        .name = wasm_derive_method_name(my.method)
        .interface = my.method.interface ? #   When method comes from an interface.

        .c_method = "Module._$(class_derive_c_method(my.class, my.method))"
        .c_arg_list = ""

        if ! defined(my.method.interface)
            #   Method can be static only if it doesn't come from an interface.
            .is_static = my.method.is_static ?
        endif

        #
        #   Return values SHOULD be proceeded first to be able pass
        #   pointer to vsc_data_t as first argument to a proxy call.
        #
        #   Wrap return:
        #       - [x] Wrap primitive type
        #       - [x] Wrap class "data"
        #       - [x] Wrap class "buffer"
        #           - [x] disown
        #       - [x] Wrap class
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] disown
        #           - [x] retain
        #       - [x] Wrap impl
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] disown
        #           - [x] retain
        #       - [x] Wrap interface
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] disown
        #           - [x] retain
        #       - [x] Wrap enum "status"
        #
        for my.method.return where ! wrapper_instance_is_status(return)
            if defined(return.type)
                wasm_create_method_return_for_primitive_type(return, wasm_method, my.wasm_class)

            elsif string_equal(return.class, "data")
                wasm_create_method_return_for_data(return, wasm_method, my.wasm_class)

            elsif string_equal(return.class, "buffer") & return.access = "disown"
                wasm_create_method_return_for_disown_buffer(return, wasm_method, my.wasm_class)

            elsif defined(return.class) | defined(return.impl)
                wasm_create_method_return_for_class(return, wasm_method, my.wasm_class)

            elsif defined(return.interface)
                wasm_create_method_return_for_interface(return, wasm_method, my.wasm_class, my.wasm_project)

            elsif defined(return.enum)
                wasm_create_method_return_for_enum(return, wasm_method, my.wasm_class)
            else
                my.return_dump = component_instance_dump(return)
                echo_fatal("Unexpected return:  $(my.return_dump:)", my)
            endif
        endfor

        #
        #   Add this context.
        #
        if is_false(my.method.is_static)
            wasm_method.c_arg_list += "this.ctxPtr, "
        endif

        #
        #   Wrap arguments:
        #       - [x] Wrap primitive types.
        #       - [x] Wrap class "data"
        #       - [x] Wrap class "buffer"
        #           - [x] writeonly
        #           - [x] readwrite
        #       - [x] Wrap class
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] retain
        #           - [x] disown (not supported)
        #       - [x] Wrap impl
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] retain
        #           - [x] disown (not supported)
        #       - [x] Wrap interface
        #           - [x] readonly
        #           - [x] readwrite
        #           - [x] retain
        #           - [x] disown (not supported)
        #       - [x] Wrap enum
        #           - [x] readonly
        #       - [x] Wrap class "error"
        #           - [x] readwrite
        #
        for my.method.argument
            if defined(argument.type) & is_false(argument.is_reference)
                wasm_create_method_argument_for_primitive_type(argument, wasm_method, my.wasm_class)

            elsif string_equal(argument.class, "data")
                wasm_create_method_argument_for_data(argument, wasm_method, my.wasm_class)

            elsif string_equal(argument.class, "buffer") & argument.access = "writeonly"
                wasm_create_method_argument_for_writeonly_buffer(argument, wasm_method, my.wasm_class)

            elsif string_equal(argument.class, "buffer") & argument.access = "readwrite"
                wasm_create_method_argument_for_readwrite_buffer(argument, wasm_method, my.wasm_class)

            elsif string_equal(argument.class, "buffer") & argument.access = "readonly"
                echo_fatal("Buffers with readonly access are prohibited.", my)

            elsif string_equal(argument.class, "error") & argument.access = "readwrite"
                wasm_create_method_argument_for_class_error(argument, wasm_method, my.wasm_class, my.wasm_project)

            elsif defined(argument.class) | defined(argument.impl)
                wasm_create_method_argument_for_class(argument, wasm_method, my.wasm_class)

            elsif defined(argument.interface)
                wasm_create_method_argument_for_interface(argument, wasm_method, my.wasm_class)

            elsif defined(argument.enum)
                wasm_create_method_argument_for_enum(argument, wasm_method, my.wasm_class)
            else
                my.argument_dump = component_instance_dump(argument)
                echo_fatal("Unexpected argument:  $(my.argument_dump:)", my)
            endif
        endfor


        #
        #   Create method body.
        #

        #   Initialize locals.
        my.code = ""
        for wasm_method.wasm_argument where defined(wasm_argument.code_precondition)
            my.code += format_left(wasm_argument.code_precondition)
        endfor

        for wasm_method.wasm_argument where defined(wasm_argument.code_on_initialize)
            my.code += terminator + format_left(wasm_argument.code_on_initialize)
        endfor

        for wasm_method.wasm_return where defined(wasm_return.code_on_initialize)
            my.code += terminator + format_left(wasm_return.code_on_initialize)
        endfor

        my.c_arg_list = string_rtrim_symbol(wasm_method.c_arg_list, ",")

        if wrapper_is_method_return_status(my.method)
            my.return_statement = "const proxyResult = "
        elsif count(my.method.return, !wrapper_is_class_returned_by_value(return))
            my.return_statement = "proxyResult = "
        endif

        #   Proxy invocation.
        my.has_finalizer = count(wasm_method.wasm_argument, defined(wasm_argument.code_on_finalize)) + \
                           count(wasm_method.wasm_return, defined(wasm_return.code_on_finalize))

        my.proxy_indent = my.has_finalizer ?? 1 ? 0

        if my.has_finalizer
            my.code += terminator + format_left("try {")
        endif
        my.code += format_left("\
            $(my.return_statement?:)$(wasm_method.c_method:)($(my.c_arg_list:));
        ", my.proxy_indent)

        #   Handle errors.
        my.status_return = my.method->return(string_equal(return.enum, "status")) ?
        if defined(my.status_return)
            my.class_error_name = wasm_derive_error_class_name_from_instance(my.status_return, my.wasm_project)
            my.code += format_left("
                modules.$(my.class_error_name:).handleStatusCode(proxyResult);
            ", my.proxy_indent)
        endif

        for wasm_method.wasm_argument where defined(wasm_argument.code_on_success)
            my.code += terminator + format_left(wasm_argument.code_on_success, my.proxy_indent)
        endfor

        for wasm_method.wasm_return where defined(wasm_return.code_on_success)
            my.code += terminator + format_left(wasm_return.code_on_success, my.proxy_indent)
        endfor

        #   Return result.
        for wasm_method.wasm_return
            my.return_list ?= ""
            my.return_list += wasm_return.name ? "proxyResult"
            if ! last()
                my.return_list += ", "
            endif
        endfor

        if count(wasm_method.wasm_return) = 1
            my.code += format_left("return $(my.return_list:);", my.proxy_indent)
        elsif count(wasm_method.wasm_return) > 1
            my.code += format_left("return { $(my.return_list:) };", my.proxy_indent)
        endif

        #   Cleanup.
        if my.has_finalizer
            my.code += format_left("} finally {")

            for wasm_method.wasm_argument where defined(wasm_argument.code_on_finalize)
                my.code += format_left(wasm_argument.code_on_finalize, my.proxy_indent)
            endfor

            for wasm_method.wasm_return where defined(wasm_return.code_on_finalize)
                my.code += format_left(wasm_return.code_on_finalize, my.proxy_indent)
            endfor

            my.code += format_left("}")
        endif

        #   Assign code.
        new wasm_code to wasm_method
            . = (my.code = "") ?? "//  TODO: Implement me." ? my.code
        endnew
    endnew
endfunction


# ===========================================================================
#   Module creation.
# ===========================================================================

#  --------------------------------------------------------------------------
function wasm_resolve_wrapper(wrapper)
    check_arguments(my, "wrapper", my)

endfunction

#  --------------------------------------------------------------------------
function wasm_create_project_module(project, wrapper)
    check_arguments(my, "project, wrapper", my)

    new wasm_project to my.wrapper
        . = my.project. ?
        .name = my.project.name
        .prefix = my.project.prefix
        .source_dir = cat_path(my.wrapper.source_dir, 0.name)
        .impl_tag_enum_name = wasm_derive_class_name_str(cat(wasm_project.name, "impl tag"))
        .error_class_name = wasm_derive_error_class_name(wasm_project)
        .interface_class_name = wasm_derive_class_name_str(cat(wasm_project.name, "interface"))

        copy my.project->license to wasm_project

        return wasm_project
    endnew
endfunction

#  --------------------------------------------------------------------------
function wasm_create_interface_module(interface, wasm_project, meta)
    check_arguments(my, "interface, wasm_project, meta", my)

    #   Nothing to do here.
endfunction

# ---------------------------------------------------------------------------
#   Create language specific module that will represent implementation.
# ---------------------------------------------------------------------------
function wasm_create_implementation_module(impl, wasm_project, meta)
    check_arguments(my, "impl, wasm_project, meta", my)

    assert_attribute(my.impl, "name", my)

    echo_info("Create <wasm_module/> from implementation: '$(my.impl.name:)'", my)

    new wasm_module to my.wasm_project
        .name = wasm_derive_module_name(my.impl)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_class to wasm_module
            . = wasm_format_description(my.impl) ?
            .name = wasm_derive_class_name(my.impl)

            for my.impl.constant where wrapper_should_wrap_class_constant(constant)
                wasm_create_class_constant(constant, wasm_class)
            endfor

            if my.impl.context <> "none" & my.impl.lifecycle <> "none"
                wasm_create_class_default_constructor(my.impl, wasm_class)
                wasm_create_class_constructors_with_c_context(my.impl, wasm_class)
                wasm_create_class_destructor(my.impl, wasm_class)

                for my.impl.constructor where wrapper_should_wrap_method(constructor)
                    wasm_create_class_constructor(my.impl, constructor, wasm_class)
                endfor
            endif

            for my.impl.dependency
                wasm_create_class_dependency_method(dependency, my.impl, wasm_class, my.wasm_project)
            endfor

            for my.impl.interface
                for interface.constant
                    wasm_create_class_constant(constant, wasm_class)
                endfor

                for interface.method
                    wasm_create_class_method(method, my.impl, wasm_class, my.wasm_project)
                endfor
            endfor

            for my.impl.method where wrapper_should_wrap_method(method)
                wasm_create_class_method(method, my.impl, wasm_class, my.wasm_project)
            endfor
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create language specific module that will represent class.
# ---------------------------------------------------------------------------
function wasm_create_class_module(class, wasm_project, meta)
    check_arguments(my, "class, wasm_project, meta", my)

    assert_attribute(my.class, "name", my)

    if string_in(my.class.name, "error")
        #   Do not generate classes that can be mapped to the built-in types.
        return
    endif

    echo_info("Create <wasm_module/> from class: '$(my.class.name:)'", my)

    new wasm_module to my.wasm_project
        .name = wasm_derive_module_name(my.class)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_class to wasm_module
            . = wasm_format_description(my.class) ?
            .name = wasm_derive_class_name(my.class)

            for my.class.constant where wrapper_should_wrap_class_constant(constant)
                wasm_create_class_constant(constant, wasm_class)
            endfor

            if my.class.context <> "none" & my.class.lifecycle <> "none"
                wasm_create_class_default_constructor(my.class, wasm_class)
                wasm_create_class_constructors_with_c_context(my.class, wasm_class)
                wasm_create_class_destructor(my.class, wasm_class)

                for my.class.constructor where wrapper_should_wrap_method(constructor)
                    wasm_create_class_constructor(my.class, constructor, wasm_class)
                endfor
            endif

            for my.class.dependency
                wasm_create_class_dependency_method(dependency, my.class, wasm_class, my.wasm_project)
            endfor

            for my.class.method where wrapper_should_wrap_method(method)
                wasm_create_class_method(method, my.class, wasm_class, my.wasm_project)
            endfor
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module with WebAssembly error from the "status" enum.
# ---------------------------------------------------------------------------
function wasm_create_error_module(enum, wasm_project, meta)
    check_arguments(my, "enum, wasm_project, meta", my)

    echo_info("Create <wasm_module/> with errors from enum: '$(my.enum.name:)'", my)

    assert_attribute(my.enum, "name", my)

    new wasm_module to my.wasm_project
        .name = my.wasm_project.error_class_name
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_class to wasm_module
            . = wasm_format_description(my.enum) ?
            .name = my.wasm_project.error_class_name
            .extends = "Error"

            new wasm_constructor to wasm_class
                new wasm_argument to wasm_constructor
                    .name = "message"
                endnew

                new wasm_code to wasm_constructor
                    . = "\
                        super(message);
                        this.name = '$(wasm_class.name:)';
                        this.message = message;
                    "
                endnew
            endnew

            new wasm_method to wasm_class
                . = "\
                    /**
                     * Throw exception of this class with a message that corresponds to the given status code.
                     */
                "
                .name = "handleStatusCode"
                .is_static = "1"

                new wasm_argument to wasm_method
                    .name = "statusCode"
                endnew

                new wasm_code to wasm_method
                    for my.enum.constant where 0.name <> "success"
                        my.status_check ?= ""
                        my.status_check += terminator + format_left("\
                            if (statusCode == $(constant.value:)) {
                                throw new $(wasm_class.name:)(\"$(enum_constant_format_oneline_description(constant))\");
                            }
                        ")
                    endfor
                    . = my.status_check
                endnew
            endnew
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create module with WebAssembly enum from the abstract 'enum' notion.
# ---------------------------------------------------------------------------
function wasm_create_enum_module(enum, wasm_project, meta)
    check_arguments(my, "enum, wasm_project, meta", my)

    echo_info("Create <wasm_module/> from enum: '$(my.enum.name:)'", my)

    assert_attribute(my.enum, "name", my)

    if my.enum.name = "status"
        wasm_create_error_module(my.enum, my.wasm_project, my.meta)
        return
    endif

    new wasm_module to my.wasm_project
        .name = wasm_derive_module_name(my.enum)
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_enum to wasm_module
            . = wasm_format_description(my.enum) ?
            .name = wasm_derive_enum_name(my.enum)

            for my.enum.constant
                my.constant_value ?= "0"
                if defined(my.constant.value)
                    my.constant_value = my.constant.value
                endif

                wasm_create_enum_constant(constant, my.constant_value, wasm_enum)

                if ! defined(my.constant.value)
                    my.constant_value += 1
                endif
            endfor
        endnew
    endnew
endfunction

#  --------------------------------------------------------------------------
function wasm_module_resolve(wasm_module, wasm_project)
    check_arguments(my, "wasm_module, wasm_project", my)

endfunction

#  --------------------------------------------------------------------------
function wasm_create_toplevel_modules(wrapper)
    check_arguments(my, "wrapper", my)

endfunction


# ===========================================================================
#   Custom module creation.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Create a class that takes a generic C interface type, aka vscf_impl_t,
#   and create correspond specific JS class.
# ---------------------------------------------------------------------------
function wasm_create_interface_wrapper_module(source, wasm_project)
    check_arguments(my, "source, wasm_project", my)

    new wasm_module to my.wasm_project
        .name = my.wasm_project.interface_class_name
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_class to wasm_module
            .name = my.wasm_project.interface_class_name

            wasm_create_custom_interface_class_constructors(my.source, wasm_class, my.wasm_project)
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create an enumeration with all possibles implementation tags.
#   JS representation of the enum "impl tag", aka vscf_impl_tag_t.
# ---------------------------------------------------------------------------
function wasm_create_impl_tag_module(source, wasm_project)
    check_arguments(my, "source, wasm_project", my)

    new wasm_module to my.wasm_project
        .name = my.wasm_project.impl_tag_enum_name
        .source_file_name = 0.name + ".js"
        .source_file_path = cat_path(my.wasm_project.source_dir, 0.source_file_name)

        new wasm_license to wasm_module
            . = wasm_format_license(my.wasm_project->license) ?
        endnew

        new wasm_enum to wasm_module
            .name = my.wasm_project.impl_tag_enum_name

            for my.source.implementation as impl by impl.name
                my.counter ?= 1

                new wasm_constant to wasm_enum
                    .name = wasm_derive_constant_name_str(impl.name)
                    .value = my.counter
                endnew

                my.counter += 1
            endfor
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create a bunch of custom modules that are not related to the existing
#   high-level models.
# ---------------------------------------------------------------------------
function wasm_create_custom_modules(source, wasm_project, meta)
    check_arguments(my, "source, wasm_project, meta", my)

    if count(my.source.implementation)
        wasm_create_interface_wrapper_module(my.source, my.wasm_project)
        wasm_create_impl_tag_module(my.source, my.wasm_project)
    endif
endfunction

.endtemplate

.template 0

gsl from "common.gsl"
gsl from "js_helpers.gsl"

# --------------------------------------------------------------------------------------------------
# General
# --------------------------------------------------------------------------------------------------

function js_append_js_project_model(parent, project, wrapper)
  new js_project to my.parent
    js_project.name = my.project.name
    js_project.prefix = my.project.prefix
    js_project.root_dir = cat_path("../wrappers/$(my.wrapper.lang:no)", "crypto")
    js_project.source_dir = cat_path(js_project.root_dir, "src")
    js_project.project_source_dir = cat_path(js_project.source_dir, js_project.name)
    js_project.umbrella_header_file = "index.h"
    js_project.umbrella_header_guard = js_cpp_header_guard(my.project.name)
    js_project.umbrella_header_file_path = cat_path(js_project.project_source_dir, js_project.umbrella_header_file)
    js_project.index_cpp_file = "index.cc"
    js_project.index_cpp_file_path = cat_path(js_project.project_source_dir, js_project.index_cpp_file)
    js_project.index_js_file = "index.js"
    js_project.index_js_file_path = cat_path(js_project.project_source_dir, js_project.index_js_file)
    for my.project.require where defined(require.project) & require.project <> "common"
      new js_project_require to js_project
        js_project_require.c_namespace_dir = ""
        js_project_require.c_umbrella_header = make_ref_c(make_id("project", require.project, "header", require.project, "public"))
      endnew
    endfor
    new js_project_require to js_project
      js_project_require.c_namespace_dir = "$(my.project.namespace_dir)/"
      js_project_require.c_umbrella_header = make_ref_c(make_id("header", my.project.name, "public"))
    endnew
    return js_project
  endnew
endfunction

function js_append_js_module_model(parent, source)
  new js_module to my.parent
    js_module.name = my.source.name
    return js_module
  endnew
endfunction

function js_append_js_interface_module_model(parent, source, wrapper_project)
  new js_interface_module to my.parent
    js_interface_module.cpp_name = "$(my.source.name:pascal)"
    new js_cpp_name to js_interface_module
      js_cpp_name.name = js_interface_module.cpp_name
      js_cpp_name.uid = make_id("js", "interface", "module", my.source.name, "cpp", "name")
    endnew
    js_interface_module.cpp_header_guard = js_cpp_header_guard(my.source.name)
    js_interface_module.c_implementation_type = "$(make_ref_c(make_id("class", "impl", "struct", "impl")))*"
    new js_cpp_header to js_interface_module
      js_cpp_header.name = "$(my.source.name:c).h"
      js_cpp_header.path = cat_path(my.wrapper_project.project_source_dir, js_cpp_header.name)
    endnew
    for my.wrapper_project.js_project_require
      copy js_project_require to js_interface_module
    endfor
    return js_interface_module
  endnew
endfunction

function js_append_js_enum_module_model(parent, source, wrapper_project)
  new js_enum_module to my.parent
    js_enum_module.js_name = "$(my.source.name:pascal)"
    new js_source to js_enum_module
      js_source.name = "$(my.source.name:cobol).js"
      js_source.path = cat_path(my.wrapper_project.project_source_dir, js_source.name)
    endnew
    for my.source.constant
      js_append_js_enum_value(js_enum_module, constant, index(constant) - 1)
    endfor
    return js_enum_module
  endnew
endfunction

function js_append_js_error_status_module_model(parent, source, wrapper_project)
  new js_error_status_module to my.parent
    js_error_status_module.cpp_name = "$(my.source.name:pascal)"
    js_error_status_module.cpp_header_guard = js_cpp_header_guard(my.source.name)
    js_error_status_module.c_type = make_ref_c(make_id("class", "status", "enum", "status"))
    for my.wrapper_project.js_project_require
      copy js_project_require to js_error_status_module
    endfor
    new js_cpp_header to js_error_status_module
      js_cpp_header.name = "$(my.source.name:c).h"
      js_cpp_header.path = cat_path(my.wrapper_project.project_source_dir, js_cpp_header.name)
    endnew
    new js_cpp_source to js_error_status_module
      js_cpp_source.name = "$(my.source.name:c).cc"
      js_cpp_source.path = cat_path(my.wrapper_project.project_source_dir, js_cpp_source.name)
    endnew
    for my.source.constant where constant.name <> "success"
      new js_error_status to js_error_status_module
        js_error_status.message = string_trim(code_collapse_spaces(string.replace("$(constant:no)", "\n| ")))
        js_error_status.c_name = make_ref_c(make_id("class", "status", "enum", "status", "constant", constant.name))
      endnew
    endfor
    new js_error_status_module_cpp_name to js_error_status_module
      js_error_status_module_cpp_name.name = js_error_status_module.cpp_name
      js_error_status_module_cpp_name.uid = make_id("js", "error", "status", "module", "cpp name")
    endnew
  endnew
endfunction

function js_append_js_class_module_model(parent, source, wrapper_project)
  new js_class_module to my.parent
    js_class_module.binding_name = "$(my.source.name:pascal)Binding"
    js_class_module.js_name = "$(my.source.name:pascal)"
    new js_name to js_class_module
      js_name.name = js_class_module.js_name
      js_name.uid = make_id("js", "class", "module", my.source.name, "js", "name")
    endnew
    js_class_module.cpp_name = "$(my.source.name:pascal)"
    new js_cpp_name to js_class_module
      js_cpp_name.name = js_class_module.cpp_name
      js_cpp_name.uid = make_id("js", "class", "module", my.source.name, "cpp", "name")
    endnew
    js_class_module.cpp_header_guard = js_cpp_header_guard(my.source.name)
    js_class_module.instance_name = "$(my.source.name:c)_instance"
    js_class_module.has_context = defined(my.source.context) & my.source.context <> "none"
    if js_class_module.has_context
      js_class_module.c_context_name = "$(my.source.name:c)"
      js_class_module.c_context_type = "$(make_ref_c(make_id("class", my.source.name, "struct", my.source.name)))*"
      js_class_module.c_context_constructor = make_ref_c(make_id("class", my.source.name, "method", "new"))
      js_class_module.c_context_destructor = make_ref_c(make_id("class", my.source.name, "method", "destroy"))
    endif
    for my.wrapper_project.js_project_require
      copy js_project_require to js_class_module
    endfor
    new js_cpp_header to js_class_module
      js_cpp_header.name = "$(my.source.name:c).h"
      js_cpp_header.path = cat_path(my.wrapper_project.project_source_dir, js_cpp_header.name)
    endnew
    new js_cpp_source to js_class_module
      js_cpp_source.name = "$(my.source.name:c).cc"
      js_cpp_source.path = cat_path(my.wrapper_project.project_source_dir, js_cpp_source.name)
    endnew
    new js_source to js_class_module
      js_source.name = "$(my.source.name:cobol).js"
      js_source.path = cat_path(my.wrapper_project.project_source_dir, js_source.name)
    endnew
    for my.source.interface
      js_append_js_interface_implementation(js_class_module, interface)
      for interface.constant
        js_append_js_constant(js_class_module, my.source, constant)
      endfor
      for interface.method
        js_append_js_method(js_class_module, my.source, method)
      endfor
    endfor
    if count(js_class_module.js_interface_implementation) > 0
      js_class_module.c_implementation_type = "$(make_ref_c(make_id("class", "impl", "struct", "impl")))*"
      js_class_module.c_implementation_method_name = make_ref_c(make_id("class", my.source.name, "method", "impl"))
    endif
    for my.source.dependency
      js_append_js_dependency(js_class_module, my.source, dependency)
    endfor
    for my.source.constant
      js_append_js_constant(js_class_module, my.source, constant)
    endfor
    for my.source.method where !js_method_is_private(method)
      js_append_js_method(js_class_module, my.source, method)
    endfor
    return js_class_module
  endnew
endfunction

function js_append_js_interface_implementation(parent, interface)
  new js_interface_implementation to my.parent
    js_interface_implementation.cpp_class_name = make_ref_js(make_id("interface", "module", my.interface.name, "cpp", "name"))
    js_interface_implementation.c_implementation_type = "$(make_ref_c(make_id("class", "impl", "struct", "impl")))*"
    return js_interface_implementation
  endnew
endfunction

function js_append_js_constant(parent, source, constant)
  new js_constant to my.parent
    js_constant.js_name = "$(my.constant.name:camel)"
    js_constant.value = my.constant.value
    return js_constant
  endnew
endfunction

function js_append_js_dependency(parent, source, dependency)
  new js_dependency to my.parent
    new js_method to js_dependency
      js_method.is_static = "0" <> "0"
      js_method.c_name = make_ref_c(make_id("class", my.source.name, "method", "use", my.dependency.name))
      js_method.js_name = "set$(my.dependency.name:pascal)"
      js_method.cpp_name = "Set$(my.dependency.name:pascal)"
      js_append_js_argument(js_method, my.dependency)
      js_append_resolved_argument(js_method, my.source, my.dependency, 0)
    endnew
  endnew
endfunction

function js_append_js_method(parent, source, method)
  new js_method to my.parent
    js_method.is_static = defined(my.method.is_static) & my.method.is_static <> "0"
    if string_equal(my.method.of_class, "global") | string_equal(my.source.of_class, "global")
      js_method.c_name = make_ref_c(make_id("global method", my.method.name))
    else
      my.of_class = my.method.of_class ? my.source.of_class ? my.source.name
      js_method.c_name = make_ref_c(make_id("class", my.of_class, "method", my.method.name))
    endif
    js_method.cpp_name = "$(my.method.name:pascal)"
    js_method.js_name = "$(my.method.name:camel)"
    for my.method.argument
      js_append_js_argument(js_method, argument)
      js_append_resolved_argument(js_method, my.source, argument, index(argument) - 1)
    endfor
    if defined(my.method->return)
      my.method->return.name = "method return"
      js_append_js_method_call_return(js_method, my.method->return)
      js_append_resolved_return(js_method, my.source, my.method->return)
    endif
    return js_method
  endnew
endfunction

function js_append_js_argument(parent, argument)
  new js_argument to my.parent
    js_argument.cpp_name = "$(my.argument.name:c)"
    js_argument.js_name = "$(my.argument.name:camel)"
    if (defined(my.argument.class) & my.argument.class <> "data" & my.argument.class <> "buffer") | defined(my.argument.impl)
      js_argument.type = "class"
    elsif defined(my.argument.interface)
      js_argument.type = "interface"
    elsif defined(my.argument.enum)
      js_argument.type = "enum"
    else
      js_argument.type = "other"
    endif
    return js_argument
  endnew
endfunction

function js_append_resolved_argument(parent, source, argument, index)
  if js_value_is_return_argument(my.argument)
    return js_append_resolved_return(my.parent, my.source, my.argument)
  endif
  return js_append_resolved_call_argument(my.parent, my.source, my.argument, my.index)
endfunction

function js_append_js_call_argument(parent, argument)
  new js_call_argument to my.parent
    js_call_argument.cpp_name = "$(my.argument.name:c)"
    js_call_argument.js_name = "$(my.argument.name:camel)"
    return js_call_argument
  endnew
endfunction

function js_append_js_size_call_argument(parent, argument, index)
  new js_size_call_argument to my.parent
    js_size_call_argument.index = my.index
    js_size_call_argument.cpp_name = "$(my.argument.name:c)"
    js_size_call_argument.js_name = "$(my.argument.name:camel)"
    return js_size_call_argument
  endnew
endfunction

function js_append_js_integer_call_argument(parent, argument, index)
  new js_integer_call_argument to my.parent
    js_integer_call_argument.index = my.index
    js_integer_call_argument.cpp_name = "$(my.argument.name:c)"
    js_integer_call_argument.js_name = "$(my.argument.name:camel)"
    return js_integer_call_argument
  endnew
endfunction

function js_append_js_unsigned_call_argument(parent, argument, index)
  new js_unsigned_call_argument to my.parent
    js_unsigned_call_argument.index = my.index
    js_unsigned_call_argument.cpp_name = "$(my.argument.name:c)"
    js_unsigned_call_argument.js_name = "$(my.argument.name:camel)"
    return js_unsigned_call_argument
  endnew
endfunction

function js_append_js_boolean_call_argument(parent, argument, index)
  new js_boolean_call_argument to my.parent
    js_boolean_call_argument.index = my.index
    js_boolean_call_argument.cpp_name = "$(my.argument.name:c)"
    js_boolean_call_argument.js_name = "$(my.argument.name:camel)"
    return js_boolean_call_argument
  endnew
endfunction

function js_append_js_byte_call_argument(parent, argument, index)
  new js_byte_call_argument to my.parent
    js_byte_call_argument.index = my.index
    js_byte_call_argument.cpp_name = "$(my.argument.name:c)"
    js_byte_call_argument.js_name = "$(my.argument.name:camel)"
    return js_byte_call_argument
  endnew
endfunction

function js_append_js_char_call_argument(parent, argument, index)
  new js_char_call_argument to my.parent
    js_char_call_argument.index = my.index
    js_char_call_argument.cpp_name = "$(my.argument.name:c)"
    js_char_call_argument.js_name = "$(my.argument.name:camel)"
    return js_char_call_argument
  endnew
endfunction

function js_append_js_data_call_argument(parent, argument, index)
  new js_data_call_argument to my.parent
    js_data_call_argument.index = my.index
    js_data_call_argument.cpp_name = "$(my.argument.name:c)"
    js_data_call_argument.js_name = "$(my.argument.name:camel)"
    return js_data_call_argument
  endnew
endfunction

function js_append_js_enum_call_argument(parent, source, argument, index)
  new js_enum_call_argument to my.parent
    js_enum_call_argument.index = my.index
    js_enum_call_argument.cpp_name = "$(my.argument.name:c)"
    js_enum_call_argument.js_name = "$(my.argument.name:camel)"
    js_enum_call_argument.c_type = make_ref_c(make_id("class", my.argument.enum, "enum", my.argument.enum))
    return js_enum_call_argument
  endnew
endfunction

function js_append_js_class_call_argument(parent, source, argument, index)
  new js_class_call_argument to my.parent
    if defined(my.argument.class)
      my.class_name = my.argument.class
    else
      my.class_name = my.argument.impl
    endif
    my.project_uid = js_get_project_uid(my.argument)
    js_class_call_argument.index = my.index
    js_class_call_argument.cpp_name = "$(my.argument.name:c)"
    js_class_call_argument.js_name = "$(my.argument.name:camel)"
    js_class_call_argument.cpp_class_name = make_ref_js(make_id(my.project_uid, "class", "module", my.class_name, "cpp", "name"))
    js_class_call_argument.c_context_name = "$(my.class_name:c)"
    js_class_call_argument.c_context_type = "$(make_ref_c(make_id(my.project_uid, "class", my.class_name, "struct", my.class_name)))*"
    return js_class_call_argument
  endnew
endfunction

function js_append_js_interface_call_argument(parent, source, argument, index)
  new js_interface_call_argument to my.parent
    my.project_uid = js_get_project_uid(my.argument)
    js_interface_call_argument.index = my.index
    js_interface_call_argument.cpp_name = "$(my.argument.name:c)"
    js_interface_call_argument.js_name = "$(my.argument.name:camel)"
    js_interface_call_argument.cpp_class_name = make_ref_js(make_id(my.project_uid, "interface", "module", my.argument.interface, "cpp", "name"))
    js_interface_call_argument.c_implementation_type = "$(make_ref_c(make_id(my.project_uid, "class", "impl", "struct", "impl")))*"
    return js_interface_call_argument
  endnew
endfunction

function js_append_resolved_call_argument(parent, source, argument, index)
  js_append_js_call_argument(my.parent, my.argument)
  if defined(my.argument.type) & my.argument.type = "size"
    return js_append_js_size_call_argument(my.parent, my.argument, my.index)
  elsif defined(my.argument.type) & my.argument.type = "integer"
    return js_append_js_integer_call_argument(my.parent, my.argument, my.index)
  elsif defined(my.argument.type) & my.argument.type = "unsigned"
    return js_append_js_unsigned_call_argument(my.parent, my.argument, my.index)
  elsif defined(my.argument.type) & my.argument.type = "boolean"
    return js_append_js_boolean_call_argument(my.parent, my.argument, my.index)
  elsif defined(my.argument.type) & my.argument.type = "byte"
    return js_append_js_byte_call_argument(my.parent, my.argument, my.index)
  elsif defined(my.argument.type) & my.argument.type = "char"
    return js_append_js_char_call_argument(my.parent, my.argument, my.index)
  elsif defined(my.argument.class) & my.argument.class = "data"
    return js_append_js_data_call_argument(my.parent, my.argument, my.index)
  elsif defined(my.argument.enum)
    return js_append_js_enum_call_argument(my.parent, my.source, my.argument, my.index)
  elsif (defined(my.argument.class) & my.argument.class <> "buffer") | defined(my.argument.impl)
    return js_append_js_class_call_argument(my.parent, my.source, my.argument, my.index)
  elsif defined(my.argument.interface)
    return js_append_js_interface_call_argument(my.parent, my.source, my.argument, my.index)
  endif
endfunction

function js_append_js_method_call_return(parent, argument)
  new js_method_call_return to my.parent
    my.project_uid = js_get_project_uid(my.argument)
    if defined(my.argument.class) & my.argument.class <> "data" & my.argument.class <> "buffer"
      js_method_call_return.type = global.js_js_method_call_return_type_class
      js_method_call_return.js_class_name = make_ref_js(make_id(my.project_uid, "class", "module", my.argument.class, "js", "name"))
    elsif defined(my.argument.interface)
      js_method_call_return.type = global.js_js_method_call_return_type_interface
    else
      js_method_call_return.type = global.js_js_method_call_return_type_other
    endif
    js_method_call_return.cpp_name = "$(my.argument.name:c)"
    return js_method_call_return
  endnew
endfunction

function js_append_js_error_status_method_return(parent, source, argument)
  new js_error_status_method_return to my.parent
    my.project_uid = js_get_project_uid(my.argument)
    js_error_status_method_return.cpp_name = "$(my.argument.name:c)"
    js_error_status_method_return.c_type = make_ref_c(make_id(my.project_uid, "class", "status", "enum", "status"))
    js_error_status_method_return.cpp_class_name = make_ref_js(make_id("error", "status", "module", "cpp name"))
  endnew
endfunction

function js_append_js_error_context_method_return(parent, source, argument)
  new js_error_context_method_return to my.parent
    my.project_uid = js_get_project_uid(my.argument)
    js_error_context_method_return.cpp_name = "$(my.argument.name:c)"
    js_error_context_method_return.cpp_status_name = "$(my.argument.name:c)_status"
    js_error_context_method_return.c_type = make_ref_c(make_id(my.project_uid, "class", "error", "struct", "error"))
    js_error_context_method_return.c_status_type = make_ref_c(make_id(my.project_uid, "class", "status", "enum", "status"))
    js_error_context_method_return.c_reset_method_name = make_ref_c(make_id(my.project_uid, "class", "error", "method", "reset"))
    js_error_context_method_return.c_status_method_name = make_ref_c(make_id(my.project_uid, "class", "error", "method", "status"))
    js_error_context_method_return.cpp_class_name = make_ref_js(make_id("error", "status", "module", "cpp name"))
    return js_error_context_method_return
  endnew
endfunction

function js_append_js_method_return(parent, argument)
  new js_method_return to my.parent
    js_method_return.cpp_name = "$(my.argument.name:c)"
    js_method_return.js_name = "$(my.argument.name:camel)"
    return js_method_return
  endnew
endfunction

function js_append_js_size_method_return(parent, argument)
  new js_size_method_return to my.parent
    js_size_method_return.cpp_name = "$(my.argument.name:c)"
    js_size_method_return.js_name = "$(my.argument.name:camel)"
    return js_size_method_return
  endnew
endfunction

function js_append_js_integer_method_return(parent, argument)
  new js_integer_method_return to my.parent
    js_integer_method_return.cpp_name = "$(my.argument.name:c)"
    js_integer_method_return.js_name = "$(my.argument.name:camel)"
    return js_integer_method_return
  endnew
endfunction

function js_append_js_unsigned_method_return(parent, argument)
  new js_unsigned_method_return to my.parent
    js_unsigned_method_return.cpp_name = "$(my.argument.name:c)"
    js_unsigned_method_return.js_name = "$(my.argument.name:camel)"
    return js_unsigned_method_return
  endnew
endfunction

function js_append_js_boolean_method_return(parent, argument)
  new js_boolean_method_return to my.parent
    js_boolean_method_return.cpp_name = "$(my.argument.name:c)"
    js_boolean_method_return.js_name = "$(my.argument.name:camel)"
    return js_boolean_method_return
  endnew
endfunction

function js_append_js_byte_method_return(parent, argument)
  new js_byte_method_return to my.parent
    js_byte_method_return.cpp_name = "$(my.argument.name:c)"
    js_byte_method_return.js_name = "$(my.argument.name:camel)"
    return js_byte_method_return
  endnew
endfunction

function js_append_js_data_method_return(parent, argument)
  new js_data_method_return to my.parent
    js_data_method_return.cpp_name = "$(my.argument.name:c)"
    js_data_method_return.js_name = "$(my.argument.name:camel)"
    return js_data_method_return
  endnew
endfunction

function js_append_js_buffer_method_return(parent, argument, source)
  new js_buffer_method_return to my.parent
    js_buffer_method_return.cpp_name = "$(my.argument.name:c)"
    js_buffer_method_return.js_name = "$(my.argument.name:camel)"
    js_append_js_buffer_size(js_buffer_method_return, my.argument, my.source)
    return js_buffer_method_return
  endnew
endfunction

function js_append_js_buffer_size(parent, argument, source)
  if defined(my.argument->length)
    new js_buffer_size to my.parent
      js_buffer_size.cpp_bytes_name = "$(my.argument.name:c)_bytes"
      if defined(my.argument->length.argument)
        js_buffer_size.type = global.js_js_buffer_size_type_argument
        js_buffer_size.cpp_name = "$(my.argument->length.argument:c)"
      else
        js_buffer_size.cpp_name = "$(my.argument.name:c)_size"
        my.class_name = my.source.name
        if defined(my.argument->length.class) & my.argument->length.class <> "self"
          my.class_name = my.argument->length.class
        endif
        if defined(my.argument->length.constant)
          js_buffer_size.type = global.js_js_buffer_size_type_constant
          js_buffer_size.c_constant_name = make_ref_c(make_id("class", my.class_name, "constant", my.argument->length.constant))
        else
          js_buffer_size.type = global.js_js_buffer_size_type_method
          js_buffer_size.c_method_name = make_ref_c(make_id("class", my.class_name, "method", my.argument->length.method))
          for my.argument->length.proxy
            js_append_js_proxy(js_buffer_size, proxy)
          endfor
        endif
      endif
      return js_buffer_size
    endnew
  endif
endfunction

function js_append_js_proxy(parent, proxy)
  new js_proxy to my.parent
    if defined(my.proxy.argument)
      js_proxy.cpp_value = my.proxy.argument
    endif
    if defined(my.proxy.constant)
      js_proxy.constant = my.proxy.constant
    endif
    return js_proxy
  endnew
endfunction

function js_append_js_enum_method_return(parent, argument)
  new js_enum_method_return to my.parent
    my.project_uid = js_get_project_uid(my.argument)
    js_enum_method_return.cpp_name = "$(my.argument.name:c)"
    js_enum_method_return.js_name = "$(my.argument.name:camel)"
    js_enum_method_return.c_type = make_ref_c(make_id(my.project_uid, "class", my.argument.enum, "enum", my.argument.enum))
    return js_enum_method_return
  endnew
endfunction

function js_append_js_class_method_return(parent, argument)
  new js_class_method_return to my.parent
    my.project_uid = js_get_project_uid(my.argument)
    if defined(my.argument.class)
      my.class_name = my.argument.class
    else
      my.class_name = my.argument.impl
    endif
    js_class_method_return.cpp_name = "$(my.argument.name:c)"
    js_class_method_return.js_name = "$(my.argument.name:camel)"
    js_class_method_return.c_context_type = make_ref_c(make_id(my.project_uid, "class", my.class_name, "struct", my.class_name))
    js_class_method_return.js_class_name = make_ref_js(make_id(my.project_uid, "class", "module", my.class_name, "js", "name"))
    js_class_method_return.cpp_class_name = make_ref_js(make_id(my.project_uid, "class" , "module", my.class_name, "cpp", "name"))
    return js_class_method_return
  endnew
endfunction

function js_append_js_interface_method_return(parent, argument)
  new js_interface_method_return to my.parent
    my.project_uid = js_get_project_uid(my.argument)
    js_interface_method_return.cpp_name = "$(my.argument.name:c)"
    js_interface_method_return.js_name = "$(my.argument.name:camel)"
    js_interface_method_return.cpp_class_name = make_ref_js(make_id(my.project_uid, "interface", "module", my.argument.interface, "cpp", "name"))
    js_interface_method_return.c_implementation_type = "$(make_ref_c(make_id(my.project_uid, "class", "impl", "struct", "impl")))*"
    return js_interface_method_return
  endnew
endfunction

function js_append_resolved_return(parent, source, argument)
  if defined(my.argument.enum) & my.argument.enum = "status"
    return js_append_js_error_status_method_return(my.parent, my.source, my.argument)
  elsif defined(my.argument.class) & my.argument.class = "error"
    return js_append_js_error_context_method_return(my.parent, my.source, my.argument)
  endif
  js_append_js_method_return(my.parent, my.argument)
  if defined(my.argument.type) & my.argument.type = "size"
    return js_append_js_size_method_return(my.parent, my.argument)
  elsif defined(my.argument.type) & my.argument.type = "integer"
    return js_append_js_integer_method_return(my.parent, my.argument)
  elsif defined(my.argument.type) & my.argument.type = "unsigned"
    return js_append_js_unsigned_method_return(my.parent, my.argument)
  elsif defined(my.argument.type) & my.argument.type = "boolean"
    return js_append_js_boolean_method_return(my.parent, my.argument)
  elsif defined(my.argument.type) & my.argument.type = "byte"
    return js_append_js_byte_method_return(my.parent, my.argument)
  elsif defined(my.argument.class) & my.argument.class = "data"
    return js_append_js_data_method_return(my.parent, my.argument)
  elsif defined(my.argument.class) & my.argument.class = "buffer"
    return js_append_js_buffer_method_return(my.parent, my.argument, my.source)
  elsif defined(my.argument.enum)
    return js_append_js_enum_method_return(my.parent, my.argument)
  elsif defined(my.argument.class)
    return js_append_js_class_method_return(my.parent, my.argument)
  elsif defined(my.argument.interface)
    return js_append_js_interface_method_return(my.parent, my.argument)
  endif
endfunction

function js_append_js_include_module_model(parent, js_wrapped_class)
  new js_include_module to my.parent
    js_include_module.name = my.js_wrapped_class.name
    js_include_module.js_class_name = my.js_wrapped_class.js_class_name
    js_include_module.js_source_file = my.js_wrapped_class.js_source_file
    js_include_module.cpp_class_name = my.js_wrapped_class.cpp_class_name
    js_include_module.cpp_header_file = my.js_wrapped_class.cpp_header_file
    return js_include_module
  endnew
endfunction

function js_append_interfaces_to_cpp_class(cpp_class, js_implementation_module, wrapper)
  for my.js_implementation_module.js_interface_implementation
    for my.wrapper.js_wrapped_interface where js_interface_implementation.interface_name = js_wrapped_interface.name
      new cpp_interface_implementation to my.cpp_class
        cpp_interface_implementation.interface_name = js_wrapped_interface.name
        cpp_interface_implementation.class_name = js_wrapped_interface.class_name
        cpp_interface_implementation.cpp_header_file = js_wrapped_interface.cpp_header_file
      endnew
      next js_interface_implementation
    endfor
  endfor
endfunction

function js_resolve_js_implementation_module(parent, js_implementation_module, wrapper)
  for my.wrapper.js_wrapped_implementation where my.js_implementation_module.name = js_wrapped_implementation.name
    my.js_class_module = js_append_js_class_module_model(my.parent, my.js_implementation_module, js_wrapped_implementation, my.wrapper)
    if defined(my.js_class_module->cpp_class)
      js_append_interfaces_to_cpp_class(my.js_class_module->cpp_class, my.js_implementation_module, my.wrapper)
    endif
    return
  endfor
endfunction

function js_resolve_js_class_module_dependencies(js_class_module, wrapper)
  my.cpp_only_includes = XML.new()
  my.js_module_includes = XML.new()
  for my.js_class_module->cpp_class.cpp_method
    for cpp_method.cpp_class_call_argument
      new class_name to my.cpp_only_includes
        class_name.name = cpp_class_call_argument.class_name
      endnew
    endfor
    for cpp_method.cpp_implementation_call_argument
      new implementation_name to my.cpp_only_includes
        implementation_name.name = cpp_implementation_call_argument.implementation_name
      endnew
    endfor
    for cpp_method.cpp_interface_call_argument
      new interface_name to my.cpp_only_includes
        interface_name.name = cpp_interface_call_argument.interface_name
      endnew
    endfor
    for cpp_method.cpp_class_method_return
      new class_name to my.js_module_includes
        class_name.name = cpp_class_method_return.class_name
      endnew
    endfor
    for cpp_method.cpp_implementation_method_return
      new implementation_name to my.js_module_includes
        implementation_name.name = cpp_implementation_method_return.implementation_name
      endnew
    endfor
  endfor
  for my.js_module_includes.class_name as js_class_name
    for my.cpp_only_includes.class_name where class_name.name = js_class_name.name
      delete class_name
    endfor
  endfor
  for my.js_module_includes.implementation_name as js_implementation_name
    for my.cpp_only_includes.implementation_name where implementation_name.name = js_implementation_name.name
      delete implementation_name
    endfor
  endfor
  for my.wrapper.js_wrapped_class
    for my.js_module_includes.class_name where class_name.name = js_wrapped_class.name
      js_append_js_include_module_model(my.js_class_module, js_wrapped_class)
      next js_wrapped_class
    endfor
    for my.cpp_only_includes.class_name where class_name.name = js_wrapped_class.name
      js_append_cpp_include_module_model(my.js_class_module, js_wrapped_class)
      next js_wrapped_class
    endfor
  endfor
  for my.wrapper.js_wrapped_implementation
    for my.js_module_includes.implementation_name where implementation_name.name = js_wrapped_implementation.name
      js_append_js_include_module_model(my.js_class_module, js_wrapped_implementation)
      next js_wrapped_implementation
    endfor
    for my.cpp_only_includes.implementation_name where implementation_name.name = js_wrapped_implementation.name
      js_append_cpp_include_module_model(my.js_class_module, js_wrapped_implementation)
      next js_wrapped_implementation
    endfor
  endfor
  for my.wrapper.js_wrapped_interface
    for my.cpp_only_includes.interface_name where interface_name.name = js_wrapped_interface.name
      next js_wrapped_interface
    endfor
  endfor
endfunction

function js_append_js_status_model(parent, source_constant, wrapper)
  new js_status to my.parent
    js_status.c_name = "$(my.wrapper.prefix)_status_$(my.source_constant.name:upper,c)"
    js_status.message = string_trim("$(my.source_constant:no)")
  endnew
endfunction

# --------------------------------------------------------------------------------------------------
# JavaScript
# --------------------------------------------------------------------------------------------------

function js_append_js_enum_value(parent, constant, index)
  new js_enum_value to my.parent
    js_enum_value.js_name = "$(my.constant.name:c,upper)"
    if defined(my.constant.value)
      js_enum_value.value = my.constant.value
    else
      js_enum_value.value = my.index
    endif
  endnew
endfunction

function js_append_js_dependency_model(parent, source_dependency)
  new js_dependency to my.parent
    js_dependency.name = "$(my.source_dependency.name:Camel)"
    js_dependency.binding_method_name = "set$(my.source_dependency.name:Pascal)"
    return js_dependency
  endnew
endfunction

function js_append_js_constant_model(parent, source_constant)
  new js_constant to my.parent
    js_constant.name = "$(my.source_constant.name:c,upper)"
    js_constant.value = my.source_constant.value
    return js_constant
  endnew
endfunction

function js_append_js_argument_model(parent, source_argument)
  new js_argument to my.parent
    js_argument.name = "$(my.source_argument.name:Camel)"
    if defined(my.source_argument.type)
      js_argument.type = my.source_argument.type
    endif
    if defined(my.source_argument.enum)
      js_argument.enum = my.source_argument.enum
    endif
    if defined(my.source_argument.class)
      js_argument.class = my.source_argument.class
    endif
    if defined(my.source_argument.interface)
      js_argument.interface = my.source_argument.interface
    endif
    return js_argument
  endnew
endfunction

function js_append_js_return_model(parent, source_return)
  new js_return to my.parent
    if defined(my.source_return.type)
      js_return.type = my.source_return.type
    endif
    if defined(my.source_return.enum)
      js_return.enum = my.source_return.enum
    endif
    if defined(my.source_return.class)
      js_return.class = my.source_return.class
    endif
    return js_return
  endnew
endfunction

function js_append_method_model(parent, source_method)
  new js_method to my.parent
    js_method.name = "$(my.source_method.name:Camel)"
    js_method.binding_name = js_binding_method_name(my.source_method)
    if defined(my.source_method.is_static)
      js_method.is_static = my.source_method.is_static
    endif
    for my.source_method.argument where !js_value_is_return_argument(argument)
      js_append_js_argument_model(js_method, argument)
    endfor
    if defined(my.source_method->return)
      js_append_js_return_model(js_method, my.source_method->return)
    endif
    return js_method
  endnew
endfunction

function js_append_js_class_model(parent, source, js_wrapped_class)
  new js_class to my.parent
    js_class.name = my.js_wrapped_class.js_class_name
    js_class.binding_name = js_binding_class_name(js_class)
    for my.source.dependency
      js_append_js_dependency_model(js_class, dependency)
    endfor
    for my.source.constant where !js_constant_is_private(constant)
      js_append_js_constant_model(js_class, constant)
    endfor
    for my.source.method where !js_method_is_private(method)
      js_append_method_model(js_class, method)
    endfor
    return js_class
  endnew
endfunction

# --------------------------------------------------------------------------------------------------
# C++
# --------------------------------------------------------------------------------------------------

function js_append_cpp_argument_model(parent, source_argument)
  new cpp_argument to my.parent
    if defined(my.source_argument.name)
      cpp_argument.type = global.js_cpp_argument_type_variable
      cpp_argument.name = js_cpp_variable_name(my.source_argument.name)
    endif
    if defined(my.source_argument.argument)
      cpp_argument.type = global.js_cpp_argument_type_variable
      cpp_argument.name = js_cpp_variable_name(my.source_argument.argument)
    endif
    if defined(my.source_argument.constant)
      cpp_argument.type = global.js_cpp_argument_type_constant
      cpp_argument.constant = my.source_argument.constant
    endif
    if defined(my.source_argument.cast)
      cpp_argument.cast = my.source_argument.cast
    endif
    return cpp_argument
  endnew
endfunction

function js_append_cpp_js_return_model(parent, value)
  new cpp_js_return to my.parent
    cpp_js_return.name = js_cpp_variable_name(my.value)
    cpp_js_return.binding_name = "$(my.value:Camel)"
    return cpp_js_return
  endnew
endfunction

function js_append_cpp_size_call_argument_model(parent, source_argument)
  new cpp_size_call_argument to my.parent
    cpp_size_call_argument.name = js_cpp_variable_name(my.source_argument.name)
    return cpp_size_call_argument
  endnew
endfunction

function js_append_cpp_integer_call_argument_model(parent, source_argument)
  new cpp_integer_call_argument to my.parent
    cpp_integer_call_argument.name = js_cpp_variable_name(my.source_argument.name)
    return cpp_integer_call_argument
  endnew
endfunction

function js_append_cpp_unsigned_call_argument_model(parent, source_argument)
  new cpp_unsigned_call_argument to my.parent
    cpp_unsigned_call_argument.name = js_cpp_variable_name(my.source_argument.name)
    return cpp_unsigned_call_argument
  endnew
endfunction

function js_append_cpp_boolean_call_argument_model(parent, source_argument)
  new cpp_boolean_call_argument to my.parent
    cpp_boolean_call_argument.name = js_cpp_variable_name(my.source_argument.name)
    return cpp_boolean_call_argument
  endnew
endfunction

function js_append_cpp_byte_call_argument_model(parent, source_argument)
  new cpp_byte_call_argument to my.parent
    cpp_byte_call_argument.name = js_cpp_variable_name(my.source_argument.name)
    return cpp_byte_call_argument
  endnew
endfunction

function js_append_cpp_char_call_argument_model(parent, source_argument)
  new cpp_char_call_argument to my.parent
    cpp_char_call_argument.name = js_cpp_variable_name(my.source_argument.name)
    return cpp_char_call_argument
  endnew
endfunction

function js_append_cpp_data_call_argument_model(parent, source_argument)
  new cpp_data_call_argument to my.parent
    cpp_data_call_argument.name = js_cpp_variable_name(my.source_argument.name)
    return cpp_data_call_argument
  endnew
endfunction

function js_append_cpp_enum_call_argument_model(parent, source_argument, wrapper)
  for my.wrapper.js_wrapped_enum where my.source_argument.enum = js_wrapped_enum.name
    new cpp_enum_call_argument to my.parent
      cpp_enum_call_argument.name = js_cpp_variable_name(my.source_argument.name)
      cpp_enum_call_argument.enum_name = my.source_argument.enum
      cpp_enum_call_argument.c_type = js_wrapped_enum.c_name
      return cpp_enum_call_argument
    endnew
  endfor
endfunction

function js_append_cpp_class_call_argument_model(parent, source_argument, wrapper)
  for my.wrapper.js_wrapped_class where my.source_argument.class = js_wrapped_class.name
    new cpp_class_call_argument to my.parent
      cpp_class_call_argument.name = js_cpp_variable_name(my.source_argument.name)
      cpp_class_call_argument.class_name = js_wrapped_class.name
      cpp_class_call_argument.cpp_class_name = js_wrapped_class.cpp_class_name
      cpp_class_call_argument.cpp_context_name = js_wrapped_class.cpp_context_name
      return cpp_class_call_argument
    endnew
  endfor
endfunction

function js_append_cpp_implementation_call_argument_model(parent, source_argument, wrapper)
  if defined(my.source_argument.class)
    my.implementation_name = my.source_argument.class
  elsif defined(my.source_argument.impl)
    my.implementation_name = my.source_argument.impl
  endif
  for my.wrapper.js_wrapped_implementation where my.implementation_name = js_wrapped_implementation.name
    new cpp_implementation_call_argument to my.parent
      cpp_implementation_call_argument.name = js_cpp_variable_name(my.source_argument.name)
      cpp_implementation_call_argument.implementation_name = js_wrapped_implementation.name
      cpp_implementation_call_argument.cpp_class_name = js_wrapped_implementation.cpp_class_name
      cpp_implementation_call_argument.cpp_context_name = js_wrapped_implementation.cpp_context_name
      return cpp_implementation_call_argument
    endnew
  endfor
endfunction

function js_append_cpp_interface_call_argument_model(parent, source_argument, wrapper)
  for my.wrapper.js_wrapped_interface where my.source_argument.interface = js_wrapped_interface.name
    new cpp_interface_call_argument to my.parent
      cpp_interface_call_argument.name = js_cpp_variable_name(my.source_argument.name)
      cpp_interface_call_argument.interface_name = js_wrapped_interface.name
      cpp_interface_call_argument.cpp_class_name = js_wrapped_interface.class_name
      cpp_interface_call_argument.implementation_type = js_cpp_implementation_type(my.wrapper)
      return cpp_interface_call_argument
    endnew
  endfor
endfunction

function js_append_resolved_call_argument_model(parent, source_argument, wrapper)
  if js_value_is_size(my.source_argument)
    return js_append_cpp_size_call_argument_model(my.parent, my.source_argument)
  elsif js_value_is_integer(my.source_argument)
    return js_append_cpp_integer_call_argument_model(my.parent, my.source_argument)
  elsif js_value_is_unsigned(my.source_argument)
    return js_append_cpp_unsigned_call_argument_model(my.parent, my.source_argument)
  elsif js_value_is_boolean(my.source_argument)
    return js_append_cpp_boolean_call_argument_model(my.parent, my.source_argument)
  elsif js_value_is_byte(my.source_argument)
    return js_append_cpp_byte_call_argument_model(my.parent, my.source_argument)
  elsif js_value_is_char(my.source_argument)
    return js_append_cpp_char_call_argument_model(my.parent, my.source_argument)
  elsif js_value_is_data(my.source_argument)
    return js_append_cpp_data_call_argument_model(my.parent, my.source_argument)
  elsif js_value_is_enum_module(my.source_argument, my.wrapper)
    return js_append_cpp_enum_call_argument_model(my.parent, my.source_argument, my.wrapper)
  elsif js_value_is_class_module(my.source_argument, my.wrapper)
    return js_append_cpp_class_call_argument_model(my.parent, my.source_argument, my.wrapper)
  elsif js_value_is_implementation_module(my.source_argument, my.wrapper)
    return js_append_cpp_implementation_call_argument_model(my.parent, my.source_argument, my.wrapper)
  elsif js_value_is_interface_module(my.source_argument, my.wrapper)
    return js_append_cpp_interface_call_argument_model(my.parent, my.source_argument, my.wrapper)
  endif
endfunction

function js_append_cpp_buffer_size_model(parent, name, source_length, cpp_class, wrapper)
  new cpp_buffer_size to my.parent
    if defined(my.source_length.argument)
      cpp_buffer_size.type = global.js_cpp_buffer_size_type_argument
      cpp_buffer_size.name = my.source_length.argument
    else
      cpp_buffer_size.name = js_cpp_size_name(my.name)
      if defined(my.source_length.constant)
        cpp_buffer_size.type = global.js_cpp_buffer_size_type_constant
        cpp_buffer_size.constant = "$(my.wrapper.prefix:no)_$(my.cpp_class.c_name:no)_$(my.source_length.constant:c,upper)"
      elsif defined(my.source_length.method)
        cpp_buffer_size.type = global.js_cpp_buffer_size_type_method
        cpp_buffer_size.method = "$(my.wrapper.prefix:no)_$(my.cpp_class.c_name:no)_$(my.source_length.method:c)"
        for my.source_length.proxy
          js_append_cpp_argument_model(cpp_buffer_size, proxy)
        endfor
      else
        echo_fatal("'source_length.constant' or 'source_length.method' should be defined", my)
      endif
    endif
    return cpp_buffer_size
  endnew
endfunction

function js_append_cpp_buffer_result_argument_model(parent, source_argument, cpp_class, wrapper)
  new cpp_buffer_result_argument to my.parent
    cpp_buffer_result_argument.name = js_cpp_variable_name(my.source_argument.name)
    js_append_cpp_buffer_size_model(cpp_buffer_result_argument, cpp_buffer_result_argument.name, my.source_argument->length, my.cpp_class, my.wrapper)
    return cpp_buffer_result_argument
  endnew
endfunction

function js_append_cpp_byte_result_argument_model(parent, source_argument)
  new cpp_byte_result_argument to my.parent
    cpp_byte_result_argument.name = js_cpp_variable_name(my.source_argument.name)
    cpp_byte_result_argument.length = js_cpp_variable_name(my.source_argument->length.argument)
    return cpp_byte_result_argument
  endnew
endfunction

function js_append_cpp_char_result_argument_model(parent, source_argument)
  new cpp_char_result_argument to my.parent
    cpp_char_result_argument.name = js_cpp_variable_name(my.source_argument.name)
    cpp_char_result_argument.length = my.source_argument->string.length_constant
    return cpp_char_result_argument
  endnew
endfunction

function js_append_cpp_error_context_result_argument_model(parent, source_argument, wrapper)
  new cpp_error_context_result_argument to my.parent
    cpp_error_context_result_argument.name = js_cpp_variable_name(my.source_argument.name)
    cpp_error_context_result_argument.c_type = "$(my.wrapper.prefix:no)_error_t"
    cpp_error_context_result_argument.reset_method = "$(my.wrapper.prefix:no)_error_reset"
    cpp_error_context_result_argument.get_status = "$(my.wrapper.prefix:no)_error_status"
    return cpp_error_context_result_argument
  endnew
endfunction

function js_append_resolved_result_argument_model(parent, source_argument, cpp_class, wrapper)
  if js_value_is_return_argument(my.source_argument)
    if js_value_is_error_context(my.source_argument)
      return js_append_cpp_error_context_result_argument_model(my.parent, my.source_argument, my.wrapper)
    endif
    js_append_cpp_js_return_model(my.parent, my.source_argument.name)
    if js_value_is_buffer(my.source_argument)
      return js_append_cpp_buffer_result_argument_model(my.parent, my.source_argument, my.cpp_class, my.wrapper)
    elsif js_value_is_byte(my.source_argument)
      return js_append_cpp_byte_result_argument_model(my.parent, my.source_argument)
    elsif js_value_is_char(my.source_argument)
      return js_append_cpp_char_result_argument_model(my.parent, my.source_argument)
    endif
  endif
endfunction

/* function js_append_resolved_argument(parent, source_argument, cpp_class, wrapper)
  if defined(js_append_resolved_result_argument_model(my.parent, my.source_argument, my.cpp_class, my.wrapper))
    return
  endif
  if defined(js_append_resolved_call_argument_model(my.parent, my.source_argument, my.wrapper))
    return
  endif
  echo_fatal("Unable to resolve argument", my)
endfunction */

function js_append_cpp_method_return_model(parent)
  new cpp_method_return to my.parent
    cpp_method_return.name = global.js_cpp_method_return_name
    return cpp_method_return
  endnew
endfunction

function js_append_cpp_size_method_return_model(parent, name)
  new cpp_size_method_return to my.parent
    cpp_size_method_return.name = my.name
    return cpp_size_method_return
  endnew
endfunction

function js_append_cpp_integer_method_return_model(parent, name)
  new cpp_integer_method_return to my.parent
    cpp_integer_method_return.name = my.name
    return cpp_integer_method_return
  endnew
endfunction

function js_append_cpp_unsigned_method_return_model(parent, name)
  new cpp_unsigned_method_return to my.parent
    cpp_unsigned_method_return.name = my.name
    return cpp_unsigned_method_return
  endnew
endfunction

function js_append_cpp_boolean_method_return_model(parent, name)
  new cpp_boolean_method_return to my.parent
    cpp_boolean_method_return.name = my.name
    return cpp_boolean_method_return
  endnew
endfunction

function js_append_cpp_byte_method_return_model(parent, name)
  new cpp_byte_method_return to my.parent
    cpp_byte_method_return.name = my.name
    return cpp_byte_method_return
  endnew
endfunction

function js_append_cpp_data_method_return_model(parent, name)
  new cpp_data_method_return to my.parent
    cpp_data_method_return.name = my.name
    return cpp_data_method_return
  endnew
endfunction

function js_append_cpp_buffer_method_return_model(parent, name)
  new cpp_buffer_method_return to my.parent
    cpp_buffer_method_return.name = my.name
    return cpp_buffer_method_return
  endnew
endfunction

function js_append_cpp_error_method_return_model(parent, name, wrapper)
  new cpp_error_method_return to my.parent
    cpp_error_method_return.name = my.name
    cpp_error_method_return.c_type = "$(my.wrapper.prefix:no)_error_t"
    return cpp_error_method_return
  endnew
endfunction

function js_append_cpp_enum_method_return_model(parent, name, enum_name, wrapper)
  for my.wrapper.js_wrapped_enum where my.enum_name = js_wrapped_enum.name
    new cpp_enum_method_return to my.parent
      cpp_enum_method_return.name = my.name
      cpp_enum_method_return.enum_name = js_wrapped_enum.name
      cpp_enum_method_return.c_type = js_wrapped_enum.c_name
      return cpp_enum_method_return
    endnew
  endfor
endfunction

function js_append_cpp_class_method_return_model(parent, name, class_name, wrapper)
  for my.wrapper.js_wrapped_class where my.class_name = js_wrapped_class.name
    new cpp_class_method_return to my.parent
      cpp_class_method_return.name = my.name
      cpp_class_method_return.class_name = js_wrapped_class.name
      cpp_class_method_return.cpp_class_name = js_wrapped_class.cpp_class_name
      cpp_class_method_return.cpp_context_name = js_wrapped_class.cpp_context_name
      return cpp_class_method_return
    endnew
  endfor
endfunction

function js_append_cpp_implementation_method_return_model(parent, name, implementation_name, wrapper)
  for my.wrapper.js_wrapped_implementation where my.implementation_name = js_wrapped_implementation.name
    new cpp_implementation_method_return to my.parent
      cpp_implementation_method_return.name = my.name
      cpp_implementation_method_return.implementation_name = js_wrapped_implementation.name
      cpp_implementation_method_return.cpp_class_name = js_wrapped_implementation.cpp_class_name
      cpp_implementation_method_return.cpp_context_name = js_wrapped_implementation.cpp_context_name
    endnew
  endfor
endfunction

function js_append_cpp_interface_method_return_model(parent, name, interface_name, wrapper)
  new cpp_interface_method_return to my.parent
    cpp_interface_method_return.name = my.name
    cpp_interface_method_return.interface_name = my.interface_name
    cpp_interface_method_return.type = js_cpp_implementation_type(my.wrapper)
  endnew
endfunction

/* function js_append_resolved_return(parent, source_return, wrapper)
  my.cpp_method_return = js_append_cpp_method_return_model(my.parent)
  if js_value_is_error(my.source_return)
    return js_append_cpp_error_method_return_model(my.parent, my.cpp_method_return.name, my.wrapper)
  endif
  js_append_cpp_js_return_model(my.parent, my.cpp_method_return.name)
  if js_value_is_size(my.source_return)
    return js_append_cpp_size_method_return_model(my.parent, my.cpp_method_return.name)
  elsif js_value_is_integer(my.source_return)
    return js_append_cpp_integer_method_return_model(my.parent, my.cpp_method_return.name)
  elsif js_value_is_unsigned(my.source_return)
    return js_append_cpp_unsigned_method_return_model(my.parent, my.cpp_method_return.name)
  elsif js_value_is_boolean(my.source_return)
    return js_append_cpp_boolean_method_return_model(my.parent, my.cpp_method_return.name)
  elsif js_value_is_byte(my.source_return)
    return js_append_cpp_byte_method_return_model(my.parent, my.cpp_method_return.name)
  elsif js_value_is_data(my.source_return)
    return js_append_cpp_data_method_return_model(my.parent, my.cpp_method_return.name)
  elsif js_value_is_buffer(my.source_return)
    return js_append_cpp_buffer_method_return_model(my.parent, my.cpp_method_return.name)
  elsif js_value_is_enum_module(my.source_return, my.wrapper)
    return js_append_cpp_enum_method_return_model(my.parent, my.cpp_method_return.name, my.source_return.enum, my.wrapper)
  elsif js_value_is_class_module(my.source_return, my.wrapper)
    return js_append_cpp_class_method_return_model(my.parent, my.cpp_method_return.name, my.source_return.class, my.wrapper)
  elsif js_value_is_implementation_module(my.source_return, my.wrapper)
    return js_append_cpp_implementation_method_return_model(my.parent, my.cpp_method_return.name, my.source_return.impl, my.wrapper)
  elsif js_value_is_interface_module(my.source_return, my.wrapper)
    return js_append_cpp_interface_method_return_model(my.parent, my.cpp_method_return.name, my.source_return.interface, my.wrapper)
  endif
  echo_fatal("Unable to resolve return", my)
endfunction */

function js_append_cpp_method_model(parent, source_method, cpp_class, wrapper)
  new cpp_method to my.parent
    cpp_method.name = "$(my.source_method.name:Pascal)"
    cpp_method.binding_name = js_binding_method_name(my.source_method)
    cpp_method.c_name = "$(my.wrapper.prefix:no)_$(my.cpp_class.c_name:no)_$(my.source_method.name:c)"
    if defined(my.source_method.is_static)
      cpp_method.is_static = my.source_method.is_static
    endif
    for my.source_method.argument
      js_append_cpp_argument_model(cpp_method, argument)
      copy argument to cpp_method
    endfor
    if defined(my.source_method->return)
      copy my.source_method->return to cpp_method
    endif
    return cpp_method
  endnew
endfunction

function js_append_cpp_dependency_model(parent, source_dependency, cpp_class, wrapper)
  new cpp_method to my.parent
    cpp_method.name = "set $(my.source_dependency.name:no)"
    cpp_method.binding_name = js_binding_method_name(cpp_method)
    cpp_method.name = "$(cpp_method.name:Pascal)"
    cpp_method.c_name = "$(my.wrapper.prefix:no)_$(my.cpp_class.c_name:no)_use_$(my.source_dependency.name:c)"
    js_append_cpp_argument_model(cpp_method, my.source_dependency)
    copy my.source_dependency to cpp_method as argument
    return cpp_method
  endnew
endfunction

function js_append_cpp_class_model(parent, source, js_wrapped_class, wrapper)
  new cpp_class to my.parent
    cpp_class.name = my.js_wrapped_class.cpp_class_name
    cpp_class.binding_name = js_binding_class_name(cpp_class)
    cpp_class.c_name = "$(my.source.name:c)"
    cpp_class.context_name = my.js_wrapped_class.cpp_context_name
    for my.source.dependency
      js_append_cpp_dependency_model(cpp_class, dependency, cpp_class, my.wrapper)
    endfor
    for my.source.method where !js_method_is_private(method)
      js_append_cpp_method_model(cpp_class, method, cpp_class, my.wrapper)
    endfor
    return cpp_class
  endnew
endfunction

function js_append_cpp_include_module_model(parent, js_wrapped_class)
  new cpp_include_module to my.parent
    cpp_include_module.name = my.js_wrapped_class.name
    cpp_include_module.cpp_class_name = my.js_wrapped_class.cpp_class_name
    cpp_include_module.cpp_header_file = my.js_wrapped_class.cpp_header_file
    return cpp_include_module
  endnew
endfunction

function js_resolve_cpp_class(cpp_class, wrapper)
  for my.cpp_class.cpp_method
    for cpp_method.argument
      js_append_resolved_argument(cpp_method, argument, my.cpp_class, my.wrapper)
      delete argument
    endfor
    if defined(cpp_method->return)
      js_append_resolved_return(cpp_method, cpp_method->return, my.wrapper)
      delete cpp_method->return
    endif
  endfor
endfunction

endtemplate

# ---------------------------------------------------------------------------
function class_calculate_dependencies_fingerprint(project, class)
    check_arguments(my, "project, class")

    new dependencies
        .project_prefix = my.project.prefix
        .self_fingerprint = fingerprint(my.class)
        .license_fingerprint = fingerprint(my.project->license)

        my.fingerprint = fingerprint(dependencies)
        delete dependencies
        return my.fingerprint
    endnew
endfunction

# ---------------------------------------------------------------------------
function class_resolve_attr_context(class, project)
    check_arguments(my, "class, project", my)

    my.has_context =(count(my.class.property) + count(my.class.dependency)) > 0
    if my.class.context = "private" & string_equal(my.class.scope ?, "internal")
        my.class.context = "internal"
    endif

    echo_resolved_attribute(my.class, "context", my)
endfunction

# ---------------------------------------------------------------------------
function class_resolve_attr_of_class(class, project)
    check_arguments(my, "class, project", my)

    my.class.of_class ?= my.class.name
    echo_resolved_attribute(my.class, "of_class", my)
endfunction

# ---------------------------------------------------------------------------
function class_resolve_attr_c_prefix(class, project)
    check_arguments(my, "class, project", my)

    my.class.c_prefix ?= my.project.prefix
    echo_resolved_attribute(my.class, "c_prefix", my)
endfunction

# ---------------------------------------------------------------------------
function class_resolve_attr_uid(class, project)
    check_arguments(my, "class, project", my)

    my.class.uid = make_id("class", my.class.name)
    echo_resolved_attribute(my.class, "uid", my)
endfunction

# ---------------------------------------------------------------------------
function class_resolve_property(property, class)
    check_arguments(my, "property, class", my)

    if string_equal(my.property.class ?, "self")
        my.property.class = my.class.name
        echo_resolved_attribute(my.property, "class", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Resolve entity: method.
# ---------------------------------------------------------------------------
function class_resolve_method(method, class)
    check_arguments(my, "method, class", my)

    echo_resolving_entity(my.method, my)

    if string_equal(my.class.context, "none")
        my.method.is_static = "1"

        for my.method.argument
            for argument.length
                length.class ?= "self"
            endfor
        endfor
    endif

    for my.method.argument where string_equal(0.class ?, "self")
        .name ?= "ctx"
        .access ?= "readwrite"
        .class = my.class.name
    endfor

    for my.method.return where string_equal(0.class ?, "self")
        .access ?= "disown"
        .class = my.class.name
    endfor
endfunction

# ---------------------------------------------------------------------------
function class_resolve_constructor(constructor, class)
    check_arguments(my, "constructor, class", my)

    my.constructor.is_static = "1"
    component_resolve_method(my.constructor, my.class)
endfunction


# ---------------------------------------------------------------------------
function class_resolve(class, project)
    check_arguments(my, "class, project", my)

    echo_resolving_entity(my.class, my)

    class_resolve_attr_context(my.class, my.project)
    class_resolve_attr_c_prefix(my.class, my.project)
    class_resolve_attr_uid(my.class, my.project)

    component_add_lineage(my.class, my.project)

    for my.class.constructor
        class_resolve_constructor(constructor, my.class)
    endfor

    for my.class.method
        class_resolve_method(method, my.class)
    endfor

    for my.class.property
        class_resolve_property(property, my.class)
        component_resolve_property(property, my.class)
    endfor

    foreach_component_resolve(my.class)
endfunction

# ---------------------------------------------------------------------------
#   Entry point
# ---------------------------------------------------------------------------
function class_process(project, class_link)
    check_arguments(my, "project, class_link", my)
    assert_attribute(my.class_link, "name", my)

    echo_info("[L1] Class '$(my.class_link.name:)' - start processing", my)

    my.class = class_load(my.project, my.class_link.name, my.class_link.[from])
    my.class.forcegen ?= my.project.forcegen
    my.cached_class = cache_load_or_invalidate(my.project, my.class) ?
    my.class.fingerprint = class_calculate_dependencies_fingerprint(my.project, my.class)

    if defined(my.cached_class)
        echo_trace("[L1] Class '$(my.class.name:)' - cache loaded", my)
    else
        echo_trace("[L1] Class '$(my.class.name:)' - full update required", my)
    endif

    if !fingerprint_is_equal(my.class, my.cached_class)
        class_setup_defaults(my.class)
        class_validate(my.class)
        class_resolve(my.class, my.project)
        class_validate_resolved(my.class)
    endif

    echo_trace("[L1] Class '$(my.class.name:)' - process children", my)

    cache_store(my.project, my.class)
    echo_info("[L1] Class '$(my.class_link.name:)' - accomplished", my)
endfunction

# ---------------------------------------------------------------------------
#   Multi-thread entry point
# ---------------------------------------------------------------------------
if main.multithread
    thread.receive(sending_thread, _project, _class_link)
    class_process(_project, _class_link)
endif

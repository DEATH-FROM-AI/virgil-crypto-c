.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   This module provides functionality, that transforms 'component' models to
#   the 'c_component' models.
#
#   Note, all 'component' passed models mused be already resolved.
#
#   Private function prefix is: X11.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------


gsl from "common.gsl"
gsl from "component_new.gsl"
gsl from "c_formatter.gsl"


# ###########################################################################
#   Attribute derivation functions
# ###########################################################################


# ---------------------------------------------------------------------------
#   Derive C style in-project constant name (full name).
# ---------------------------------------------------------------------------
function c_derive_constant_name (constant)
    check_argument (my, "constant", my)

    component_require_linage (my.constant, my)

    my.ancestors = ""
    for my.constant.ancestor where ! string_in (id, "project, module")
        my.ancestors = cat (my.ancestors, ancestor.name)
    endfor

    return c_format_constant_name ( \
            my.constant.c_prefix, my.constant.class, my.ancestors, my.constant.name)
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project enum name (full name).
# ---------------------------------------------------------------------------
function c_derive_enum_name (enum)
    check_argument (my, "enum", my)

    component_require_linage (my.enum, my)

    return c_format_name (my.enum.c_prefix, my.enum.class, my.enum.name, "t")
endfunction

# ---------------------------------------------------------------------------
#   Derive C style in-project method name (full name).
# ---------------------------------------------------------------------------
function c_derive_method_name (method)
    check_argument (my, "method", my)

    component_require_linage (my.method, my)

    return c_format_name (my.method.c_prefix, my.method.class, my.method.name)
endfunction

# ---------------------------------------------------------------------------
#   Derive C integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function c_component_derive_integer_type (size)
    if defined (my.size)
        if my.size = "1"
            return "int8_t"

        elsif my.size = "2"
            return "int16_t"

        elsif my.size = "4"
            return "int32_t"

        elsif my.size = "8"
            return "int64_t"
        else
            echo_fatal ("Unsupported size 'my.size' for C integers", my)
        endif
    else
        return "int"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return .(c_<uid>) if given value in a format .(<uid>), else return as-is.
# ---------------------------------------------------------------------------
function c_component_wrap_uid (value)
    check_argument (my, "value", my)

    return is_ref (my.value) ?? c_ref (my.value) ? my.value
endfunction

# ###########################################################################
#   Validate or check attribute
# ###########################################################################

# ---------------------------------------------------------------------------
#   Check required attribute: file.
# ---------------------------------------------------------------------------
function c_component_require_attr_file (c_component, caller)
    check_argument (my, "c_component", my)

    assert_attribute (my.c_component, "file", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: name.
# ---------------------------------------------------------------------------
function c_component_require_attr_name (c_component, caller)
    check_argument (my, "c_component", my)

    assert_attribute (my.c_component, "name", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: type.
# ---------------------------------------------------------------------------
function c_component_require_attr_type (c_component, caller)
    check_argument (my, "c_component", my)

    assert_attribute (my.c_component, "type", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check required attribute: value.
# ---------------------------------------------------------------------------
function c_component_require_attr_value (c_component, caller)
    check_argument (my, "c_component", my)

    assert_attribute (my.c_component, "value", my.caller ? my)
endfunction

# ---------------------------------------------------------------------------
#   Check optional integral attribute: value.
# ---------------------------------------------------------------------------
function c_component_optional_integral_attr_value (c_component)
    check_argument (my, "c_component", my)

    if defined (my.component.value)
        assert_attribute_number (my.c_component, "value", my.caller ? my)
    endif
endfunction

# ###########################################################################
#   Attribute resolution functions
# ###########################################################################

# ---------------------------------------------------------------------------
#   Resolve attribute: scope.
# ---------------------------------------------------------------------------
function c_component_resolve_attr_scope (c_component)
    check_argument (my, "c_component", my)

    my.c_component.scope ?= "public"
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: visibility.
# ---------------------------------------------------------------------------
function c_component_resolve_attr_visibility (c_component)
    check_argument (my, "c_component", my)

    my.c_component.visibility ?= "public"
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: definition.
# ---------------------------------------------------------------------------
function c_component_resolve_attr_definition (c_component)
    check_argument (my, "c_component", my)

    my.c_component.definition ?= "private"
endfunction

# ---------------------------------------------------------------------------
#   Resolve attribute: is_system.
# ---------------------------------------------------------------------------
function c_component_resolve_attr_is_system (c_component)
    check_argument (my, "c_component", my)

    my.c_component.is_system ?= "0"
endfunction


# ###########################################################################
#   Item resolution functions
# ###########################################################################

# ---------------------------------------------------------------------------
#   Resolve component: c_include.
# ---------------------------------------------------------------------------
function c_component_resolve_include (c_include)
    check_argument (my, "c_include", my)

    c_component_require_attr_file (my.c_include, my)
    c_component_resolve_attr_scope (my.c_include)
    c_component_resolve_attr_is_system (my.c_include)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: c_alias.
# ---------------------------------------------------------------------------
function c_component_resolve_alias (c_alias)
    check_argument (my, "c_alias", my)

    c_component_require_attr_name (my.c_alias, my)
    c_component_require_attr_type (my.c_alias, my)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: c_constant.
# ---------------------------------------------------------------------------
function c_component_resolve_constant (c_constant)
    check_argument (my, "c_constant", my)

    c_component_require_attr_name (my.c_constant, my)
    c_component_optional_integral_attr_value (my.c_constant, my)
    c_component_resolve_attr_scope (my.c_constant)
endfunction

# ---------------------------------------------------------------------------
#   Resolve component: c_enum.
# ---------------------------------------------------------------------------
function c_component_resolve_enum (c_enum)
    check_argument (my, "c_enum", my)

    c_component_resolve_attr_scope (my.c_enum, my)
    c_component_resolve_attr_visibility (my.c_enum, my)
    c_component_resolve_attr_definition (my.c_enum, my)

    for my.c_enum.c_constant
        c_component_resolve_constant (c_constant)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Define c_instance.kind:
#       * value - if instance is a type or enum with readonly access;
#
#       * pointer - if instance is a callback,
#                   if instance is a type or enum with write access,
#                   if instance is a class with any access except disown;
#
#       * reference - if instance is a class with disown access.
# ---------------------------------------------------------------------------
function c_component_map_instance_kind (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    if (defined (my.instance.type) & my.instance.access = "readonly") | \
            (defined (my.instance.enum) & my.instance.access = "readonly") | \
        my.instance.kind = "value"

    elsif (defined (my.instance.callback)) | \
            (defined (my.instance.type) & string.match (my.instance.access, "write")) | \
            (defined (my.instance.enum) & string.match (my.instance.access, "write")) | \
            (defined (my.instance.class) & my.instance.access <> "disown")
        my.c_instance.kind = "pointer"

    elsif defined (my.instance.class) & my.instance.access = "disown"
        my.c_instance.kind = "reference"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Define c_instance.type and related attributes: is_string, is_callback.
# ---------------------------------------------------------------------------
function c_component_map_instance_type (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    if defined (my.instance.type)
        if my.instance.type = "nothing"
            my.c_instance.type = "void"

        elsif my.instance.type = "boolean"
            my.c_instance.type = "bool"

        elsif my.instance.type = "integer"
            my.c_instance.type = c_component_derive_integer_type (my.instance.size ?)

        elsif my.instance.type = "byte"
            my.c_instance.type = "byte"

        elsif my.instance.type = "size"
            my.c_instance.type = "size_t"

        else
            echo_fatal ("Unsupported instance type '$(my.instance.type)' for C language.", my)
        endif

    elsif defined (my.instance.class)
        if my.instance.class = "any"
            my.c_instance.type = "void"

        elsif my.instance.class = "string"
            my.c_instance.type = "char"
            my.c_instance.is_string = "1"

        elsif my.instance.class = "buffer"
            my.c_instance.type = ".(class_buffer)"

        elsif my.instance.class = "impl"
            my.c_instance.type = ".(class_impl)"

        else
            my.c_instance.type = c_component_wrap_uid (my.instance.class)
        endif

    elsif defined (my.instance.enum)
            my.c_instance.type = c_component_wrap_uid (my.instance.enum)

    elsif defined (my.instance.callback)
            my.c_instance.type = c_component_wrap_uid (my.instance.callback)
            my.c_instance.is_callback = "1"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Define 'c_instance' attributes that are responsible for constness.
# ---------------------------------------------------------------------------
function c_component_map_instance_constness (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    if my.instance.access = "readonly" & (\
            (defined (my.instance.class)) | \
            (defined (my.instance.type) & count (my.instance.array)) | \
            (defined (my.instance.enum) & count (my.instance.array)))
        my.c_instance.is_const_type = "1"
    endif

    if count (my.instance.array) & my.instance->array.access = "readonly"
        my.c_instance.is_const_array = "1"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Define 'c_instance.array' attribute.
# ---------------------------------------------------------------------------
function c_component_map_instance_arrayness (c_instance, instance)
    check_arguments (my, "c_instance, instance", my)

    if count (my.instance.array)
        my.c_instance.array = my.instance->array.length

        if my.instance->array.length = "fixed"
            my.c_instance.length = c_component_wrap_uid (my.instance->length_constant)
        endif
    else
        my.c_instance.array = # undefined
    endif
endfunction

# ---------------------------------------------------------------------------
#   Define 'c_instance' from 'instance'.
# ---------------------------------------------------------------------------
function c_component_map_instance (c_instance, instance)
    check_arguments (my, "c_instance, instance")

    c_component_map_instance_kind (my.c_instance, my.instance)
    c_component_map_instance_type (my.c_instance, my.instance)
    c_component_map_instance_arrayness (my.c_instance, my.instance)
    c_component_map_instance_constness (my.c_instance, my.instance)
endfunction

# ---------------------------------------------------------------------------
#   Copy 'c_implementation' from component to c_component, if defined.
# ---------------------------------------------------------------------------
function c_component_map_implementation (c_component, component)
    check_arguments (my, "c_component, component", my)

    if count (my.component.c_implementation)
        copy my.component->c_implementation to my.c_component
    endif
endfunction


# ###########################################################################
#   Functions to creation new c_component(s)
# ###########################################################################

# ---------------------------------------------------------------------------
#   Create 'c_include' from 'require'.
# ---------------------------------------------------------------------------
function c_component_create_include (require, destination)
    check_arguments (my, "require, destination", my)

    new c_include to my.destination
        .file = c_ref ("module_$(make_id (my.require.module))") + ".h"
        .scope = require.scope ?
        .is_system = "0"

        c_component_resolve_include (c_include)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_constant' from 'constant'.
#   Note, enumeration constant do not require explicit value.
# ---------------------------------------------------------------------------
function c_component_create_constant (constant, destination)
    check_arguments (my, "constant, destination", my)

    if ! item_in (my.destination ?, "c_enum")
        component_require_attr_value (my.constant, my)
    endif

    new c_constant to my.destination
        .name = c_derive_constant_name (my.constant.name)
        .value = my.constant.value
        .scope = my.constant.scope ?

        c_component_resolve_constant (c_constant)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_enum' from 'enum'.
# ---------------------------------------------------------------------------
function c_component_create_enum (enum, destination)
    check_arguments (my, "enum, destination", my)

    component_require_attr_name (my.enum)

    new c_enum to my.destination
        . = c_format_comment (my.enum. ?) ?
        .name = c_derive_enum_name (my.enum)
        .scope = my.enum.scope
        .visibility = my.enum.visibility
        .definition = my.enum.definition

        #   Should be before 'c_constant' to avoid double resolve processing
        c_component_resolve_enum (c_enum)

        for my.enum.constant
            c_component_create_enum_constant (constant, c_enum)
        endfor
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_argument' from 'argument'.
# ---------------------------------------------------------------------------
function c_component_create_argument (argument, destination)
    check_arguments (my, "argument, destination", my)

    component_require_attr_name (my.argument)

    new c_argument to my.destination
        .name = c_derive_argument_name (my.argument)

        c_component_map_instance (c_argument, my.argument)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create void 'c_argument'.
# ---------------------------------------------------------------------------
function c_component_create_void_argument (destination)
    check_arguments (my, "destination", my)

    new c_argument to my.destination
        .type = "void"
        .kind = "value"
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_return' from 'return'
# ---------------------------------------------------------------------------
function c_component_create_return (return, destination)
    check_arguments (my, "return, destination", my)

    new c_return to my.destination
        c_component_map_instance (c_return, my.return)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create void 'c_argument'.
# ---------------------------------------------------------------------------
function c_component_create_void_return (destination)
    check_arguments (my, "destination", my)

    new c_return to my.destination
        .type = "void"
        .kind = "value"
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'c_method' from 'method'.
# ---------------------------------------------------------------------------
function c_component_create_method (method, destination)
    check_arguments (my, "method, destination", my)

    component_require_attr_name (my.method)

    new c_method to my.destination
        . = c_format_comment (my.method. ?) ?
        .name = c_derive_method_name (my.method)
        .scope = my.method.scope
        .visibility = my.method.visibility
        .definition = my.method.definition

        for my.method.argument
            c_component_create_argument (argument, c_method)
        else
            c_component_create_void_argument (c_method)
        endfor

        if count (my.method.return)
            c_component_create_return (my.method->return, c_method)
        else
            c_component_create_void_return (c_method)
        endif

        c_component_map_implementation (c_method, my.method)
    endnew
endfunction

.endtemplate

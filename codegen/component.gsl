.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Perform resolution over known common components.
#
#   Resolution includes several steps:
#       1. Add default items to the component.
#       2. Set default values to the component attributes.
#       3. Define 'uid' for components that can be belong to the
#          category 'language_component'.
#       4. Define next attribute for components that belongs to the category
#          'language_component' and related to the name and type derivation:
#               - c_project_prefix;
#               - c_class_prefix;
#               - c_prefix;
#               - c_name - if defined attribute 'name';
#               - c_type - if defined attribute 'type'.
#
#   Category 'language_component' includes:
#       - method;
#       - struct;
#       - enum;
#       - macros;
#       - argument;
#       - property;
#       - constant;
#       - callback;
#       - type;
#       - return.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"

gsl from "c_formatter.gsl"
gsl from "c_resolver.gsl"


# ###########################################################################
#   C specific resolution functions.
# ###########################################################################


# ###########################################################################
#   Component inspection.
# ###########################################################################


# ---------------------------------------------------------------------------
#   Return true if given component is 'enum'.
# ---------------------------------------------------------------------------
function component_is_entry_enum (component)
    check_argument (my, "component")

    return item_in (my.component,  "enum")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component is 'struct'.
# ---------------------------------------------------------------------------
function component_is_entry_struct (component)
    check_argument (my, "component")

    return item_in (my.component,  "struct")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component is 'macros'.
# ---------------------------------------------------------------------------
function component_is_entry_macros (component)
    check_argument (my, "component")

    return item_in (my.component,  "macros")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component is 'method'.
# ---------------------------------------------------------------------------
function component_is_entry_method (component)
    check_argument (my, "component")

    return item_in (my.component,  "method")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component is 'callback'.
# ---------------------------------------------------------------------------
function component_is_entry_callback (component)
    check_argument (my, "component")

    return item_in (my.component,  "callback")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component is 'type'.
# ---------------------------------------------------------------------------
function component_is_entry_type (component)
    check_argument (my, "component")

    return item_in (my.component,  "type")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component represents instance.
# ---------------------------------------------------------------------------
function component_is_instance (component)
    check_argument (my, "component")

    return item_in (my.component,  "(object, argument, property)")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component represent self confident lamguage entry.
# ---------------------------------------------------------------------------
function component_is_entry (component)
    check_argument (my, "component")

    return item_in (my.component, "method, macros, callback, enum, struct, type, object")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component is part of the type component.
# ---------------------------------------------------------------------------
function component_is_entry_infant (component)
    check_argument (my, "component")

    return item_in (my.component, "argument, value, property, return")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component is part of the type component.
# ---------------------------------------------------------------------------
function component_is_entry_enum_infant (component, parent)
    check_argument (my, "component")

    return defined (my.parent) & item_in (my.parent, "enum") & item_in (my.component, "value")
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component can be represented as some programming
#   language construct.
# ---------------------------------------------------------------------------
function component_is_language_construct (component)
    check_argument (my, "component")

    return component_is_entry (my.component) | \
            component_is_entry_infant (my.component)
endfunction

# ---------------------------------------------------------------------------
#   Return true if given component must have a unique UID.
# ---------------------------------------------------------------------------
function component_uid_is_unique (component, parent)
    check_argument (my, "component")

    return component_is_entry (my.component) | \
            component_is_entry_enum_infant (my.component, my.parent)
endfunction

# ###########################################################################
#   Add default component item(s).
# ###########################################################################

# ---------------------------------------------------------------------------
#   For each callback property within 'struct' creates correspond type,
#   and add it to the 'destination'.
# ---------------------------------------------------------------------------
function component_add_struct_default_callbacks (struct, destination)
    check_argument (my, "struct")
    check_argument (my, "destination")

    for my.struct.property where is_true (is_callback)
        my.callback_name = struct.name + " " + property.name

        if count (my.destination.callback, callback.name = my.callback_name)
            next #  Already added.
        endif

        my.callback = item_copy_to (property, my.destination, "callback")
        my.callback.name = my.callback_name
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add default component 'return' if missed within 'method' or 'callback.
#   Note, default return type is 'nothing'.
# ---------------------------------------------------------------------------
function component_add_default_return (component)
    check_argument (my, "component")

    if count (my.component.return) = 0
        new return to my.component
            .type = "nothing"
        endnew
    endif
endfunction


# ###########################################################################
#   Set default values to component attributes.
# ###########################################################################

# ---------------------------------------------------------------------------
#   Add attributes that are common for all components.
# ---------------------------------------------------------------------------
function component_add_common_attributes (component, parent)
    check_argument (my, "component")

    my.component.visibility ?= "public"
    my.component.scope ?= "public"
    my.component.class ?= my.parent.class ?
endfunction

# ---------------------------------------------------------------------------
#   Add attributes:
#       * c_project_prefix - project prefix is used to avoid name
#               collision across projects;
#       * c_class_prefix - module level prefix is used to avoid name
#               collision within project;
#       * c_prefix - all-in-one prefix, that makes component name unique,
#               it is combination of 'c_project_prefix' and 'c_class_prefix'.
# ---------------------------------------------------------------------------
function component_add_prefixes (component, parent, project)
    check_argument (my, "component")
    check_argument (my, "project")

    if ! component_is_entry (my.component)
        echo_debug ("Do nothing for component: $(name (my.component)).", my)
    endif

    scope my.component
        .c_project_prefix = c_format_name (my.project.prefix)
        .c_class_prefix = c_format_name (0.class ? my.parent.class ?)

        if is_true (0.is_cross_domain)
            .c_prefix = ""
        else
            .c_prefix = c_format_name (0.c_project_prefix, 0.c_class_prefix)
        endif
    endscope
endfunction

# ---------------------------------------------------------------------------
#   Define attribute 'uid' for given component.
#   'uid' - is a unique name that can be used to reference this component.
#   'uid' is used within name resolution context as context a key.
# ---------------------------------------------------------------------------
function component_add_uid (component, parent)
    check_argument (my, "component")

    if component_is_entry_infant (my.component)
        check_argument (my, "parent")
    endif

    if component_is_entry (my.component)
        my.prefix = string_defined (my.component.class) ?? \
                "class $(my.component.class:)" ? "global"
    elsif component_uid_is_unique (my.component, my.parent)
        my.prefix = my.parent.uid
    endif

    my.component.uid = c_format_name (my.prefix ?, name (my.component) ?,  my.component.name ?)
endfunction

# ---------------------------------------------------------------------------
#   Define attribute 'c_name'.
# ---------------------------------------------------------------------------
function component_add_names (component, parent)
    check_argument (my, "component")

    scope my.component as component
        if ! defined (0.name)
            return
        endif

        if component_is_instance (component)
            if is_true (0.is_reference)
                .c_name = c_format_name (0.name, "ref")
            elsif is_true (0.is_callback)
                .c_name = c_format_name (0.name, "cb")
            else
                .c_name = c_format_name (0.name)
            endif
        elsif component_is_entry_struct (component) | component_is_entry_enum (component)
            .c_name = c_format_name (0.c_prefix, 0.name, "t")
        elsif component_is_entry_callback (component)
            .c_name = c_format_name (0.c_prefix, 0.name, "fn")
        elsif component_is_entry_enum_infant (component, my.parent)
            .c_name = c_format_name (my.parent.c_prefix, my.parent.name) + \
                    "_" + c_format_macros_name (0.name)
        elsif component_is_entry_macros (component)
            .c_name = c_format_macros_name (0.c_prefix, 0.name)
        elsif component_is_entry_method (component)
            .c_name = c_format_name (0.c_prefix, 0.name)
        elsif component_is_entry_type (component)
            .c_name = c_format_name (0.c_prefix, 0.name)
        elsif defined (0.name)
            .c_name = c_format_name (0.c_project_prefix, 0.name)
        else
            echo_fatal ("Unexpected component $(name (my.component) ?)", my)
        endif
    endscope
endfunction

# ---------------------------------------------------------------------------
#   Define attribute: 'c_type' that is type for C instances such as argument,
#   global varibale, constant, return value.
# ---------------------------------------------------------------------------
function component_add_types (component)
    check_argument (my, "component")

    scope my.component
        if ! defined (0.type)
            return
        endif

        if 0.type = "size"
            .c_type = "size_t"
        elsif 0.type = "string"
            .c_type = "char"
            .is_object ?= 1
        elsif 0.type = "buffer"
            .c_type = "byte"
            .is_object ?= 1
        elsif 0.type = "integer"
            .c_type = "int"
        elsif 0.type = "boolean"
            .c_type = "bool"
        elsif 0.type = "byte"
            .c_type = "byte"
        elsif 0.type = "nothing" | string_empty (0.type)
            .c_type = "void"
        elsif 0.type = "any"
            .c_type = "void"
            .is_object ?= 1
        else
            .c_type = c_resolve_ref (0.type)
        endif

        if is_true (0.is_object) & is_false (0.is_instance)
            .c_type += " *"
        endif

        if is_true (0.is_object) & is_false (0.is_mutable) & is_false (0.is_reference)
            .c_type = "const " + .c_type
        endif

        if is_false (0.is_object) & is_true (0.is_mutable)
            .c_type += " *"
        endif

        if is_true (0.is_object) & is_true (0.is_const_array)
            .c_type += "const *const "
        endif

        if is_true (0.is_object) & is_true (0.is_reference)
            .c_type += "*"
        endif

    endscope
endfunction


# ###########################################################################
#   Recursive changes in a component hierarchy.
# ###########################################################################

# ---------------------------------------------------------------------------
#   Traverse known components within parent and add default infant
#   components to it.
#   See, component_add_struct_default_callbacks ().
#   See, component_add_default_return ().
# ---------------------------------------------------------------------------
function foreach_component_add_default_items (parent)
    check_argument (my, "parent")

    for my.parent.struct
        for struct.property where is_true (is_callback)
            component_add_default_return (property)
        endfor

        component_add_struct_default_callbacks (struct, my.parent)
    endfor

    for my.parent.callback
        component_add_default_return (callback)
    endfor

    for my.parent.method
        component_add_default_return (method)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Traverse known components within parent and add default attributes.
#   See, component_add_common_attributes ().
# ---------------------------------------------------------------------------
function foreach_component_add_default_attributes (parent)
    check_argument (my, "parent")

    for my.parent. as component where component_is_entry (component)
        component_add_common_attributes (component, my.parent)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Traverse known components within parent and add prefixes.
#   See, component_add_prefixes ().
# ---------------------------------------------------------------------------
function foreach_component_add_prefixes (parent, project)
    check_argument (my, "parent")
    check_argument (my, "project")

    for my.parent. as component where component_is_entry (component)
        component_add_prefixes (component, my.parent, my.project)
        foreach_component_add_prefixes (component, my.project)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Traverse known components within parent and add uid.
#   See, component_add_uid ().
# ---------------------------------------------------------------------------
function foreach_component_add_uid (parent)
    check_argument (my, "parent")

    for my.parent. as component where component_is_language_construct (component)
        component_add_uid (component, my.parent)
        foreach_component_add_uid (component)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Traverse known components within parent and add name.
#   See, component_add_names ().
# ---------------------------------------------------------------------------
function foreach_component_add_names (parent)
    check_argument (my, "parent")

    for my.parent. as component where component_is_language_construct (component)
        component_add_names (component, my.parent)
        foreach_component_add_names (component)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Traverse known components within parent and add name.
#   See, component_add_types ().
# ---------------------------------------------------------------------------
function foreach_component_add_types (parent)
    check_argument (my, "parent")

    for my.parent. as component where component_is_language_construct (component)
        component_add_types (component)
        foreach_component_add_types (component)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Traverse known components within parent and perform complete resolution.
# ---------------------------------------------------------------------------
function foreach_component_resolve (parent, project)
    check_argument (my, "parent")
    check_argument (my, "project")

    foreach_component_add_default_items (my.parent)
    foreach_component_add_default_attributes (my.parent)
    foreach_component_add_prefixes (my.parent, my.project)
    foreach_component_add_uid (my.parent)
    foreach_component_add_names (my.parent)
    foreach_component_add_types (my.parent)
endfunction


# ###########################################################################
#   Per component resolution.
# ###########################################################################

# ---------------------------------------------------------------------------
#   Resolve component: 'method'.
# ---------------------------------------------------------------------------
function component_resolve_method (method, parent, project)
    check_argument (my, "method")
    check_argument (my, "parent")
    check_argument (my, "project")

    component_add_common_attributes (my.method)
    component_add_default_return (my.method)
    component_add_prefixes (my.method, my.parent, my.project)
    component_add_uid (my.method, my.parent)
    component_add_names (my.method, my.parent)

    foreach_component_resolve (my.method, my.project)
endfunction


# ###########################################################################
#   Context.
# ###########################################################################


# ---------------------------------------------------------------------------
#   Collect all attributes with suffix '_name' within component and write
#   them to the context.
#   Written key-pair pattern:
#       <name_prefix>_<component.uid> = component.<name_prefix>_name
#   Supported values for <name_prefix>:
#       { c, cpp, java, csharp }.
# ---------------------------------------------------------------------------
function component_update_context (component, context)
    check_argument (my, "component")
    check_argument (my, "context")

    if string_empty (my.component.uid)
        return
    endif

    if component_is_instance (my.component)
        if is_true (my.component.is_callback)
            my.uid_suffix = c_format_name (my.uid_suffix, "cb")
        endif

        if is_true (my.component.is_reference)
            my.uid_suffix = c_format_name (my.uid_suffix, "ref")
        endif

        if defined (my.uid_suffix)
            my.uid_suffix = "_" + my.uid_suffix
        endif
    endif

    scope my.component
        my.context.$(0.uid:)$(my.uid_suffix ?:) = 0.name ?
        my.context.c_$(0.uid:)$(my.uid_suffix ?:) = 0.c_name ?
        my.context.cpp_$(0.uid:)$(my.uid_suffix ?:) = 0.cpp_name ?
        my.context.java_$(0.uid:)$(my.uid_suffix ?:) = 0.java_name ?
        my.context.csharp_$(0.uid:)$(my.uid_suffix ?:) = 0.csharp_name ?
    endscope
endfunction

# ---------------------------------------------------------------------------
#   Update context with data from each 'module' within source.
# ---------------------------------------------------------------------------
function foreach_component_update_context (source, context)
    check_argument (my, "source")
    check_argument (my, "context")

    for my.source. as component where is_item (component)
        component_update_context (component, my.context)

        foreach_component_update_context (component, my.context)
    endfor
endfunction

.endtemplate

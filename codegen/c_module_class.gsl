.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Transform abstract 'class' declaration to the C language components.
#
#   Private function prefix is: X13.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------


gsl from "common.gsl"

# ---------------------------------------------------------------------------
#   Add model 'struct' that handles class context.
# ---------------------------------------------------------------------------
function _X13_add_context_struct (class, declaration, definition, destination, meta)
    check_arguments (my, "class, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    new struct to my.destination
        . = "Handle '$(my.class.name:)' context."
        .name = my.class.name
        .of_class = my.class.of_class ?
        .declaration = my.declaration
        .definition = my.definition

        for my.class.property
            copy property to struct
        endfor

        if my.class.lifecycle <> "none" & my.class.context <> "none"
            new property to struct
                .name = my.names.class_property_self_dealloc
                .callback = ".(global_callback_dealloc)"
                .="\
                Function do deallocate self context.
                "
            endnew
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
function _X13_add_method_context_size (class, destination, meta)
    check_arguments (my, "class, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.class_method_ctx_size
        . = "\
        Return size of '$(my.refs.c_class_struct_ctx)'.
        "

        new return to method
            .type = "size"
        endnew

        new code to method
            . = "\
                return sizeof($(my.refs.c_class_struct_ctx));
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
function _X13_resolve_argument_ctx (argument, meta)
    check_arguments (my, "argument, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    scope my.argument
        .name ?= my.names.class_argument_ctx
        .class = my.refs.class_struct_ctx # redefine placeholder class='context'
        .access ?= "readwrite"
    endscope
endfunction

# ---------------------------------------------------------------------------
function _X13_resolve_return_ctx (ret, meta)
    check_arguments (my, "ret, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    scope my.ret
        .class = my.refs.class_struct_ctx # redefine placeholder class='context'
        .access ?= "disown"
    endscope
endfunction

# ---------------------------------------------------------------------------
function _X13_add_argument_ctx (destination, meta)
    check_arguments (my, "destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    my.argument = item_prepend_new ("argument", my.destination)

    scope my.argument
        .name = my.names.class_argument_ctx
        .class = my.refs.class_struct_ctx
        .access = "readwrite"
    endscope
endfunction

# ---------------------------------------------------------------------------
function _X13_add_argument_ctx_ref (destination, meta)
    check_arguments (my, "destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new argument to my.destination
        .name = my.names.class_argument_ctx
        .class = my.refs.class_struct_ctx
        .access = "disown"
    endnew
endfunction

# ---------------------------------------------------------------------------
function _X13_add_return_error (destination, meta)
    check_arguments (my, "destination, meta", my)

    new return to my.destination
        .type = "error"
    endnew
endfunction

# ---------------------------------------------------------------------------
function _X13_add_method_init (class, destination, meta)
    check_arguments (my, "class, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Perform initialization of pre-allocated context.
        "
        .name = my.names.method_init

        _X13_add_argument_ctx (method, my.meta)

        new code to method
            .type = "stub"
            . = "
            .(c_class_assert_macros_ptr)($(my.refs.class_argument_ctx));

            //  TODO: This is STUB. Implement me.
            "
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _X13_add_method_cleanup (class, destination, meta)
    check_arguments (my, "class, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Release all inner resources.
        "
        .name = my.names.method_cleanup

        _X13_add_argument_ctx (method, my.meta)
    endnew
endfunction


# ---------------------------------------------------------------------------
function _X13_add_method_new (class, destination, meta)
    check_arguments (my, "class, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Allocate context and perform it's initialization.
        "
        .name = my.names.method_new

        new return to method
            .class = my.refs.class_struct_ctx
            .access = "disown"
        endnew

        new code to method
            my.type_ctx = my.refs.c_class_struct_ctx
            my.arg_ctx = my.names.c_class_argument_ctx

            . = "\
            $(my.type_ctx) *$(my.arg_ctx:) = ($(my.type_ctx) *) .(c_global_method_alloc)(sizeof ($(my.type_ctx)));
            .(c_class_assert_macros_alloc)($(my.arg_ctx:));

            $(my.refs.c_class_method_init)($(my.arg_ctx:));

            $(my.arg_ctx:)->$(my.refs.c_class_property_self_dealloc) = .(c_global_method_dealloc);

            return $(my.arg_ctx:);
            "
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _X13_add_constructor (class, constructor, destination, meta)
    check_arguments (my, "class, constructor, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = cat (my.names.method_new, my.constructor.name)

        . = my.constructor. ?

        for my.constructor.argument
            copy argument to method
        endfor

        new return to method
            .class = my.refs.class_struct_ctx
            .access = "disown"
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _X13_add_method_delete (class, destination, meta)
    check_arguments (my, "class, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.method_delete

        . = "\
        Release all inner resorces and deallocate context if needed.
        It is safe to call this method even if context was allocated by the caller.
        "

        _X13_add_argument_ctx (method, my.meta)

        new code to method
            my.arg_ctx = my.refs.class_argument_ctx

            . = "\
            if (NULL == $(my.arg_ctx)) {
                return;
            }

            $(my.refs.c_class_method_cleanup)($(my.arg_ctx));

            if ( $(my.arg_ctx:)->$(my.refs.c_class_property_self_dealloc) != NULL) {
                 $(my.arg_ctx:)->$(my.refs.c_class_property_self_dealloc)($(my.arg_ctx));
            }
            "
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _X13_add_method_destroy (class, destination, meta)
    check_arguments (my, "class, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.method_destroy

        . = "\
        Delete given context and nullifies reference.
        This is a reverse action of the function '$(my.refs.c_class_method_new) ()'.
        "

        _X13_add_argument_ctx_ref (method, my.meta)

        new code to method
            my.arg_ctx_ref = my.refs.class_argument_ctx
            my.arg_ctx = my.names.c_class_argument_ctx
            my.type_ctx = my.refs.c_class_struct_ctx

            . = "\
            .(c_class_assert_macros_ptr)($(my.arg_ctx_ref));

            $(my.type_ctx) *$(my.arg_ctx:) = *$(my.arg_ctx_ref);
            *$(my.arg_ctx_ref) = NULL;

            $(my.refs.c_class_method_delete)($(my.arg_ctx:));
            "
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Copy class methods with context resolution.
# ---------------------------------------------------------------------------
function _X13_add_method (method, destination, meta)
    check_arguments (my, "method, destination, meta", my)

    my.copied_method = item_copy_to (my.method, my.destination)

    for my.copied_method.argument where string_equal(0.class, "context")
        _X13_resolve_argument_ctx (argument, my.meta)
    endfor

    for my.copied_method.return where string_equal(0.class, "context")
        _X13_resolve_return_ctx (return, my.meta)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add methods that manages class lifecycle.
# ---------------------------------------------------------------------------
function _X13_add_lifecycle_methods (class, destination, meta)
    check_arguments (my, "class, destination, meta", my)

    _X13_add_method_init (my.class, my.destination, my.meta)
    _X13_add_method_cleanup (my.class, my.destination, my.meta)
    _X13_add_method_new (my.class, my.destination, my.meta)

    for my.class.constructor
        _X13_add_constructor (my.class, constructor, my.destination, my.meta)
    endfor

    _X13_add_method_delete (my.class, my.destination, my.meta)
    _X13_add_method_destroy (my.class, my.destination, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Create 'module' component with a public API for given class.
# ---------------------------------------------------------------------------
function c_module_class_create_module_public (class, destination, meta)
    check_arguments (my, "class, destination, meta", my)

    my.names = meta_names (my.meta)

    new module to my.destination
        . = my.class.?
        .name = my.names.class_module
        .feature = my.class.name
        .of_class = my.class.of_class ?
        .c_prefix = my.class.c_prefix ?
        .scope = my.class.scope ?

        new require to module
            .module = my.names.module_library
        endnew

        new require to module
            .module = my.names.module_error
        endnew

        new require to module
            .module = my.names.module_memory
            .scope = "private"
        endnew

        new require to module
            .module = my.names.module_assert
            .scope = "private"
        endnew


        if my.class.context = "public"
            _X13_add_context_struct (my.class, "public", "public", module, my.meta)

        elsif my.class.context = "private"
            _X13_add_context_struct (my.class, "public", "external", module, my.meta)

            new require to module
                .module = my.names.class_module_defs
                .scope = "private"
            endnew

        elsif my.class.context = "internal"
            _X13_add_context_struct (my.class, "public", "private", module, my.meta)
        endif


        if my.class.context <> "none" & my.class.context <> "public"
            _X13_add_method_context_size (my.class, module, my.meta)
        endif


        if my.class.lifecycle <> "none" & my.class.context <> "none"
            _X13_add_lifecycle_methods (my.class, module, my.meta)
        endif


        for my.class.require
            copy require to module
        endfor

        for my.class.c_include
            copy c_include to module
        endfor

        for my.class.constant
            copy constant to module
        endfor

        for my.class.property
            copy property to module
        endfor

        for my.class.enum
            copy enum to module
        endfor

        for my.class.callback
            copy callback to module
        endfor

        for my.class.method
            _X13_add_method (method, module, my.meta)
        endfor

        for my.class.macros
            copy macros to module
        endfor

        for my.class.macroses
            copy macroses to module
        endfor

        for my.class.struct
            copy struct to module
        endfor

        for my.class.variable
            copy variable to module
        endfor
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Create 'module' component with a types defineition for given class.
# ---------------------------------------------------------------------------
function c_module_class_create_module_defs (class, destination, meta)
    check_arguments (my, "class, destination, meta", my)

    my.names = meta_names (my.meta)

    new module to my.destination
        .name = my.names.class_module_defs
        .scope = "private"
        .feature = my.class.name
        . = "
        Class '$(my.class.name:)' types definition.
        "

        new require to module
            .module = my.names.module_library
        endnew

        _X13_add_context_struct (my.class, "external", "public", module, my.meta)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Entrypoint.
# ---------------------------------------------------------------------------
function c_module_class_create (source, destination, meta)
    check_arguments (my, "source, destination, meta", my)

    for my.source.class by name
        meta_reset_active_entity (my.meta, class.name)
        c_module_class_create_module_public (class, my.destination, my.meta)

        if class.context = "private"
            c_module_class_create_module_defs (class, my.destination, my.meta)
        endif
    endfor

endfunction

.endtemplate

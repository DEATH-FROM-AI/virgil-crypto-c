.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Contains API for Swift wrapper generation.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"
gsl from "interface.gsl"
gsl from "component.gsl"
gsl from "c_component.gsl"
gsl from "swift_codegen.gsl"


# ===========================================================================
#   Name and type derivation.
# ===========================================================================

# ---------------------------------------------------------------------------
#   If attribute 'project' is defined within <instance/> then return project
#   prefix, otherwise return empty string.
# ---------------------------------------------------------------------------
function swift_derive_instance_project_uid (instance)
    check_arguments (my, "instance", my)

    return defined (my.instance.project) ?? make_id ("project", my.instance.project) ? ""
endfunction

# ---------------------------------------------------------------------------
#   Crate uid based on the given options.
#   Examples:
#       {struct, buffer, buffer} - returns "class_buffer_struct_buffer"
#       {struct, inner/buffer, buffer} - returns "class_inner_struct_buffer"
#       {enum, impl/tag,} - returns "class_impl_enum_tag"
#       {struct, codes,} - returns "global_struct_codes"
# ---------------------------------------------------------------------------
function c_component_derive_instance_type_uid (type_id, type_value, of_class)
    check_arguments (my, "type_id, type_value", my)

    if regexp.match ("([^\/]+)\/(.+)", my.type_value, my.group1, my.group2)
        my.of_class = my.group1
        my.type_value = my.group2
    endif

    if defined (my.of_class)
        return make_id ("class", my.of_class, my.type_id, my.type_value)

    else
        return make_id ("global", my.type_id, my.type_value)
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted module name.
# ---------------------------------------------------------------------------
function swift_derive_module_name (type)
    check_arguments (my, "type", my)

    assert_attribute (my.type, "name", my)

    return "$(my.type.name:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted constant name.
# ---------------------------------------------------------------------------
function swift_derive_constant_name (instance, wrapper)
    assert_attribute (my.instance, "name", my)

    return "$(my.instance.name:Camel)"
endfunction

# ---------------------------------------------------------------------------
#   Return mapped constant type.
# ---------------------------------------------------------------------------
function swift_derive_constant_type (instance, wrapper)
    check_arguments (my, "instance, wrapper", my)

    return "Int"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted instance name.
# ---------------------------------------------------------------------------
function swift_derive_instance_name (instance, wrapper)
    check_arguments (my, "instance, wrapper", my)

    assert_attribute (my.instance, "name", my)

    return "$(my.instance.name:Camel)"
endfunction

# ---------------------------------------------------------------------------
#   Derive Swift integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function swift_derive_integer_type (size)
    if defined (my.size)
        if my.size = "1"
            return "Int8"

        elsif my.size = "2"
            return "Int16"

        elsif my.size = "4"
            return "Int32"

        elsif my.size = "8"
            return "Int64"
        else
            echo_fatal ("Unsupported size 'my.size' for Swift integers", my)
        endif
    else
        return "Int"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Derive Swift unsigned integer type correspond to it's size.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function swift_derive_unsigned_type (size)
    if defined (my.size)
        if my.size = "1"
            return "UInt8"

        elsif my.size = "2"
            return "UInt16"

        elsif my.size = "4"
            return "UInt32"

        elsif my.size = "8"
            return "UInt64"
        else
            echo_fatal ("Unsupported size 'my.size' for Swift unsigned integers", my)
        endif
    else
        return "UInt"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Derive Swift size type correspond to it's size.
#   Note, Swift size type represented as Int type.
#   Size: {1, 2, 4, 8}.
# ---------------------------------------------------------------------------
function swift_derive_size_type (size)
    if defined (my.size)
        if my.size = "1"
            return "Int8"

        elsif my.size = "2"
            return "Int16"

        elsif my.size = "4"
            return "Int32"

        elsif my.size = "8"
            return "Int64"
        else
            echo_fatal ("Unsupported size 'my.size' for Swift size type", my)
        endif
    else
        return "Int"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Return formatted method name.
# ---------------------------------------------------------------------------
function swift_derive_method_name (method, wrapper)
    check_arguments (my, "method, wrapper", my)

    return "$(my.method.name:Camel)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Swift protocol.
# ---------------------------------------------------------------------------
function swift_derive_protocol_name (interface, wrapper)
    check_arguments (my, "interface, wrapper", my)

    assert_attribute_one_of (my.interface, "name, interface", my)

    return "$(my.interface.name ? my.interface.interface:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Swift class.
# ---------------------------------------------------------------------------
function swift_derive_class_name (class, wrapper)
    check_arguments (my, "class, wrapper", my)

    assert_attribute_one_of (my.class, "name", my)

    return "$(my.class.name:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Swift enum.
# ---------------------------------------------------------------------------
function swift_derive_enum_name (enum, wrapper)
    check_arguments (my, "enum, wrapper", my)

    assert_attribute_one_of (my.enum, "name", my)

    if my.enum.name = "error"
        return "$(my.wrapper.project:Pascal)$(my.enum.name:Pascal)"
    else
        return "$(my.enum.name:Pascal)"
    endif

endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Objective-C protocol.
# ---------------------------------------------------------------------------
function swift_derive_protocol_objc_name (swift_protocol, wrapper)
    check_arguments (my, "swift_protocol, wrapper", my)

    return "$(my.wrapper.prefix:UPPER)$(my.swift_protocol.name:)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Objective-C class.
# ---------------------------------------------------------------------------
function swift_derive_class_objc_name (swift_class, wrapper)
    check_arguments (my, "swift_class, wrapper", my)

    return "$(my.wrapper.prefix:UPPER)$(my.swift_class.name:)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the Objective-C enum.
# ---------------------------------------------------------------------------
function swift_derive_enum_objc_name (swift_enum, wrapper)
    check_arguments (my, "swift_enum, wrapper", my)

    return "$(my.wrapper.prefix:UPPER)$(my.swift_enum.name:)"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted argument name.
# ---------------------------------------------------------------------------
function swift_derive_argument_name (argument, wrapper)
    check_arguments (my, "argument, wrapper", my)

    return "$(my.argument.name:Camel)"
endfunction


# ===========================================================================
#   Attribute mapping.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Map attribute 'access' of <component/> to <swift_component/>.
# ---------------------------------------------------------------------------
function swift_map_attr_access (swift_component, component)
    check_arguments (my, "swift_component, component", my)

    assert_attribute (my.component, "access", my)

    my.swift_component.access = my.component.access
endfunction

# ---------------------------------------------------------------------------
#   Map attribute 'visibility' of <component/> to <swift_component/>.
# ---------------------------------------------------------------------------
function swift_map_attr_visibility (swift_component, component)
    check_arguments (my, "swift_component, component", my)

    #   TODO: make mapping more accurate.
    my.swift_component.visibility = my.component.visibility ? "public"
endfunction

# ---------------------------------------------------------------------------
#   Map attribute 'scope' of <component/> to <swift_component/>.
# ---------------------------------------------------------------------------
function swift_map_attr_scope (swift_component, component)
    check_arguments (my, "swift_component, component", my)

    #   TODO: make mapping more accurate.
    my.swift_component.scope = my.component.scope ? "public"
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <swift_instance type=""/> attributes.
# ---------------------------------------------------------------------------
function swift_map_instance_type (swift_instance, instance)
    check_arguments (my, "swift_instance, instance", my)

    if defined (my.instance.type)
        if my.instance.type = "nothing"
            my.swift_instance.type = "Void"

        elsif my.instance.type = "boolean"
            my.swift_instance.type = "Bool"

        elsif my.instance.type = "integer"
            my.swift_instance.type = swift_derive_integer_type (my.instance.size ?)

        elsif my.instance.type = "unsigned"
            my.swift_instance.type = swift_derive_unsigned_type (my.instance.size ?)

        elsif my.instance.type = "byte"
            my.swift_instance.type = "UInt8"

        elsif my.instance.type = "size"
            my.swift_instance.type = swift_derive_size_type (my.instance.size ?)

        elsif my.instance.type = "char"
            my.swift_instance.type = "Character"

        else
            echo_fatal ("Unsupported instance type '$(my.instance.type)' for Swift language.", my)
        endif

    elsif defined (my.instance.class)

        if my.instance.class = "any"
            my.swift_instance.type = "Any"

        elsif my.instance.class = "data"
            my.swift_instance.type = "Data"

        elsif my.instance.class = "buffer"
            my.swift_instance.type = "Data"

        elsif is_ref (my.instance.class) | defined (my.instance.library)
            my.swift_instance.type = swift_lang_ref (my.instance.class)

        else
            my.project_uid = swift_derive_instance_project_uid (my.instance)
            my.type_uid = make_id ("class", "$(my.instance.class:Pascal)")
            my.swift_instance.type = make_ref_swift (make_id(my.project_uid, my.type_uid))
        endif

    elsif defined (my.instance.enum)
        if is_ref (my.instance.enum) | defined (my.instance.library)
            my.swift_instance.type = swift_lang_ref (my.instance.enum)

        else
            my.swift_instance.type = my.instance.enum
        endif

    else
        my.instance_dump = component_instance_dump (my.instance)

        echo_warning ("Unreacheable code, component_resolve_instance() must handle this. $(my.instance_dump:)", my)

        my.swift_instance.type = "Unknown"
    endif
endfunction

# ---------------------------------------------------------------------------
#   Map <instance/> attributes to the <swift_instance/> attributes.
# ---------------------------------------------------------------------------
function swift_map_instance (swift_instance, instance)
    check_arguments (my, "swift_instance, instance", my)

    swift_map_attr_access (my.swift_instance, my.instance)
    swift_map_instance_type (my.swift_instance, my.instance)
endfunction


# ===========================================================================
#   Component resolution.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Resolve UIDs for given component and all inner components.
# ---------------------------------------------------------------------------
function swift_module_resolve_uids (swift_component, parent_uid)
    check_arguments (my, "swift_component", my)

    if defined (my.parent_uid) & string.prefixed (my.parent_uid, "swift_module")
        my.parent_uid = # Undefined
    endif

    my.component_name = name (my.swift_component)
    if  defined (my.parent_uid) & string.prefixed (my.component_name, "swift_")
        regexp.match ("swift_(.+)", my.component_name, my.component_name)
    endif

    my.swift_component.uid = make_id (my.parent_uid, my.component_name, my.swift_component.name)

    for my.swift_component. as inner_component where is_item (inner_component) & defined (inner_component.name)
        swift_module_resolve_uids (inner_component, my.swift_component.uid)
    endfor
endfunction


# ===========================================================================
#   Module resolution.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Setup and check default and automatically resolved attributes.
# ---------------------------------------------------------------------------
function swift_resolve (project, wrapper)
    check_arguments (my, "project, wrapper", my)

    echo_info ("Resolve <wrapper lang=\"$(my.wrapper.lang:)\"/> for project: '$(my.project.name:)'", my)

    assert_attribute (my.wrapper, "lang", my)
    assert_attributes (my.project, "name, prefix, framework", my)
    assert_item (my.project, "license", my)

    my.wrapper.project = my.project.name
    my.wrapper.prefix = my.project.prefix
    my.wrapper.framework = my.project.framework
    my.wrapper.namespace = "$(my.project.namespace:Pascal)"
    my.wrapper.namespace_dir = my.wrapper.namespace
    my.wrapper.source_dir = \
            cat_path ("../wrappers/$(my.wrapper.lang:c,lower)", "VirgilCrypto", my.wrapper.namespace_dir)
    copy my.project->license to my.wrapper
endfunction

# ---------------------------------------------------------------------------
#   Add auto-resolving attributes:
#       - uid.
# ---------------------------------------------------------------------------
function swift_module_resolve (swift_module, wrapper)
    check_arguments (my, "swift_module, wrapper", my)

    echo_trace ("Resolving <$(name (my.swift_module)) name=\"$(my.swift_module.name:)\"/>", my)

    assert_attribute (my.swift_module, "name", my)

    #   Resolve UIDs
    swift_module_resolve_uids (my.swift_module)
endfunction


# ===========================================================================
#   Component creation.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Add new <swift_class/> that encapsulate multiple objects returned by
#   method.
# ---------------------------------------------------------------------------
function swift_create_result_class (parent, swift_method, destination, wrapper, meta)
    check_arguments (my, "parent, swift_method, destination, wrapper, meta", my)

    assert_attributes (my.parent, "name, visibility", my)
    assert_attribute (my.swift_method, "name", my)

    new swift_class to my.destination
        . = "/// Encapsulate result of method $(my.parent.name:).$(my.swift_method.name:)()"
        .name = "$(my.parent.name:Pascal)$(my.swift_method.name:Pascal)Result"
        .objc_name = swift_derive_class_objc_name (swift_class, my.wrapper)
        .visibility = my.parent.visibility

        new swift_inherit to swift_class
            .type = "NSObject"
        endnew

        for my.swift_method.swift_return
            delete swift_return
        endfor

        new swift_return to my.swift_method
            .type = swift_class.name
        endnew

        return swift_class
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_inherit/> from the entity <inherit/>.
# ---------------------------------------------------------------------------
function swift_create_inherit (inherit, destination, wrapper, meta)
    check_arguments (my, "inherit, destination, wrapper, meta", my)

    new swift_inherit to my.destination
        .type = swift_derive_protocol_name (my.inherit, my.wrapper)

        return swift_inherit
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_property/> from the entity <instance/>.
# ---------------------------------------------------------------------------
function swift_create_property_from_constant (constant, destination, wrapper, meta)
    check_arguments (my, "constant, destination, wrapper, meta", my)

    new swift_property to my.destination
        . = swift_format_description (my.constant) ?
        .name = swift_derive_constant_name (my.constant, my.wrapper)
        .type = swift_derive_constant_type (my.constant, my.wrapper)
        .visibility = "public"
        .access = "readonly"

        return swift_property
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_property/> from the entity <instance/>.
# ---------------------------------------------------------------------------
function swift_create_property_from_instance (instance, destination, wrapper, meta)
    check_arguments (my, "instance, destination, wrapper, meta", my)

    assert_attribute (my.instance, "access", my)

    new swift_property to my.destination
        . = swift_format_description (my.instance) ?
        .name = swift_derive_instance_name (my.instance, my.wrapper)

        swift_map_instance (swift_property, my.instance)

        new swift_getter to swift_property
        endnew

        if my.instance.access <> "readonly"
            new swift_setter to swift_property
            endnew
        endif

        return swift_property
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_argument/> from the entity <argument/>.
# ---------------------------------------------------------------------------
function swift_create_argument (argument, destination, wrapper, meta)
    check_arguments (my, "argument, destination, wrapper, meta", my)

    assert_attributes (my.argument, "name", my)

    new swift_argument to my.destination
        .name = swift_derive_instance_name (my.argument, my.wrapper)

        swift_map_instance (swift_argument, my.argument)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_return/> from the entity <argument/>.
# ---------------------------------------------------------------------------
function swift_create_return_from_argument (argument, destination, wrapper, meta)
    check_arguments (my, "argument, destination, wrapper, meta", my)

    assert_attributes (my.argument, "name", my)

    new swift_return to my.destination
        .name = swift_derive_instance_name (my.argument, my.wrapper)

        swift_map_instance (swift_return, my.argument)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_return/> from the entity <return/>if it is not
#   an error, otherwise nothing is created.
# ---------------------------------------------------------------------------
function swift_create_return (return, destination, wrapper, meta)
    check_arguments (my, "return, destination, wrapper, meta", my)

    new swift_return to my.destination
        swift_map_instance (swift_return, my.return)
        swift_return.name ?= "$(swift_return.type:Camel)"
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_method/> from the entity <method/>.
# ---------------------------------------------------------------------------
function swift_create_method_declaration (method, destination, wrapper, meta)
    check_arguments (my, "method, destination, wrapper, meta", my)

    new swift_method to my.destination
        . = swift_format_description (my.method) ?
        .name = swift_derive_method_name (method, my.wrapper)
        .throws = count (my.method.return, string_equal (return.enum, "error")) ?? "1" ? "0"

        swift_map_attr_visibility (swift_method, my.method)

        swift_method.modifier = my.method.is_static ?? "static" ?

        for my.method.argument
            if argument.access <> "writeonly"
                swift_create_argument (argument, swift_method, my.wrapper, my.meta)
            else
                swift_create_return_from_argument (argument, swift_method, my.wrapper, my.meta)
            endif
        endfor

        for my.method.return where ! string_equal (return.enum, "error")
            swift_create_return (return, swift_method, my.wrapper, my.meta)
        endfor

        return swift_method
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add method implementation that makes proxy call to the correspond C
#   method.
# ---------------------------------------------------------------------------
function swift_implement_class_method (swift_class, swift_method, method, wrapper, meta)
    check_arguments (my, "swift_class, swift_method, method, wrapper, meta", my)

    my.c_method_name = "todo"
    my.c_method_args = ""


    new swift_code to my.swift_method
        . = "\
            throw NSError()
        "
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <swift_method/> from the entity inetrafce <method/>.
# ---------------------------------------------------------------------------
function swift_create_implemented_method (method, destination, wrapper, meta)
    check_arguments (my, "method, destination, wrapper, meta", my)

    new swift_method to my.destination
        . = swift_format_description (my.method) ?
        .name = swift_derive_method_name (method, my.wrapper)
        .throws = count (my.method.return, string_equal (return.enum, "error")) ?? "1" ? "0"

        swift_map_attr_visibility (swift_method, my.method)

        for my.method.argument
            if argument.access <> "writeonly"
                swift_create_argument (argument, swift_method, my.wrapper, my.meta)
            else
                swift_create_return_from_argument (argument, swift_method, my.wrapper, my.meta)
            endif
        endfor

        for my.method.return where ! string_equal (return.enum, "error")
            swift_create_return (return, swift_method, my.wrapper, my.meta)
        endfor

        return swift_method
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add all required components
# ---------------------------------------------------------------------------
function swift_create_methods_from_interface (interface, swift_class, wrapper, meta)
    check_arguments (my, "interface, swift_class, wrapper, meta", my)

    swift_create_inherit (my.interface, my.swift_class, my.wrapper, my.meta)

    for my.interface.method
        swift_create_implemented_method (method, my.swift_class, my.wrapper, my.meta)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Create enumeration <swift_constant/> from the entity <constant/>
# ---------------------------------------------------------------------------
function swift_create_enum_constant (constant, swift_enum, wrapper, meta)
    check_arguments (my, "constant, swift_enum, wrapper, meta", my)

    assert_attribute (my.constant, "name", my)

    new swift_constant to my.swift_enum
        . = swift_format_description (my.constant) ?
        .name = swift_derive_constant_name (my.constant, my.wrapper)
        .value = my.constant.value ?
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add entities specific for "error" enum.
# ---------------------------------------------------------------------------
function swift_map_enum_error (swift_enum, enum, wrapper, meta)
    check_arguments (my, "swift_enum, enum, wrapper, meta")

    new swift_inherit to my.swift_enum
        .type = "Error"
    endnew

    for my.enum.constant where 0.name <> "success"
        swift_create_enum_constant (constant, my.swift_enum, my.wrapper, my.meta)
    endfor

    new swift_method to my.swift_enum
        . = "/// Check given C error (result), and if it's not \"success\" then throw correspond exception."
        .name = "handleError"
        .visibility = "internal"
        .modifier = "static"
        .throws = "1"

        new swift_argument to swift_method
            .name = "code"
            .ext_name = "fromC"
            .type = make_ref_c (make_id ("class", my.enum.name, "enum", my.enum.name))
        endnew

        my.success_constant = \
                make_ref_c (make_id ("global", "enum", my.enum.name, "constant success"))

        new swift_code to swift_method
            . = "\
                if code != $(my.success_constant:) {
                    throw $(my.swift_enum.name:)(fromC: code)
                }
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add entities for regular enums (not error codes).
# ---------------------------------------------------------------------------
function swift_map_enum_default (swift_enum, enum, wrapper, meta)
    check_arguments (my, "swift_enum, enum, wrapper, meta")

    for my.enum.constant
        swift_create_enum_constant (constant, my.swift_enum, my.wrapper, my.meta)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add constructor init(fromC: c_enum_type)
# ---------------------------------------------------------------------------
function swift_create_enum_constructor (swift_enum, enum, wrapper, meta)
    check_arguments (my, "swift_enum, enum, wrapper, meta")

    new swift_constructor to my.swift_enum
        . = "/// Create enumeration value from the correspond C enumeration value."
        .visibility = "internal"

        my.arg_enum_name = swift_derive_argument_name (my.enum, my.wrapper)

        new swift_argument to swift_constructor
            .name = my.arg_enum_name
            .ext_name = "fromC"
            .type = make_ref_c (make_id ("class", my.enum.name, "enum", my.enum.name))
        endnew

        new swift_code to swift_constructor
            . = "\
                self.init(rawValue: Int($(my.arg_enum_name:).rawValue))!
            "
        endnew
    endnew
endfunction

# ===========================================================================
#   Create modules.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Create module with Swift protocol from the abstract 'interface' notion.
# ---------------------------------------------------------------------------
function swift_create_interface_module (interface, destination, wrapper, meta)
    check_arguments (my, "interface, destination, wrapper, meta", my)

    if my.interface.scope <> "internal"
        echo_info ("Create <swift_module/> from interface: '$(my.interface.name:)'", my)
    else
        echo_info ("Skip creating <swift_module/> from internal interface: '$(my.interface.name:)'", my)
    endif

    new swift_module to my.destination
        .name = swift_derive_module_name (my.interface)
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.wrapper.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.wrapper->license) ?
        endnew

        new swift_import to swift_module
            .framework = "Foundation"
        endnew

        new swift_import to swift_module
            .framework = my.wrapper.framework
        endnew

        new swift_protocol to swift_module
            . = swift_format_description (my.interface) ?
            .name = swift_derive_protocol_name (my.interface, my.wrapper)
            .objc_name = swift_derive_protocol_objc_name (swift_protocol, my.wrapper)

            swift_map_attr_visibility (swift_protocol, my.interface)

            for my.interface.inherit
                swift_create_inherit (inherit, swift_protocol, my.wrapper, my.meta)
            endfor

            for my.interface.constant
                swift_create_property_from_constant (constant, swift_protocol, my.wrapper, my.meta)
            endfor

            for my.interface.method
                my.swift_method = swift_create_method_declaration (method, swift_protocol, my.wrapper, my.meta)

                if count (my.swift_method.swift_return) > 1
                    swift_create_result_class (\
                            swift_protocol, my.swift_method, swift_module, my.wrapper, my.meta)
                endif
            endfor
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create module with Swift class from the abstract 'implementation' notion.
# ---------------------------------------------------------------------------
function swift_create_implementation_module (implementation, interfaces, destination, wrapper, meta)
    check_arguments (my, "implementation, interfaces, destination, wrapper, meta", my)

    if my.implementation.scope <> "internal"
        echo_info ("Create <swift_module/> from implementation: '$(my.implementation.name:)'", my)
    else
        echo_info ("Skip creating <swift_module/> from internal implementation: '$(my.implementation.name:)'", my)
    endif

    new swift_module to my.destination
        .name = swift_derive_module_name (my.implementation)
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.wrapper.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.wrapper->license) ?
        endnew

        new swift_import to swift_module
            .framework = "Foundation"
        endnew

        new swift_import to swift_module
            .framework = my.wrapper.framework
        endnew

        new swift_class to swift_module
            . = swift_format_description (my.implementation) ?
            .name = swift_derive_class_name (my.implementation, my.wrapper)
            .objc_name = swift_derive_class_objc_name (swift_class, my.wrapper)

            swift_map_attr_visibility (swift_class, my.implementation)

            new swift_inherit to swift_class
                .type = "NSObject"
            endnew

            for my.implementation.interface as interface_link
                my.interface = interface_find (interface_link.name, my.interfaces)
                swift_create_methods_from_interface (my.interface, swift_class, my.wrapper, my.meta)
            endfor

            for my.implementation.constant
                swift_create_property_from_constant (constant, swift_class, my.wrapper, my.meta)
            endfor

            for my.implementation.method where method.declaration = "public"
                my.swift_method = swift_create_method_declaration (method, swift_class, my.wrapper, my.meta)

                if count (my.swift_method.swift_return) > 1
                    swift_create_result_class (\
                            swift_class, my.swift_method, swift_module, my.wrapper, my.meta)
                endif
            endfor
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create module with Swift class from the abstract 'class' notion.
# ---------------------------------------------------------------------------
function swift_create_class_module (class, destination, wrapper, meta)
    check_arguments (my, "class, destination, wrapper, meta", my)

    echo_info ("Create <swift_module/> from class: '$(my.class.name:)'", my)

    assert_attribute (my.class, "name", my)

    if string_in (my.class.name, "data, buffer")
        #   Do not generate classes that can be mapped to the built-in types.
        return
    endif

    new swift_module to my.destination
        .name = swift_derive_module_name (my.class)
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.wrapper.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.wrapper->license) ?
        endnew

        new swift_import to swift_module
            .framework = "Foundation"
        endnew

        new swift_import to swift_module
            .framework = my.wrapper.framework
        endnew

        new swift_class to swift_module
            . = swift_format_description (my.class) ?
            .name = swift_derive_class_name (my.class, my.wrapper)
            .objc_name = swift_derive_class_objc_name (swift_class, my.wrapper)
            .full_name = "$(my.wrapper.namespace:).$(0.name:)"

            swift_map_attr_visibility (swift_class, my.class)

            new swift_inherit to swift_class
                .type = "NSObject"
            endnew

            for my.class.method where method.declaration = "public"
                my.swift_method = swift_create_method_declaration (method, swift_class, my.wrapper, my.meta)

                if count (my.swift_method.swift_return) > 1
                    swift_create_result_class (\
                            swift_class, my.swift_method, swift_module, my.wrapper, my.meta)
                endif

                swift_implement_class_method (swift_class, my.swift_method, method, my.wrapper, my.meta)
            endfor
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create module with Swift enum from the abstract 'enum' notion.
# ---------------------------------------------------------------------------
function swift_create_enum_module (enum, destination, wrapper, meta)
    check_arguments (my, "enum, destination, wrapper, meta", my)

    echo_info ("Create <swift_module/> from enum: '$(my.enum.name:)'", my)

    assert_attribute (my.enum, "name", my)

    new swift_module to my.destination
        .name = swift_derive_module_name (my.enum)
        .source_file_name = 0.name + ".swift"
        .source_file_path = cat_path (my.wrapper.source_dir, 0.source_file_name)

        new swift_license to swift_module
            . = swift_format_license (my.wrapper->license) ?
        endnew

        new swift_import to swift_module
            .framework = "Foundation"
        endnew

        new swift_import to swift_module
            .framework = my.wrapper.framework
        endnew

        new swift_enum to swift_module
            . = swift_format_description (my.enum) ?
            .name = swift_derive_enum_name (my.enum, my.wrapper)
            .objc_name = swift_derive_enum_objc_name (swift_enum, my.wrapper)
            .full_name = "$(my.wrapper.namespace:).$(0.name:)"

            swift_map_attr_visibility (swift_enum, my.enum)
            swift_map_attr_scope (swift_enum, my.enum)

            new swift_inherit to swift_enum
                .type = "Int"
            endnew

            if my.enum.name = "error"
                swift_map_enum_error (swift_enum, my.enum, my.wrapper, my.meta)
            else
                swift_map_enum_default (swift_enum, my.enum, my.wrapper, my.meta)
            endif

            swift_create_enum_constructor (swift_enum, my.enum, my.wrapper, my.meta)
        endnew
    endnew

    echo_debug ("Done", my)
endfunction

.endtemplate

.template 0
#   Copyright (C) 2015-2019 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Contains API for PHP wrapper generation.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"
gsl from "interface.gsl"
gsl from "component.gsl"
gsl from "c_component.gsl"
gsl from "php_codegen.gsl"

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_create_toplevel_modules(wrapper) #[optional]
    check_arguments (my, "wrapper", my)
    #TODO
endfunction

function php_resolve_toplevel (wrapper, license) #[optional]
endfunction

function php_resolve_project (project, wrapper, projects_api)
    ### ?
endfunction

function php_create_project_module (project, wrapper)
    check_arguments (my, "project, wrapper", my)

    assert_attribute (my.wrapper, "lang", my)
    assert_attributes (my.project, "name, prefix, framework", my)
    assert_item (my.project, "license", my)

    echo_info ("Create PHP project for project: '$(my.project.name:)'", my)

    new php_project to my.wrapper
        . = my.project. ?
        .name = my.project.name
        .description = my.project.brief
        .prefix = my.project.prefix
        .framework = my.project.framework
        .namespace = "$(my.project.namespace:c)"
        .namespace_dir = my.project.name
        .source_dir = cat_path ("$(my.wrapper.main_package_dir:)", php_project.namespace_dir)

        copy my.project->license to php_project

        new php_uid to php_project
            .name = php_project.namespace
            .uid = "php_framework_name"
        endnew

        if directory.create (php_project.source_dir) = -1
            echo_fatal ("Can not create directory: $(.source_dir:). ", my)
        endif

        return php_project
    endnew
endfunction

function php_create_custom_modules (source, php_project, meta)
    check_arguments (my, "source, php_project, meta", my)

    if directory.create (my.php_project.source_dir) = -1
        echo_fatal ("Can not create directory: $(.source_dir_path:). ", my)
    endif

    new json_module to my.php_project
        .name = "composer"
        .source_file_name = 0.name + ".json"
        .source_file_path = cat_path(my.php_project.source_dir, 0.source_file_name)
        new code to json_module
            .= "\
            {
                \"name\": \"virgil/crypto-$(my.php_project.name:)\",
                \"description\": \"$(my.php_project.description:)\",
                \"keywords\": [],
                \"homepage\": \"https://virgilsecurity.com\",
                \"license\": \"BSD-3-Clause\",
                \"authors\": [
                    {
                        \"name\": \"Virgil Security, Inc\",
                        \"email\": \"support@virgilsecurity.com\",
                        \"homepage\": \"https://virgilsecurity.com\"
                    }
                ],
                \"require\": {
                    \"php\": \"^7.2\"
                },
                \"autoload\": {
                    \"psr-4\": {
                        \"Virgil\\\\Crypto-$(my.php_project.name:Pascal)\\\\\": \"sources\"
                    }
                },
                \"scripts\": {
                    \"setup-extension\": [
                    ]
                }
            }
            "
        endnew
    endnew
endfunction

function php_create_interface_module (source, destination, wrapper, meta)
endfunction

function php_create_implementation_module (source, destination, wrapper, meta)
endfunction

# ---------------------------------------------------------------------------
#   Create module with PHP class from the abstract 'class' notion.
# ---------------------------------------------------------------------------
function php_create_class_module (class, php_project, meta)
    check_arguments (my, "class, php_project, meta", my)

    echo_info ("Create <php_module/> from class: '$(my.class.name:)'", my)
    
    assert_attribute (my.class, "name", my)

    # Skipping all classes with not public scope
    if my.class.scope <> "public"
        return
    endif

    new php_module to my.php_project
        .name = php_derive_module_name (my.class, my.php_project, "Pascal")
        .source_file_name = 0.name + ".php"
        .source_file_path = cat_path (my.php_project.source_dir, 0.source_file_name)

        new php_license to php_module
            . = php_format_license (my.php_project->license) ?
        endnew

        new php_class to php_module
            . = php_format_description (my.class) ?
            .name = php_derive_class_name (my.class, my.php_project)
            .low_level_name_c_format = php_derive_class_low_level_name_c_formated (my.class, my.php_project)
            
            php_create_class_default_constructor (php_class, my.class, my.php_project, my.meta)
            
            php_create_class_default_destructor (php_class, my.class, my.php_project, my.meta)
            
            for my.class.method where method.declaration = "public" & method.scope ?= "public"
                php_create_class_method (my.class, method, php_class, my.php_project, my.meta)
            endfor

        endnew
        
    endnew
    echo_debug ("Done", my)
endfunction

# ---------------------------------------------------------------------------
#   Create default <php_constructor/> that initialize underlying C context.
# ---------------------------------------------------------------------------
function php_create_class_default_constructor (php_class, class, php_project, meta)
    check_arguments (my, "php_class, class, php_project, meta", my)

    new php_constructor to my.php_class
        
        . = "Create underlying C context.\n"
        . += "@return void"
        . = php_format_description (php_constructor)

        new php_code to php_constructor
                my.constructor_body = format_left ("$this->ctx = $(my.php_class.low_level_name_c_format:c)_new_php();")
            . = my.constructor_body
        endnew
    endnew
endfunction

function php_create_enum_module (source, destination, wrapper, meta)
endfunction

function php_finalize_custom_modules (source, destination, wrapper, meta) #[optional]
endfunction

# ===========================================================================
#   Component resolution.
# ===========================================================================

# ---------------------------------------------------------------------------
#   Resolve UIDs for given component and all inner components.
# ---------------------------------------------------------------------------
function php_module_resolve_uids (php_component, parent_uid)
    check_arguments (my, "php_component", my)

    if defined (my.parent_uid) & string.prefixed (my.parent_uid, "php_module")
        my.parent_uid = # Undefined
    endif

    my.component_name = name (my.php_component)
    if  defined (my.parent_uid) & string.prefixed (my.component_name, "php_")
        regexp.match ("php_(.+)", my.component_name, my.component_name)
    endif

    my.php_component.uid = make_id (my.parent_uid, my.component_name, my.php_component.name)

    for my.php_component. as inner_component where is_item (inner_component) & defined (inner_component.name)
        php_module_resolve_uids (inner_component, my.php_component.uid)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add auto-resolving attributes:
#       - uid.
# ---------------------------------------------------------------------------
function php_module_resolve (php_module, php_project)
    check_arguments (my, "php_module, php_project", my)

    echo_trace ("Resolving <$(name (my.php_module)) name=\"$(my.php_module.name:)\"/>", my)

    assert_attribute (my.php_module, "name", my)

    #   Resolve UIDs
    php_module_resolve_uids (my.php_module)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted module name.
# ---------------------------------------------------------------------------
function php_derive_module_name (type, php_project, ppm)
    check_arguments (my, "type, php_project, ppm", my)

    assert_attribute (my.type, "name", my)

    if ! string_in(my.ppm, "c, UPPER, Pascal, Camel")
        echo_fatal("Undefined ppm: $(my.ppm:)", my)
    endif

    return "$(my.type.name:$(my.ppm))"
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the PHP class.
# ---------------------------------------------------------------------------
function php_derive_class_name (class, php_project)
    check_arguments (my, "class, php_project", my)

    assert_attribute_one_of (my.class, "name", my)

    return php_derive_class_name_str (my.class.name, my.php_project)
endfunction

# ---------------------------------------------------------------------------
#   Return formatted name of the PHP class.
# ---------------------------------------------------------------------------
function php_derive_class_name_str (name, php_project)
    check_arguments (my, "name, php_project", my)

    return "$(my.name:Pascal)"
endfunction

# ---------------------------------------------------------------------------
#   Return C formatted low level name of the PHP class.
# ---------------------------------------------------------------------------
function php_derive_class_low_level_name_c_formated (class, php_project)
    check_arguments (my, "class, php_project", my)

    assert_attribute_one_of (my.class, "name", my)

    return "$(my.php_project.prefix:c)_$(my.class.name:c)"
endfunction

# ---------------------------------------------------------------------------
# Create default <php_destructor/> that destroy underlying C context.
# ---------------------------------------------------------------------------

function php_create_class_default_destructor (php_class, class, php_project, meta)
    check_arguments (my, "php_class, class, php_project, meta", my)

    new php_destructor to my.php_class
        . = "Destroy underlying C context.\n"
        . += "@return void"
        . = php_format_description (php_destructor)

        new php_code to php_destructor
            my.destructor_body = "$(my.php_class.low_level_name_c_format:c)_delete_php($this->ctx);"
            . = my.destructor_body
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create entity <php_method/> of from the class entity <method/>.
# ---------------------------------------------------------------------------
function php_create_class_method (class, method, destination, php_project, meta)
    check_arguments (my, "class, method, destination, php_project, meta", my)

    new php_method to my.destination

        #COMMON
        my.count_in = 1 # ctx
        my.count_out = 0
        my.return_data = ""

        for my.method.argument            
            if string_in (argument.class, "buffer")
                my.return_data += php_derive_argument_name(argument, "-l")
                my.count_out = my.count_out + 1

                if ! last()
                    my.return_data += ", "
                endif
            else 
                my.count_in = my.count_in + 1
            endif
        endfor

        my.res_type = ""
        my.res_data = ""

        if my.count_out = 0
            my.res_data = ""
            my.res_type = "void"
        elsif my.count_out = 1
            my.res_data = "// $(my.return_data:)"
            # TODO! NEED TO BE CHECKED WITH OTHER TYPES
            my.res_type = "string"
        elsif my.count_out > 1
            my.res_data = "// [$(my.return_data:)]"
            my.res_type = "array"
        endif

        my.return_enum_status = count (my.method.return, string_equal (return.enum, "status"))
        my.extension_return_type = php_derive_extension_return_type(my.res_type) 

        # HIGH_LEVEL
        new high_level to php_method
            my.docblock_data = ""

            if defined (my.method.)
                my.docblock_data += my.method.
            endif

            my.function_name = class_derive_c_method (my.class, my.method)

            .name = php_derive_method_name (my.method, "-h")
            .function_name = php_derive_function_name(my.function_name, "-h")
            .return_data = my.res_data
            .return_type = my.res_type

            .throws_exception = my.return_enum_status

            for my.method.argument where defined (argument.class) & argument.class <> "buffer"
                new php_argument to high_level
                    .name = php_derive_argument_name (argument, "-h")
                    php_map_argument_type (argument, "-h", php_argument)
                    my.docblock_data += "@param $(0.type:) $(0.name:)\n"
                endnew
            endfor

            if my.return_enum_status = 1
                my.docblock_data += "@throws Exception\n"
            endif

            my.docblock_data += "@return $(my.res_type:)\n"

            new docblock to high_level
                . = php_format_docblock (my.docblock_data) ?
            endnew

            new php_code to high_level
                my.method_body = ""
                my.method_argument = ""
                my.extension_function = high_level.function_name
                my.is_void = string_in(php_method.return_type, "void")
                my.ctx = "$this->ctx"

                for high_level.php_argument where defined (php_argument.name)
                    if first()
                        my.method_argument += ", "
                    endif

                    my.method_argument += "$(php_argument.name:)"

                    if ! last()
                        my.method_argument += ", "
                    endif
                endfor

                my.return = ""

                if is_false (my.is_void)
                    my.return = "return "
                endif

                my.method_body += "$(my.return:)$(my.extension_function:)($(my.ctx:)$(my.method_argument:));"

                . = my.method_body
            endnew
        endnew

        # LOW_LEVEL
        new low_level to php_method

            my.function_name = class_derive_c_method (my.class, my.method)

            .module_name = php_derive_module_name (my.class, my.php_project, "c")
            .function_name = php_derive_function_name (my.function_name, "-l")
            .required_num_args = my.count_in
            .throws_exception = my.return_enum_status
            .return_type = my.extension_return_type

            for my.method.argument where defined (argument.class)
                new extension_argument to low_level
                    .name = php_derive_argument_name (argument, "-l")
                    php_map_argument_type (argument, "-l", extension_argument)

                    if defined (argument->length)
                        php_map_extension_argument_len(argument, extension_argument)
                    endif
                endnew
            endfor

            new extension_code to low_level
                if defined (low_level)
                    new zend_header to extension_code
                        . = php_format_extension_zend_header (low_level)
                    endnew

                    new php_function to extension_code
                        . = php_format_extension_php_function (low_level)
                    endnew

                    new declaration_input to extension_code
                        . = php_format_extension_declare_input (low_level)
                    endnew
                    new parse_arguments to extension_code
                        . = php_format_extension_parse_arguments (low_level)
                    endnew
                    new proxy_call to extension_code
                        . = php_format_extension_proxy_call (low_level)
                    endnew
                    new allocate_output_buffer to extension_code
                        . = php_format_extension_allocate_output_buffer (low_level)
                    endnew
                    new status to extension_code
                        . = php_format_extension_status (low_level)
                    endnew
                    new output to extension_code
                        . = php_format_extension_output (low_level)
                    endnew
                endif
            endnew
        endnew
    endnew

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_argument_type (argument, type, destination)
    check_arguments (my, "argument, type, destination", my)
    assert_attribute (my.argument, "class", my)

    php_type_checker(my.type)

    if my.type = "-h"
        if my.argument.class = "data"
            my.destination.type = "string"
        else
            echo_fatal("Undefined argument type for the class: $(my.argument.class)")
        endif
    elsif my.type = "-l"
        if my.argument.class = "data"
            my.destination.type = "vsc_data_t"
            my.destination.zend_type = "IS_STRING"
        elsif my.argument.class = "buffer"
            my.destination.type = "vsc_buffer_t"
        else
            echo_fatal("Undefined argument class type: $(my.argument.class)", my)
        endif
    endif

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_extension_argument_len (argument, destination)
    check_arguments (my, "argument, destination", my)

    if ! defined (my.argument->length)
        echo_fatal("Undefined argument length for argument: $(my.argument.name)", my)
    endif

    if defined (my.argument->length.method)
        my.destination.len_type = "method"
        my.destination.len_data = "$(my.argument->length.method:c)"
    elsif defined (my.argument->length.constant)
        my.destination.len_type = "constant"
        my.destination.len_data = php_derive_constant_formatted_string("$(my.argument->length.constant:)")
    else 
        echo_fatal("Undefined method argument length type for the argument: $(my.argument.name)", my)
    endif
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_derive_extension_return_type (type)
    check_arguments (my, "type", my)

    my.res = ""

    if my.type = "void"
        my.res = "IS_VOID"
    elsif my.type = "string"
        my.res = "IS_STRING"
    elsif my.type = "array"
        my.res = "IS_ARRAY"
    elsif my.type = "res"
        my.res = "IS_RESOURCE"
    else
        echo_fatal("Undefined type: $(my.type)", my)
    endif

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_derive_method_name (method, type)
    check_arguments (my, "method, type", my)

    php_type_checker(my.type)

    if my.type = "-h"
        my.res = "$(my.method.name:Camel)"
    elsif my.type = "-l"
        my.res = "$(my.method.name:c)"
    endif

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_derive_function_name (function, type)
    check_arguments (my, "function, type", my)

    php_type_checker(my.type)

    if my.type = "-h"
        my.res = "$(my.function:)_php"
    elsif my.type = "-l"
        my.res = "$(my.function:)"
    endif

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_derive_argument_name (argument, type)
    check_arguments (my, "argument, type", my)
    assert_attribute (my.argument, "name", my)

    php_type_checker(my.type)

    if my.type = "-h"
        my.res = "$$(my.argument.name:Camel)"
    elsif my.type = "-l"
        my.res = "$(my.argument.name:c)"
    endif

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_type_checker (type)
    check_arguments (my, "type", my)

    if ! string_in(my.type, "-h, -l")
        echo_fatal("Invalid type: $(my.type:)", my)
    endif

    return
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_derive_constant_formatted_string (string)
    check_arguments (my, "string", my)

    my.res = "$(my.string:c)"
    my.res = "$(my.res:UPPER)"

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_derive_extension_zend_function_arginfo (function_name)
    check_arguments (my, "function_name", my)

    my.res = "arginfo_$(my.function_name:)_php"

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_derive_extension_zend_function_input_name (arg, type)
    check_arguments (my, "arg, type", my)

    if ! string_in(my.type, "-c, -l")
        echo_fatal("Invalid type: $(my.type:)", my)
    endif

    if my.type = "-c"
        my.res = "in_$(my.arg.name:)"
    elsif my.type = "-l"
        my.res = "in_$(my.arg.name:)_len"
    endif

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_derive_extension_zend_function_output_name (arg, type)
    check_arguments (my, "arg, type", my)

    if ! string_in(my.type, "-o, -n")
        echo_fatal("Invalid type: $(my.type:)", my)
    endif

    if my.type = "-o"
        my.res = "out_$(my.arg.name:)"
    elsif my.type = "-n"
        my.res = "new_$(my.arg.name:)"
    endif

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_format_extension_wrap_method (low_level)
    check_arguments (my, "low_level", my)

    my.res = ""
    
    my.res += php_format_extension_zend_body (low_level)
    
    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_format_extension_zend_header (low_level)
    check_arguments (my, "low_level", my)

    my.arginfo = php_derive_extension_zend_function_arginfo(my.low_level.function_name)

    my.arg_type_info = "ZEND_ARG_INFO(0, ctx)\n"

    for my.low_level.extension_argument as extension_argument
        my.term = ""
        if ! last()
            my.term = "\n"
        endif

        if defined (extension_argument.zend_type)
            my.arg_type_info += "ZEND_ARG_TYPE_INFO(0, $(extension_argument.name:), $(extension_argument.zend_type), 0)$(my.term:)"
        endif
    endfor

    my.res = "\
//
//  Wrap method: $(my.low_level.function_name)
//
ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX($(my.arginfo:), 0, $(my.low_level.required_num_args:), $(my.low_level.return_type:UPPER), 0)
$(my.arg_type_info:)
ZEND_END_ARG_INFO()
    "

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_format_extension_php_function (low_level)
    check_arguments (my, "low_level", my)

    my.res = "PHP_FUNCTION($(my.low_level.function_name:))"

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_format_extension_status (low_level)
    check_arguments (my, "low_level", my)

    my.status = "vsce_status_t status = $(my.low_level.function_name:)($(my.low_level.module_name:), "

    for my.low_level.extension_argument as extension_argument
        my.status += "$(extension_argument.name:)"

        if ! last()
            my.status += ", "
        endif
    endfor

    my.status += ");"
    my.status += "\n
//
//  Handle error
//
VSCE_HANDLE_STATUS(status);
    "
    my.res = my.status

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_format_extension_output (low_level)
    check_arguments (my, "low_level", my)

    if my.low_level.return_type = "IS_STRING"
        my.c = 0
        for my.low_level.extension_argument
            if extension_argument.type = "vsc_buffer_t"
                my.c = my.c + 1
                my.out_arg = php_derive_extension_zend_function_output_name(extension_argument, "-o")
                my.arg = extension_argument.name
            endif
        endfor

        if my.c > 1
            echo_fatal("Invalid amount of the output string arguments", my)
        endif

        my.res = "\
//
//  Correct string length to the actual
//
ZSTR_LEN($(my.out_arg:)) = vsc_buffer_len($(my.arg));

//
//  Write returned result
//
RETVAL_STR($(my.out_arg));

goto success;

fail:
    zend_string_free($(my.out_arg));
success:
    vsc_buffer_destroy(&$(my.arg));
}
        "
    elsif my.low_level.return_type = "IS_VOID"
        my.res = "RETURN_TRUE;"

    elsif my.low_level.return_type = "IS_ARRAY"
    my.zstr_len = ""
    my.add_next_index_str = ""
    my.zend_string_free = ""
    my.vsc_buffer_destroy = ""

    for my.low_level.extension_argument
        if extension_argument.type = "vsc_buffer_t"

            my.term = ""
            if ! last()
                my.term = "\n"
            endif

            my.out_arg = php_derive_extension_zend_function_output_name(extension_argument, "-o")
            my.arg = extension_argument.name

            my.zstr_len += "ZSTR_LEN($(my.out_arg:)) = vsc_buffer_len($(my.arg:));\n"
            my.add_next_index_str += "add_next_index_str(return_value, $(my.out_arg:));\n"
            my.zend_string_free += "zend_string_free($(my.out_arg:));\n"
            my.vsc_buffer_destroy += "vsc_buffer_destroy(&$(my.arg:));$(my.term:)"
        endif
    endfor

        my.res = "\
    //
    //  Correct string length to the actual
    //
    $(my.zstr_len:)

    //
    //  Write returned result
    //
    array_init(return_value);
    $(my.add_next_index_str:)

    goto success;

fail:
    $(my.zend_string_free:)
success:
    $(my.vsc_buffer_destroy:)
}
        "
    else 
        echo_fatal("Not implemented return type: $(my.low_level.return_type:)", my)
    endif

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_format_extension_declare_input (low_level)
    check_arguments (my, "low_level", my)

    my.res = "\
//
// Declare input arguments
//
zval *in_ctx = NULL;
    "

    for my.low_level.extension_argument as extension_argument
        if extension_argument.type <> "vsc_buffer_t"
            my.char = php_derive_extension_zend_function_input_name(extension_argument, "-c")
            my.size = php_derive_extension_zend_function_input_name(extension_argument, "-l")
            my.res += "\
char *$(my.char:) = NULL;
size_t $(my.size:) = 0;
            "
        endif
    endfor

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_format_extension_parse_arguments (low_level)
check_arguments (my, "low_level", my)

    my.parse_arguments = "Z_PARAM_RESOURCE_EX(in_ctx, 1, 0)\n"
    my.c = 1 # ctx

    for my.low_level.extension_argument as extension_argument

        if extension_argument.type <> "vsc_buffer_t"
            my.char = php_derive_extension_zend_function_input_name(extension_argument, "-c")
            my.size = php_derive_extension_zend_function_input_name(extension_argument, "-l")
            my.c = my.c + 1

            my.term = ""
            if ! last()
                my.term = "\n"
            endif

            my.parse_arguments += "Z_PARAM_STRING_EX($(my.char:), $(my.size:), 1, 0)$(my.term:)"
        endif
    endfor

    my.res = "\
//
//  Parse arguments
//
ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, $(my.c:), $(my.c:))
$(my.parse_arguments:)
ZEND_PARSE_PARAMETERS_END();
    "

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_format_extension_proxy_call (low_level)
    check_arguments (my, "low_level", my)

    my.proxy_call = ""

    for my.low_level.extension_argument as extension_argument
        if extension_argument.type <> "vsc_buffer_t"
            my.char = php_derive_extension_zend_function_input_name(extension_argument, "-c")
            my.size = php_derive_extension_zend_function_input_name(extension_argument, "-l")
            my.term = ""
            if ! last()
                my.term = "\n"
            endif
            my.proxy_call += "$(extension_argument.type:) $(extension_argument.name) = vsc_data((const byte*)$(my.char:), $(my.size:));$(my.term:)"
        endif
    endfor

    my.res = "
//
// Proxy call
//
vsce_phe_client_t *phe_client = zend_fetch_resource_ex(in_ctx, VSCE_PHE_CLIENT_PHP_RES_NAME, le_vsce_phe_client);
VSCE_ASSERT_PTR($(my.low_level.module_name:));
$(my.proxy_call:)
    "

    return my.res
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_format_extension_allocate_output_buffer (low_level)
    check_arguments (my, "low_level", my)

    my.allocate_output_buffer = ""

    for my.low_level.extension_argument as extension_argument

        if extension_argument.type = "vsc_buffer_t"
            my.out = php_derive_extension_zend_function_output_name (extension_argument, "-o")
            if extension_argument.len_type = "method"
                #TODO Add prefix!
                my.zend_string_alloc = "$(extension_argument.len_data:)($(my.low_level.module_name:))"
            elsif extension_argument.len_type = "constant"
                #TODO Add prefix!
                my.zend_string_alloc = "$(extension_argument.len_data:)"
            else
                #TODO
                echo_fatal("Not implemented!", my)
            endif

            my.allocate_output_buffer += "\
            //  Allocate output buffer for output '$(extension_argument.name:)'
            zend_string *$(my.out:) = zend_string_alloc($(my.zend_string_alloc:), 0);
            vsc_buffer_t *$(extension_argument.name:) = vsc_buffer_new();
            vsc_buffer_use($(extension_argument.name:), (byte *)ZSTR_VAL($(my.out:)), ZSTR_LEN($(my.out:)));
            "
        endif
    endfor

    my.res = "\
        $(my.allocate_output_buffer:)
    "

    return my.res
endfunction
.endtemplate

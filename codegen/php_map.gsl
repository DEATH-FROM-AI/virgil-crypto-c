.template 0
#   Copyright (C) 2015-2019 Virgil Security, Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Functions for PHP primitives generation: protocol, class, enum, etc.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_high_level (in_module, in_php_project, out_high_level, in_type)
    check_arguments (my, "in_module, in_php_project, out_high_level, in_type", my)

    if ! string_empty(my.in_module.)
        my.out_high_level. = php_format_comment (my.in_module.)
    endif

    my.out_high_level.name = "$(my.in_module.name:Pascal)"
    my.out_high_level.name0 = "$(my.in_module.name:c)"
    my.out_high_level.namespace = php_derive_high_level_namespace(my.in_php_project)

    new namespace to my.out_high_level
        . = format_left("namespace $(my.out_high_level.namespace:);", 0)
    endnew

    my._implements = ""

    my._type = "class"

    if my.in_type = "interface"
        my._type = "interface"
    endif

    if my.in_type <> "interface"
        new property to my.out_high_level
            my._db = php_format_comment("@var")
            my._property = "private $ctx;"

            my._res = format_left(my._db + "\n" + my._property, 0)

            . = my._res
        endnew
    endif

    my._interface_methods = XML.new()
    my._constant = ""


    for my.in_module.interface as interface0

        my._d = ""
        if ! last()
            my._d = ", "
        endif

        new interface to my.out_high_level
            .name = "$(interface0.name:Pascal)"
            my._name = interface.name

            for my.in_php_project.php_module as php_module0 where php_module0.name = my._name
                for php_module0->high_level.php_method as php_method0
                    copy php_method0 to my._interface_methods
                endfor
            endfor

            my._implements += my._name + my._d
        endnew

        for interface0.constant as constant0
            new constant to high_level
                .name = php_derive_high_level_constant_name(constant0)
                .value = constant0.value

                my._constant += format_left("const $(0.name:) = $(0.value:);", 0)
            endnew
        endfor
    endfor

    new constants to my.out_high_level
        . = format_left(my._constant, 0)
    endnew

    if my.in_type <> "interface"
        php_map_high_level_constructor_destructor (my.in_module, my.out_high_level)
    endif

    if my._implements <> ""
        my._implements = "implements $(my._implements:)"
    endif

    for my._interface_methods.php_method as php_method0

        php_method0.entity0 = "$(my.in_module.name:c)"
        php_method0.function_name = php_derive_high_level_function_name(0)

        new body to php_method0
            . = php_format_high_level_method_body(php_method0)
        endnew

        copy php_method0 to my.out_high_level
    endfor

    for my.in_module.method as method0 where method0.visibility = "public" & method0.declaration = "public" & method0.scope = "public"
        new php_method to my.out_high_level

            my._docblock_data = ""

            if defined (method0.)
                my._docblock_data += format_left(method0., 0) + "\n"
            endif

            php_map_high_level_method (method0, my.in_php_project, php_method)

            .prefix0 = "$(my.in_module.c_prefix:c)"
            .entity0 = "$(my.in_module.name:c)"
            if my.in_type = "interface"
                .function_name = ""
            else 
                .function_name = php_derive_high_level_function_name(0)
            endif
            my._method_arguments = ""
            my._function_arguments = ""

            for method0.argument as argument0 where defined (argument0.class) & argument0.class <> "error"

                my._d = ""
                if ! last()
                    my._d = ", "
                endif

                new php_argument to php_method
                    php_map_high_level_argument (argument0, my.in_php_project, php_argument)
                    my._docblock_data += format_left("@param $(0.type:) $(0.name:)\n", 0)
                    my._method_arguments += "$(0.type:) $(0.name:)" + my._d
                    my._function_arguments += "$(0.name:)" + my._d
                endnew
            endfor

            my._docblock_data += format_left("@return $(0.return_type:)\n", 0)

            if 0.throw_exception = 1
                my._docblock_data += format_left("@throws \\\\Exception", 0)
            endif

            new docblock to php_method
                . = php_format_comment(my._docblock_data)
            endnew

            my._declaration = 0.declaration
            my._name = 0.name
            my._return_type = 0.return_type
            my._return_data = 0.return_data
            my._function_name = 0.function_name

            new signature to php_method
                . = "$(my._declaration:) function $(my._name:)($(my._method_arguments:)): $(my._return_type:) $(my._return_data:)"
            endnew

            if my.in_type <> "interface"
                new body to php_method
                    . = php_format_high_level_method_body(php_method)
                endnew
            endif
        endnew
    endfor

    new signature to my.out_high_level
        . = format_left("$(my._type:) $(my.out_high_level.name:) $(my._implements:)", 0)
    endnew
endfunction

# ---------------------------------------------------------------------------
# 
# ---------------------------------------------------------------------------
function php_map_high_level_constructor_destructor (in_module, out_high_level)
    check_arguments (my, "in_module, out_high_level", my)

    new php_method to my.out_high_level
        .name = "__construct"
        .name0 = "new"
        .function_name = "TEMP_FUNCTION_NAME"
        .return_type = "void"
        .return_data = ""
        .throws_exception = "0"
        .declaration = "public"
        .prefix0 = "$(my.in_module.c_prefix:c)"
        .entity0 = "$(my.in_module.name:c)"
        .function_name = php_derive_high_level_function_name(0)

        new docblock to php_method
            my._docblock = format_left("\
            Create underlying C context.
            @return void
            ", 0)

            . = php_format_comment (my._docblock)
        endnew

        new signature to php_method
            . = "$(php_method.declaration:) function $(php_method.name:)()"
        endnew

        new body to php_method
            . = "$this->ctx = $(php_method.function_name:)();"
        endnew
    endnew

    new php_method to my.out_high_level
        .name = "__destructor"
        .name0 = "delete"
        .function_name = "TEMP_FUNCTION_NAME"
        .return_type = "void"
        .return_data = ""
        .throws_exception = "0"
        .declaration = "public"
        .prefix0 = "$(my.in_module.c_prefix:c)"
        .entity0 = "$(my.in_module.name:c)"
        .function_name = php_derive_high_level_function_name(0)

        new docblock to php_method
            my._docblock = format_left("\
            Destroy underlying C context.
            @return void
            ", 0)

            . = php_format_comment (my._docblock)
        endnew

        new signature to php_method
            . = "$(php_method.declaration:) function $(php_method.name:)()"
        endnew

        new body to php_method
            . = "$(php_method.function_name:)($this->ctx);"
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_high_level_method (in_method, in_php_project, out_php_method)
    check_arguments (my, "in_method, in_php_project, out_php_method", my)

    my.out_php_method.name = "$(my.in_method.name:Camel)"
    my.out_php_method.name0 = "$(my.in_method.name:c)"

    php_map_high_level_return (my.in_method, my.in_php_project, my.out_php_method)

    my._md = "public"

    if my.in_method.is_static="1"
        my._md = "static"
    endif

    my.out_php_method.declaration = my._md
endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_high_level_return (in_method, in_php_project, out_php_method)
    check_arguments (my, "in_method, in_php_project, out_php_method", my)

    my._return_type = "void"
    my._return_data = ""
    my._instance = 0
    my._namespace = ""
    my._throw_exception = 0
    my._return_data_list = ""

    my._argument_buffer_count = 0

    for my.in_method.argument as argument0 where defined (argument0.class)
        if argument0.class = "buffer"
            my._argument_buffer_count = my._argument_buffer_count + 1
            my._return_data_list += "$(argument0.name:c)"
            if ! last()
                my._return_data_list += ", "
            endif
        endif
    endfor

    if my._argument_buffer_count = 1
        my._return_type = "string"
    elsif my._argument_buffer_count > 1
        my._return_type = "array"
        my._return_data = "// [$(my._return_data_list)]"
    endif

    for my.in_method.return as return0

        if defined (return0.type)
            if return0.type = "size" | return0.type = "integer" | return0.type = "unsigned"
                my._return_type = "int"
            elsif return0.type = "boolean"
                my._return_type = "bool"
            elsif return0.type = "byte"
                my._return_type = "string"
            else
                # TODO
                echo_debug_item(my.in_method)
                echo_debug_item(return0)
                echo_fatal("Not implemented (101)", my)
            endif
        endif

        my._r = "sfdfsd"

        if defined (return0.class)
            if return0.class = "data"
                my._return_type = "string"
                my._return_data = ""
            else
                my._r = return0.class
                my._namespace = php_derive_high_level_namespace(my.in_php_project)
                my._instance = 1
            endif
        elsif defined (return0.interface)
            my._r = return0.interface
            my._namespace = php_derive_high_level_namespace(my.in_php_project)
            my._instance = 1
        endif

        if (defined (return0.class) & return0.class <> "data") | defined (return0.interface)
            my._return_type = "$(my._r:Pascal)"
        endif

        if defined (return0.enum)
            if return0.enum = "status"
                my._throw_exception = 1
            else
                # TODO
                echo_debug_item(my.in_method)
                echo_debug_item(return0)
                echo_warning("Not implemented (102)", my)
            endif
        endif
    endfor

    my.out_php_method.return_type = my._return_type
    my.out_php_method.return_data = my._return_data
    my.out_php_method.instance = my._instance
    my.out_php_method.namespace = my._namespace
    my.out_php_method.throw_exception = my._throw_exception

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_high_level_argument (in_argument, in_php_project, out_php_argument)
    check_arguments (my, "in_argument, in_php_project, out_php_argument", my)

    my.out_php_argument.name = "$$(my.in_argument.name:Camel)"

    my._type = ""
    my._instance = 0
    my._namespace = ""

    if defined (my.in_argument.class) & my.in_argument.class <> "error"
        if string_in(my.in_argument.class, "data, buffer") 
            my._type = "string"
        else
            my._type = "$(my.in_argument.class:Pascal)"
            my._instance = 1
            my._namespace = php_derive_high_level_namespace(my.in_php_project)
        endif
    endif

    if defined (my.in_argument.interface)
        my._type = "$(my.in_argument.interface:Pascal)"
        my._instance = 1
        my._namespace = php_derive_high_level_namespace(my.in_php_project)
    endif

    if defined (my.in_argument.type)
        if string_in(my.in_argument.type, "size, integer, unsigned")
            my._type = "int"
        elsif my.in_argument.type = "byte"
            my._type = "string"
        elsif my.in_argument.type = "boolean"
            my._type = "bool"
        else
            # TODO
            echo_debug_item(my.in_argument)
            echo_fatal("Not implemented (301)", my)
        endif
    endif

    my.out_php_argument.type = my._type
    my.out_php_argument.instance = my._instance
    my.out_php_argument.namespace = my._namespace

endfunction

# ---------------------------------------------------------------------------
#   
# ---------------------------------------------------------------------------
function php_map_high_level_enum (in_module, in_php_project, out_high_level)
    check_arguments (my, "in_module, in_php_project, out_high_level", my)

    if ! string_empty(my.in_module.)
        my.out_high_level. = php_format_comment (my.in_module.)
    endif

    my.out_high_level.name = "$(my.in_module.name:Pascal)"
    my.out_high_level.name0 = "$(my.in_module.name:c)"
    my.out_high_level.namespace = php_derive_high_level_namespace(my.in_php_project)

    new namespace to my.out_high_level
        . = format_left("namespace $(my.out_high_level.namespace:);", 0)
    endnew

    new constants to my.out_high_level
        . = format_left("const TEMP_KEY = TEMP_VALUE;", 0)
    endnew

    new signature to my.out_high_level
        . = format_left("class TEMP extends Enum")
    endnew

    new use to my.out_high_level
        . = "use TEMP;"
    endnew

    new body to my.out_high_level
    endnew

.endfunction
.endtemplate

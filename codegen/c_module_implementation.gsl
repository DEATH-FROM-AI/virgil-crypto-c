.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Create 3 modules with 'Implementation API'.
#   For details see functions description:
#       - c_module_implementation_create_module_public ()
#       - c_module_implementation_create_module_impl ()
#       - c_module_implementation_create_module_internal ()
#
#   Private function prefix is: Z19.
# ---------------------------------------------------------------------------
#   This is a code generator helper built using the iMatix GSL code
#   generation language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------


gsl from "common.gsl"
gsl from "c_module_interface_api.gsl"

# ---------------------------------------------------------------------------
function _Z19_has_methods_with_context_impl (impl)
    check_argument (my, "impl", my)

    for my.impl.interface
        for interface.method where context = "impl"
            return 1
        endfor
    endfor

    return 0
endfunction


# ---------------------------------------------------------------------------
#   Add instance of 'Interface API' class.
#   Instance is fulfilled with implementation constants, methods,
#   and dependencies.
# ---------------------------------------------------------------------------
function _Z19_add_instance_interface_api (impl, interface_api, destination, meta)
    check_arguments (my, "impl, interface_api, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new variable to my.destination
        . = "Configuration of the interface API '$(my.interface_api.name:)'."
        .name = my.interface_api.name
        .class = ref (make_id ("class", my.interface_api.name, "struct", my.interface_api.name))
        .declaration = "private"
        .definition = "private"
        .is_reference = "0"

        for my.interface_api.property
            my.value = item_copy_to (property, variable, "value")

            scope my.value
                if property.tag = "tag"
                    .value = property.value #   Actually this attribute already there

                elsif property.tag = "api"
                    .value = my.refs.implementation_variable_$(make_id (property.name))

                elsif property.tag = "method"
                    .value = my.refs.implementation_method_$(make_id (property.name))
                    item_copy_to (property, value, "cast")

                elsif property.tag = "constant"
                    .value = my.refs.implementation_constant_$(make_id (property.name))

                else
                    my.property_dump = my.property_dump = component_dump_instance (property)
                    echo_fatal ("Can not handle attribute 'tag' of the property $(my.property_dump:).")
                endif
            endscope
        endfor

    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add instance that is array of the implemented 'Interface API' instances.
# ---------------------------------------------------------------------------
function _Z19_add_instance_array_of_interface_api (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new variable to my.destination
        . = "Null-terminated array of the implemented 'Interface API' instances."
        .name = my.names.implementation_variable_api_array
        .class = my.refs.class_api_struct_api
        .declaration = "private"
        .definition = "private"

        new array to variable
            .length = "derived"
            .access = "readonly"
        endnew

        for my.impl.interface
            new value to variable
                .value = my.refs.implementation_variable_$(make_id (interface.name))_api

                new cast to value
                    .class = my.refs.class_api_struct_api
                    .access = "readonly"
                endnew
            endnew
        endfor

        new value to variable
            .value = "NULL"
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add instance of the 'Implementation Info' class.
# ---------------------------------------------------------------------------
function _Z19_add_instance_impl_info (impl, impl_info, destination, meta)
    check_arguments (my, "impl, impl_info, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new variable to my.destination
        . = "Compile-time known information about '$(my.impl.name:)' implementation."
        .name = my.names.implementation_variable_info
        .class = my.refs.class_impl_struct_info
        .declaration = "private"
        .definition = "private"
        .is_reference = "0"

        for my.impl_info.property
            my.value = item_copy_to (property, variable, "value")
            scope my.value
                if property.tag = "tag"
                    .value = my.refs.implementation_constant_tag

                elsif property.tag = "api_array"
                    .value = my.refs.implementation_variable_api_array

                elsif property.tag = "self_cleanup"
                    .value = my.refs.implementation_method_cleanup
                    item_copy_to (property, value, "cast")

                elsif property.tag = "self_destroy"
                    .value = my.refs.implementation_method_destroy
                    item_copy_to (property, value, "cast")

                else
                    my.property_dump = component_dump_instance (property)
                    echo_fatal ("Unsupported impl info property: $(my.property_dump:).", my)
                endif
            endscope
        endfor
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add require includes to the implementation public module.
# ---------------------------------------------------------------------------
function _Z19_add_includes_for_module_public (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)

    new require to my.destination
        .module = my.names.module_library
    endnew

    new require to my.destination
        .module = my.names.module_assert
        .scope = "private"
    endnew

    for my.impl.require where type = "api" as interface_api
        new require to my.destination
            .module = interface_api.name
        endnew
    endfor

    if count (my.impl.require, type = "interface") | _Z19_has_methods_with_context_impl (my.impl)
        new require to my.destination
            .module = my.names.module_impl
        endnew
    endif

    if _Z19_has_methods_with_context_impl (my.impl)
        new require to my.destination
            .module = my.names.implementation_module_impl
            .scope = "private"
        endnew

        new require to my.destination
            .module = my.names.implementation_module_internal
            .scope = "private"
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Add require includes to the implementation public module.
# ---------------------------------------------------------------------------
function _Z19_add_includes_for_module_internal (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)

    new require to my.destination
        .module = my.names.module_library
    endnew

    new require to my.destination
        .module = my.names.module_memory
        .scope = "private"
    endnew

    new require to my.destination
        .module = my.names.module_assert
        .scope = "private"
    endnew

    new require to my.destination
        .module = my.names.implementation_module
        .scope = "private"
    endnew

    if _Z19_has_methods_with_context_impl (my.impl)
        new require to my.destination
            .module = my.names.implementation_module_impl
            .scope = "public"
        endnew
    endif

    for my.impl.interface
        new require to my.destination
            .module = cat (interface.name, my.names.module_api)
            .scope = "private"
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
function _Z19_add_argument_impl (destination, meta, access)
    check_arguments (my, "destination, meta", my)

    my.access ?= "readwrite"

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    my.argument = item_prepend_new ("argument", my.destination)

    scope my.argument
        .name = my.names.implementation_struct_impl
        .class = my.refs.implementation_struct_impl
        .access = my.access
    endscope
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_return_impl (destination, meta)
    check_arguments (my, "destination, meta", my)

    my.refs = meta_refs (my.meta)

    new return to my.destination
        .class = my.refs.implementation_struct_impl
        .access = "disown"
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_define_dependency_argument (argument, require, meta)
    check_arguments (my, "argument, require, meta", my)

    my.refs = meta_refs (my.meta)

    my.argument.name = my.require.name
    if my.require.type = "interface"
        my.argument.class = my.refs.class_impl_struct_impl
        my.argument.access = "readwrite"
    elsif require.type = "api"
        my.argument.class = ".($(make_id ("class", require.name, "struct", require.name)))"
        my.argument.access = "readonly"
    endif
endfunction

# ---------------------------------------------------------------------------
function _Z19_add_self_tag (implementation, enum, meta)
    check_arguments (my, "implementation, enum, meta", my)

    my.names = meta_names (my.meta)

    my.insertion_position = my.enum->constant (name = my.names.enum_constant_end) ?
    if ! defined (my.insertion_position)
        echo_fatal ("Enum '$(my.enum.name:)' does not contain value '$(my.names.enum_constant_end:)'.", my)
    endif

    new constant before my.insertion_position
        .name = my.implementation.name
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add type that handles implementation details.
# ---------------------------------------------------------------------------
function _Z19_add_type_impl (impl, definition, destination, meta)
    check_arguments (my, "impl, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new struct to my.destination
        . = "Handles implementation details."
        .name = my.names.class_impl
        .definition = my.definition

        new property to struct
            . = "Compile-time known information about this implementation."
            .name = my.names.property_info
            .class = my.refs.class_impl_struct_info
        endnew

        for my.impl.require where type = "interface"
            new property to struct
                . = "Dependency to the interface '$(require.name:)'."
                .name = my.names.implementation_property_dependency_$(make_id (require.name))
                .class = my.refs.class_impl_struct_impl
                .access = "readwrite"
            endnew
        endfor

        for my.impl.require where type = "api"
            new property to struct
                . = "Dependency to the interface api '$(require.name:)'."
                .name = my.names.implementation_property_dependency_$(make_id (require.name))
                .class = ".($(make_id ("class", require.name, "struct", require.name)))"
            endnew
        endfor

        for my.impl.interface
            for interface.context
                my.property = item_copy_to (context, struct, "property")
                my.property. ?= "Interface implementation specific context."
            endfor
        endfor

        for my.impl.require where type = "interface"
            new property to struct
                . = "Ownership status of the dependency to the interface '$(require.name:)'."
                .name = my.names.implementation_property_is_owning_dependency_$(make_id (require.name))
                .type = "size"
                .bits = 1
            endnew
        endfor
    endnew
endfunction


function _Z19_add_interface_constants (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    for my.impl.interface
        for interface.constant
            copy constant to my.destination
        endfor
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add function that returns size of implementation context type.
# ---------------------------------------------------------------------------
function _Z19_add_method_impl_type_size (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Return size of '$(my.refs.c_implementation_struct_impl)' type.
        "
        .name = cat (my.names.class_impl, "size")
        .declaration = my.declaration
        .definition = my.definition

        new return
            .type = "size"
        endnew

        new implementation to method
            . = "return sizeof ($(my.refs.c_implementation_struct_impl));"
        endnew

        return method
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add function that cast specific implementation context type to the
#   common implementation context type.
# ---------------------------------------------------------------------------
function _Z19_add_method_impl_type_cast (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    new method to my.destination
        . = "\
        Cast to the '.(c_class_impl_struct_impl)' type.
        "
        .name = my.names.class_impl
        .declaration = my.declaration
        .definition = my.definition

        _Z19_add_argument_impl (method, my.meta)

        new return
            .class = ".(c_class_impl_struct_impl)"
            .access = "readwrite"
        endnew

        my.arg_impl = ".(_argument_$(make_id (my.names.implementation_struct_impl)))"
        new implementation to method
            . = "\
            .(c_class_assert_macros_assert) ($(my.arg_impl));
            return (.(c_class_impl_struct_impl) *) ($(my.arg_impl));
            "
        endnew

        return method
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_init (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Perform initialization of preallocated implementation context.
        "
        .name = my.names.method_init
        .declaration = my.declaration
        .definition = my.definition

        _Z19_add_argument_impl (method, my.meta)

        new implementation to method
            my.arg_impl = ".(_argument_$(make_id (my.names.implementation_struct_impl)))"

            . = "\
            .(c_class_assert_macros_assert) ($(my.arg_impl));
            .(c_class_assert_macros_assert) ($(my.arg_impl)->$(my.names.c_property_info:) == NULL);

            $(my.arg_impl)->$(my.names.c_property_info:) = &$(my.refs.c_implementation_variable_info);

            $(my.refs.c_implementation_method_init_ctx) ($(my.arg_impl));
            "
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_cleanup (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.method_cleanup
        .name = my.names.method_cleanup
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Cleanup sensitive data within implementation context.
        Note, dependencies are cleaned up as well.
        "

        _Z19_add_argument_impl (method, my.meta)

        new implementation to method
            my.arg_impl = ".(_argument_$(make_id (my.names.implementation_struct_impl)))"

            my.impl_check_precondition = "\
                .(c_class_assert_macros_assert) ($(my.arg_impl));

                if ($(my.arg_impl)->$(my.names.c_property_info:) == NULL) {
                    return;
                }
            "


            for my.impl.require where type = "interface"
                my.dependency = my.refs.c_implementation_property_dependency_$(make_id (require.name))
                my.is_owning_dependency = my.refs.c_implementation_property_is_owning_dependency_$(make_id (require.name))

                my.impl_cleanup_dependencies ?= ""
                my.impl_cleanup_dependencies += "\

                    //   Cleanup dependency: '$(require.name)'.
                    if ($(my.arg_impl)->$(my.dependency)) {
                        if ($(my.arg_impl)->$(my.is_owning_dependency)) {
                            .(c_class_impl_method_destroy) (&$(my.arg_impl)->$(my.dependency));
                        } else {
                            .(c_class_impl_method_cleanup) ($(my.arg_impl)->$(my.dependency));
                            $(my.arg_impl)->$(my.dependency) = NULL;
                        }
                    }
                "
            endfor

            for my.impl.require where type = "api"
                my.dependency = my.refs.c_implementation_property_dependency_$(make_id (require.name))

                my.impl_cleanup_dependencies_api ?= ""
                my.impl_cleanup_dependencies_api += "\

                    //   Release dependency: '$(require.name)'.
                    if ($(my.arg_impl)->$(my.dependency)) {
                        $(my.arg_impl)->$(my.dependency) = NULL;
                    }
                "
            endfor

            my.impl_cleanup_ctx = "\
                $(my.refs.c_implementation_method_cleanup_ctx) ($(my.arg_impl));
            "

            my.impl_cleanup_info = "\
                $(my.arg_impl)->$(my.names.c_property_info:) = NULL;
            "

            my.method_body = ""
            my.method_body += format_left (my.impl_check_precondition) + terminator
            my.method_body += (format_left (my.impl_cleanup_dependencies) + terminator) ? ""
            my.method_body += (format_left (my.impl_cleanup_dependencies_api) + terminator) ? ""
            my.method_body += format_left (my.impl_cleanup_ctx) + terminator
            my.method_body += format_left (my.impl_cleanup_info)

            . = my.method_body
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_new (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.method_new
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Allocate implementation context and perform it's initialization.
        Postcondition: check memory allocation result.
        "

        _Z19_add_return_impl (method, my.meta)

        new implementation to method
            my.type_impl = my.refs.c_implementation_struct_impl
            my.arg_impl = my.names.c_implementation_struct_impl

            . = "\
            $(my.type_impl) *$(my.arg_impl:) = ($(my.type_impl) *) .(c_global_method_alloc) (sizeof ($(my.type_impl)));
            .(c_class_assert_macros_assert) ($(my.arg_impl:));

            $(my.refs.c_implementation_method_init) ($(my.arg_impl:));

            return $(my.arg_impl:);
            "
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_destroy (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.method_destroy
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Destroy given implementation context and it's dependencies.
        This function SHOULD be called even if context was statically allocated,
        because it automatically detect this fact for context itself and
        dependencies as well and destroy them appropriately.
        "

        _Z19_add_argument_impl (method, my.meta, "disown")

        new implementation
            my.arg_impl_ref = ".(_argument_$(make_id (my.names.implementation_struct_impl)))"
            my.arg_impl = my.names.c_implementation_struct_impl
            my.type_impl = my.refs.c_implementation_struct_impl

            . = "\
            .(c_class_assert_macros_assert) ($(my.arg_impl_ref));

            $(my.type_impl) *$(my.arg_impl:) = *$(my.arg_impl_ref);
            *$(my.arg_impl_ref) = NULL;

            if ($(my.arg_impl:)) {
                $(my.refs.c_implementation_method_cleanup) ($(my.arg_impl:));
                .(c_global_method_dealloc) ($(my.arg_impl:));
            }
            "
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_lifecycle_methods (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    _Z19_add_method_init (my.impl, my.declaration, my.definition, my.destination, my.meta)
    _Z19_add_method_cleanup (my.impl, my.declaration, my.definition, my.destination, my.meta)
    _Z19_add_method_new (my.impl, my.declaration, my.definition, my.destination, my.meta)
    _Z19_add_method_destroy (my.impl, my.declaration, my.definition, my.destination, my.meta)
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_init_ctx (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    new method to my.destination
        . = "Privides initialization of the implementation specific context."
        .name = my.names.method_init_ctx
        .declaration = my.declaration
        .definition = my.definition
        .visibility = "private"

        _Z19_add_argument_impl (method, my.meta)
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_cleanup_ctx (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    new method to my.destination
        . = "Privides initialization of the implementation specific context."
        .name = my.names.method_cleanup_ctx
        .declaration = my.declaration
        .definition = my.definition
        .visibility = "private"

        _Z19_add_argument_impl (method, my.meta)
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_ctx_lifecycle_methods (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    _Z19_add_method_init_ctx (my.impl, my.declaration, my.definition, my.destination, my.meta)
    _Z19_add_method_cleanup_ctx (my.impl, my.declaration, my.definition, my.destination, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Define interface method that accept 'api' context.
# ---------------------------------------------------------------------------
function _Z19_define_interface_method_with_api_context (method, impl, meta)
    check_arguments (my, "method, impl, meta", my)

    for my.impl.require
        my.dependency_argument = item_prepend_new ("argument", my.method, my.dependency_argument)
        _Z19_define_dependency_argument (my.dependency_argument, require, my.meta)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Define interface method that accept 'impl' context.
# ---------------------------------------------------------------------------
function _Z19_define_interface_method_with_impl_context (method, impl, meta)
    check_arguments (my, "method, impl, meta", my)

    _Z19_add_argument_impl (my.method, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Add methods that implements interface methods.
# ---------------------------------------------------------------------------
function _Z19_add_interface_methods (impl, definition, destination, meta)
    check_arguments (my, "impl, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    for my.impl.interface
        for interface.method
            my.impl_method = item_copy_to (method, my.destination)
            my.impl_method.definition = my.definition

            if method.context = "api"
                _Z19_define_interface_method_with_api_context (my.impl_method, my.impl, my.meta)
            elsif method.context = "impl"
                _Z19_define_interface_method_with_impl_context (my.impl_method, my.impl, my.meta)
            endif
        endfor
    endfor
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_use_dependency (require, declaration, definition, destination, meta)
    check_arguments (my, "require, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    new method to my.destination
        . = "\
        Setup dependency '$(my.require.name)' and keep ownership.
        "
        .name = cat (my.names.method_use, my.require.name)
        .definition = my.definition
        .declaration = my.declaration


        _Z19_add_argument_impl (method, my.meta)

        new argument to method
            _Z19_define_dependency_argument (argument, my.require, my.meta)
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_take_dependency (require, declaration, definition, destination, meta)
    check_arguments (my, "require, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    new method to my.destination
        . = "\
        Setup dependency '$(my.require.name)' and transfer ownership.
        "
        .name = cat (my.names.method_take, my.require.name)
        .definition = my.definition
        .declaration = my.declaration

        _Z19_add_argument_impl (method, my.meta)

        new argument to method
            _Z19_define_dependency_argument (argument, my.require, my.meta)
            argument.access = "disown"
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Add dependency management functions.
# ---------------------------------------------------------------------------
function _Z19_add_dependency_methods (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    for my.impl.require
        _Z19_add_method_use_dependency (require, my.declaration, my.definition, my.destination, my.meta)

        if require.type = "interface"
            _Z19_add_method_take_dependency (require, my.declaration, my.definition, my.destination, my.meta)
        endif
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add next instances:
#       - implemented interface api instance
#       - implemented interface api instances as array
#       - implementation info instance
#       - implementation instance
# ---------------------------------------------------------------------------
function _Z19_add_instances (impl, source, destination, meta)
    check_arguments (my, "impl, source, destination, meta", my)

    my.names = meta_names (my.meta)

    for my.impl.interface
        my.interface_api = c_module_interface_api_find_type (interface.name, my.source, my.meta)
        _Z19_add_instance_interface_api (my.impl, my.interface_api, my.destination, my.meta)
    endfor

    _Z19_add_instance_array_of_interface_api (my.impl, my.destination, my.meta)

    my.impl_info_module = my.source->module (name = my.names.module_impl_private)
    my.impl_info = my.impl_info_module->struct (name = my.names.struct_info)
    _Z19_add_instance_impl_info (my.impl, my.impl_info, my.destination, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Create module with:
#       - opaque declaration of the Implementation API type
#       - constants that required by interfaces
#       - lifecycle functions - declaration only
#       - functions that implements interface
#       - dependency management functions - declaration only
#       - function that returns implementation type size - declaration only
#       - function that cast implementation type to the common
#         implementation type - declaration only
# ---------------------------------------------------------------------------
function c_module_implementation_create_module_public (impl, enum_impl_tag, destination, meta)
    check_arguments (my, "impl, enum_impl_tag, destination, meta", my)

    my.names = meta_names (my.meta)

    new module to my.destination
        . = "\
        This module contains '$(my.names.implementation_module)' implementation.
        "

        .name = my.names.implementation_module
        .class = my.names.implementation_class

        _Z19_add_includes_for_module_public (my.impl, module, my.meta)
        _Z19_add_self_tag (my.impl, my.enum_impl_tag, my.meta)
        _Z19_add_interface_constants (my.impl, module, my.meta)

        if _Z19_has_methods_with_context_impl (my.impl)
            _Z19_add_type_impl (my.impl, "external", module, my.meta)
            _Z19_add_method_impl_type_size (my.impl, "public", "external", module, my.meta)
            _Z19_add_method_impl_type_cast (my.impl, "public", "external", module, my.meta)
            _Z19_add_ctx_lifecycle_methods (my.impl, "external", "private", module, my.meta)
            _Z19_add_lifecycle_methods (my.impl, "public", "external", module, my.meta)
            _Z19_add_dependency_methods (my.impl, "public", "external", module, my.meta)
        endif

        _Z19_add_interface_methods (my.impl, "public", module, my.meta)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Creates module with:
#       - Implementation type definition.
# ---------------------------------------------------------------------------
function c_module_implementation_create_module_impl (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)

    new module to my.destination
        .= "\
        Types of the '$(my.impl.name:)' implementation.
        This types SHOULD NOT be used directly.
        The only purpose of including this module is to place implementation
        object in the stack memory.
        "

        .name = my.names.implementation_module_impl
        .of_class = my.names.implementation_class
        .scope = "private"

        new require to module
            .module = my.names.module_library
        endnew

        new require to module
            .module = my.names.module_impl_private
        endnew

        for my.impl.require as dependency where type = "api"
            new require to module
                .module = dependency.name
            endnew
        endfor

        _Z19_add_type_impl (my.impl, "public", module, my.meta)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Creates module with fully generated code:
#       - instantiations of the Interface API objects
#       - instantiations of the Implementation API objects
#       - lifecycle functions - definition only
#       - dependency management functions - definition only
#       - function that returns implementation type size - definition only
#       - function that cast implementation type to the common
#         implementation type - definition only
# ---------------------------------------------------------------------------
function c_module_implementation_create_module_internal (impl, source, destination, meta)
    check_arguments (my, "impl, source, destination, meta", my)

    my.names = meta_names (my.meta)

    new module to my.destination
        . = "\
        "

        .name = my.names.implementation_module_internal
        .of_class = my.names.implementation_class
        .scope = "internal"

        _Z19_add_includes_for_module_internal (my.impl, module, my.meta)
        _Z19_add_instances (my.impl, my.source, module, my.meta)
        _Z19_add_ctx_lifecycle_methods (my.impl, "public", "external", module, my.meta)
        _Z19_add_lifecycle_methods (my.impl, "external", "private", module, my.meta)
        _Z19_add_dependency_methods (my.impl, "external", "private", module, my.meta)
        _Z19_add_method_impl_type_size (my.impl, "external", "private", module, my.meta)
        _Z19_add_method_impl_type_cast (my.impl, "external", "private", module, my.meta)

    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'Implementation Lifecycle API' module for each 'implementation'
#   within given source and put it to the destination.
# ---------------------------------------------------------------------------
function c_module_implementation_create (source, destination, meta)
    check_arguments (my, "source, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    my.module_impl = my.source->module (name = my.names.module_impl)
    my.enum_impl_tag = my.module_impl->enum (name = my.names.enum_tag)

    for my.source.implementation
        meta_reset_active_entity (my.meta, implementation.name)

        c_module_implementation_create_module_public (implementation, my.enum_impl_tag, my.destination, my.meta)

        if _Z19_has_methods_with_context_impl (implementation)
            c_module_implementation_create_module_impl (implementation, my.destination, my.meta)
            c_module_implementation_create_module_internal (implementation, my.source, my.destination, my.meta)
        endif
    endfor
endfunction

.endtemplate

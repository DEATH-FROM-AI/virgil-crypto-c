.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Create 3 modules with 'Implementation API'.
#   For details see functions description:
#       - c_module_implementation_create_module_public ()
#       - c_module_implementation_create_module_impl ()
#       - c_module_implementation_create_module_internal ()
#
#   Private function prefix is: Z19.
# ---------------------------------------------------------------------------
#   This is a code generator helper built using the iMatix GSL code
#   generation language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------


gsl from "common.gsl"
gsl from "component.gsl"
gsl from "c_module_interface.gsl"

# ---------------------------------------------------------------------------
function _Z19_has_methods_with_context_impl (impl)
    check_argument (my, "impl", my)

    for my.impl.interface
        for interface.method where context = "impl"
            return 1
        endfor
    endfor

    return 0
endfunction

# ---------------------------------------------------------------------------
function _Z19_has_underlying_context (impl)
    check_argument (my, "impl", my)

    return count (my.impl.context) <> 0
endfunction

# ---------------------------------------------------------------------------
#   Add instance of 'Interface API' class.
#   Instance is fulfilled with implementation constants, methods,
#   and dependencies.
# ---------------------------------------------------------------------------
function _Z19_add_instance_interface_api (impl, interface_api, destination, meta)
    check_arguments (my, "impl, interface_api, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new variable to my.destination
        . = "Configuration of the interface API '$(my.interface_api.name:)'."
        .name = my.interface_api.name
        .class = ref (make_id ("class", my.interface_api.name, "struct", my.interface_api.name))
        .declaration = "private"
        .definition = "private"
        .is_reference = "0"

        for my.interface_api.property
            my.value = item_copy_to (property, variable, "value")

            scope my.value
                if property.tag = "tag"
                    .value = property.value #   Actually this attribute already there

                elsif property.tag = "api"
                    .value = my.refs.implementation_variable_$(make_id (property.name))

                elsif property.tag = "method"
                    .value = my.refs.implementation_method_$(make_id (property.name))
                    item_copy_to (property, value, "cast")

                elsif property.tag = "constant"
                    .value = my.refs.implementation_constant_$(make_id (property.name))

                else
                    my.property_dump = my.property_dump = component_instance_dump (property)
                    echo_fatal ("Can not handle attribute 'tag' of the property $(my.property_dump:).")
                endif
            endscope
        endfor

    endnew
endfunction


# ---------------------------------------------------------------------------
#   Add instance for each implemented interface.
# ---------------------------------------------------------------------------
function _Z19_add_instances_of_interface_api (impl, source, destination, meta)
    check_arguments (my, "impl, source, destination, meta", my)

    my.names = meta_names (my.meta)

    for my.impl.interface
        my.interface_api = c_module_interface_find_api_type (interface.name, my.source, my.meta)
        _Z19_add_instance_interface_api (my.impl, my.interface_api, my.destination, my.meta)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add instance that is array of the implemented 'Interface API' instances.
# ---------------------------------------------------------------------------
function _Z19_add_instance_array_of_interface_api (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new variable to my.destination
        . = "Null-terminated array of the implemented 'Interface API' instances."
        .name = my.names.implementation_variable_api_array
        .class = my.refs.class_api_struct_api
        .declaration = "private"
        .definition = "private"

        new array to variable
            .length = "derived"
            .access = "readonly"
        endnew

        for my.impl.interface
            new value to variable
                .value = my.refs.implementation_variable_$(make_id (interface.name))_api

                new cast to value
                    .class = my.refs.class_api_struct_api
                    .access = "readonly"
                endnew
            endnew
        endfor

        new value to variable
            .value = "NULL"
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Add instance of the 'Implementation Info' class.
# ---------------------------------------------------------------------------
function _Z19_add_instance_impl_info (impl, source, destination, meta)
    check_arguments (my, "impl, source, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    my.impl_info_module = my.source->module (name = my.names.module_impl_private)
    my.impl_info = my.impl_info_module->struct (name = my.names.struct_info)

    new variable to my.destination
        . = "Compile-time known information about '$(my.impl.name:)' implementation."
        .name = my.names.implementation_variable_info
        .class = my.refs.class_impl_struct_info
        .declaration = "private"
        .definition = "private"
        .is_reference = "0"

        for my.impl_info.property
            my.value = item_copy_to (property, variable, "value")
            scope my.value
                if property.tag = "tag"
                    .value = my.refs.implementation_constant_tag

                elsif property.tag = "api_array"
                    .value = my.refs.implementation_variable_api_array

                elsif property.tag = "self_cleanup"
                    .value = my.refs.implementation_method_cleanup
                    item_copy_to (property, value, "cast")

                elsif property.tag = "self_delete"
                    .value = my.refs.implementation_method_delete
                    item_copy_to (property, value, "cast")

                else
                    my.property_dump = component_instance_dump (property)
                    echo_fatal ("Unsupported impl info property: $(my.property_dump:).", my)
                endif
            endscope
        endfor
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Add next instances:
#       - implemented interface api instance
#       - implemented interface api instances as array
#       - implementation info instance
#       - implementation instance
# ---------------------------------------------------------------------------
function _Z19_add_instances (impl, source, destination, meta)
    check_arguments (my, "impl, source, destination, meta", my)

    _Z19_add_instances_of_interface_api (my.impl, my.source, my.destination, my.meta)
    _Z19_add_instance_array_of_interface_api (my.impl, my.destination, my.meta)
    _Z19_add_instance_impl_info (my.impl, my.source, my.destination, my.meta)
endfunction


# ---------------------------------------------------------------------------
#   Add require includes to the implementation public module.
# ---------------------------------------------------------------------------
function _Z19_add_includes_for_module_public (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)

    new require to my.destination
        .module = my.names.module_library
    endnew

        new require
            .module = my.names.module_error
        endnew

    new require to my.destination
        .module = my.names.module_assert
        .scope = "private"
    endnew

    new require to my.destination
        .module = my.names.module_memory
        .scope = "private"
    endnew

    for my.impl.dependency where type = "api"
        new require to my.destination
            .module = dependency.interface
        endnew
    endfor

    for my.impl.dependency where type = "impl"
        new require to my.destination
            .module = dependency.interface
            .scope = "private"
        endnew
    endfor

    if count (my.impl.dependency, type = "impl") | _Z19_has_methods_with_context_impl (my.impl)
        new require to my.destination
            .module = my.names.module_impl
        endnew
    endif

    for my.impl.interface
        new require to my.destination
            .module = interface.name
        endnew
    endfor

    for my.impl.require where has_one_of_attribute (require, "module, header, interface, class")
        copy require to my.destination
    endfor

    if _Z19_has_methods_with_context_impl (my.impl)
        new require to my.destination
            .module = my.names.implementation_module_impl
            .scope = "private"
        endnew

        new require to my.destination
            .module = my.names.implementation_module_internal
            .scope = "private"
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Add require includes to the implementation public module.
# ---------------------------------------------------------------------------
function _Z19_add_includes_for_module_internal (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)

    new require to my.destination
        .module = my.names.module_library
    endnew

    new require
        .module = my.names.module_error
    endnew

    new require to my.destination
        .module = my.names.module_memory
        .scope = "private"
    endnew

    new require to my.destination
        .module = my.names.module_assert
        .scope = "private"
    endnew

    new require to my.destination
        .module = my.names.implementation_module
        .scope = "private"
    endnew

    if _Z19_has_methods_with_context_impl (my.impl)
        new require to my.destination
            .module = my.names.implementation_module
            .scope = "public"
        endnew

        new require to my.destination
            .module = my.names.implementation_module_impl
            .scope = "private"
        endnew
    endif

    for my.impl.interface
        my.entity_names = meta_entity_names (my.meta, interface.name)

        new require to my.destination
            .module = my.entity_names.interface_module_api
            .scope = "private"
        endnew
    endfor

    for my.impl.dependency
        my.entity_names = meta_entity_names (my.meta, dependency.interface)

        new require to my.destination
            .module = my.entity_names.interface_module
            .scope = "private"
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
function _Z19_add_argument_impl (destination, meta, access)
    check_arguments (my, "destination, meta", my)

    my.access ?= "readwrite"

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    my.argument = item_prepend_new ("argument", my.destination)

    scope my.argument
        .name = my.names.implementation_argument_impl
        .class = my.refs.implementation_struct_impl
        .access = my.access
    endscope

    return my.argument
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_return_impl (destination, meta)
    check_arguments (my, "destination, meta", my)

    my.refs = meta_refs (my.meta)

    new return to my.destination
        .class = my.refs.implementation_struct_impl
        .access = "disown"
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_dependency_argument (require, destination, after_argument, meta)
    check_arguments (my, "require, destination, meta", my)

    my.refs = meta_refs (my.meta)

    my.argument = item_prepend_new ("argument", my.destination, my.after_argument)

    scope my.argument
        .name = my.require.name
        if my.require.type = "impl"
            .class = my.refs.class_impl_struct_impl
            .access = "readwrite"
        elsif my.require.type = "api"
            .class = ".($(make_id ("class", my.require.name, "struct", my.require.name)))"
            .access = "readonly"
        endif
    endscope

    return my.argument
endfunction

# ---------------------------------------------------------------------------
function _Z19_add_self_tag (implementation, enum, meta)
    check_arguments (my, "implementation, enum, meta", my)

    my.names = meta_names (my.meta)

    my.insertion_position = my.enum->constant (name = my.names.enum_constant_end) ?
    if ! defined (my.insertion_position)
        echo_fatal ("Enum '$(my.enum.name:)' does not contain value '$(my.names.enum_constant_end:)'.", my)
    endif

    new constant before my.insertion_position
        .name = my.implementation.name
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add type that handles implementation details.
# ---------------------------------------------------------------------------
function _Z19_add_type_impl (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new struct to my.destination
        . = "Handles implementation details."
        .name = my.names.struct_impl
        .declaration = my.declaration
        .definition = my.definition

        new property to struct
            . = "Compile-time known information about this implementation."
            .name = my.names.property_info
            .class = my.refs.class_impl_struct_info
        endnew

        for my.impl.dependency where type = "impl"
            new property to struct
                . = "Dependency to the interface '$(dependency.interface:)'."
                .name = my.names.implementation_property_$(make_id (dependency.name))
                .class = my.refs.class_impl_struct_impl
                .access = "readwrite"
            endnew
        endfor

        for my.impl.dependency where type = "api"
            new property to struct
                . = "Dependency to the interface api '$(dependency.interface:)'."
                .name = my.names.implementation_property_$(make_id (dependency.name))
                .class = ".($(make_id (\
                        "class", dependency.interface, my.names.struct_api, \
                        "struct", dependency.interface, my.names.struct_api)))"
            endnew
        endfor

        for my.impl.context
            for context.property
                my.property = item_copy_to (property, struct)
                my.property. ?= "Implementation specific context."
            endfor
        endfor

        for my.impl.dependency where type = "impl"
            new property to struct
                . = "Ownership status of the dependency to the interface '$(dependency.interface:)'."
                .name = my.names.implementation_property_is_owning_$(make_id (dependency.name))
                .type = "boolean"
                .bits = "1"
            endnew
        endfor
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_interface_constants (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    for my.impl.interface
        for interface.constant
            copy constant to my.destination
        endfor
    endfor
endfunction


# ---------------------------------------------------------------------------
#   Add function that returns size of implementation context type.
# ---------------------------------------------------------------------------
function _Z19_add_method_impl_type_size (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Return size of '$(my.refs.c_implementation_struct_impl)' type.
        "
        .name = my.names.method_impl_size
        .declaration = my.declaration
        .definition = my.definition

        new return
            .type = "size"
        endnew

        new code to method
            . = "return sizeof ($(my.refs.c_implementation_struct_impl));"
        endnew

        return method
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add function that cast specific implementation context type to the
#   common implementation context type.
# ---------------------------------------------------------------------------
function _Z19_add_method_impl_type_cast (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    new method to my.destination
        . = "\
        Cast to the '.(c_class_impl_struct_impl)' type.
        "
        .name = my.names.method_impl
        .declaration = my.declaration
        .definition = my.definition

        _Z19_add_argument_impl (method, my.meta)

        new return
            .class = ".(c_class_impl_struct_impl)"
            .access = "readwrite"
        endnew

        my.arg_impl = ".(_argument_$(make_id (my.names.implementation_argument_impl)))"
        new code to method
            . = "\
            .(c_class_assert_macros_ptr) ($(my.arg_impl));
            return (.(c_class_impl_struct_impl) *) ($(my.arg_impl));
            "
        endnew

        return method
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_init (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Perform initialization of preallocated implementation context.
        "
        .name = my.names.method_init
        .declaration = my.declaration
        .definition = my.definition

        _Z19_add_argument_impl (method, my.meta)

        new return to method
            .type="error"
        endnew

        new code to method
            my.arg_impl = ".(_argument_$(make_id (my.names.implementation_argument_impl)))"

            my.impl_begin = "\
                .(c_class_assert_macros_ptr) ($(my.arg_impl));
                .(c_class_assert_macros_ptr) ($(my.arg_impl)->$(my.names.c_property_info:) == NULL);

                $(my.arg_impl)->$(my.names.c_property_info:) = &$(my.refs.c_implementation_variable_info);
            "

            for my.impl.dependency
                my.dependency = my.refs.c_implementation_property_$(make_id (dependency.name))

                my.impl_init_dependencies ?= ""
                my.impl_init_dependencies += "\

                    $(my.arg_impl)->$(my.dependency) = NULL;
                "
            endfor

            for my.impl.dependency where type = "impl"
                my.is_owning_dependency = my.refs.c_implementation_property_is_owning_$(make_id (dependency.name))

                my.impl_init_dependencies += "\

                    $(my.arg_impl)->$(my.is_owning_dependency) = false;
                "
            endfor

            if _Z19_has_underlying_context (my.impl)
                my.impl_end = "\
                    return $(my.refs.c_implementation_method_init_ctx) ($(my.arg_impl));
                "
            else
                my.impl_end = "\
                    return .(c_global_enum_error_constant_success);
                "
            endif

            my.method_body = ""
            my.method_body += format_left (my.impl_begin) + terminator
            my.method_body += format_left (my.impl_init_dependencies) + terminator ? ""
            my.method_body += format_left (my.impl_end) + terminator

            . = my.method_body
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_cleanup (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.method_cleanup
        .name = my.names.method_cleanup
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Cleanup implementation context and it's dependencies.
        This is a reverse action of the function '$(my.refs.c_implementation_method_init) ()'.
        All dependencies that is not under ownership will be cleaned up.
        All dependencies that is under ownership will be destroyed.
        "

        _Z19_add_argument_impl (method, my.meta)

        new code to method
            my.arg_impl = ".(_argument_$(make_id (my.names.implementation_argument_impl)))"

            my.impl_check_precondition = "\
                .(c_class_assert_macros_ptr) ($(my.arg_impl));

                if ($(my.arg_impl)->$(my.names.c_property_info:) == NULL) {
                    return;
                }
            "


            for my.impl.dependency where type = "impl"
                my.dependency = my.refs.c_implementation_property_$(make_id (dependency.name))
                my.is_owning_dependency = my.refs.c_implementation_property_is_owning_$(make_id (dependency.name))

                my.impl_cleanup_dependencies ?= ""
                my.impl_cleanup_dependencies += "\

                    //   Cleanup dependency: '$(dependency.name)'.
                    if ($(my.arg_impl)->$(my.dependency)) {

                        if ($(my.arg_impl)->$(my.is_owning_dependency)) {
                            .(c_class_impl_method_destroy) (&$(my.arg_impl)->$(my.dependency));

                        } else {
                            .(c_class_impl_method_cleanup) ($(my.arg_impl)->$(my.dependency));
                            $(my.arg_impl)->$(my.dependency) = NULL;
                        }

                        $(my.arg_impl)->$(my.is_owning_dependency) = 0;
                    }
                "
            endfor

            for my.impl.dependency where type = "api"
                my.dependency = my.refs.c_implementation_property_$(make_id (dependency.name))

                my.impl_cleanup_dependencies_api ?= ""
                my.impl_cleanup_dependencies_api += "\

                    //   Release dependency: '$(dependency.name)'.
                    if ($(my.arg_impl)->$(my.dependency)) {
                        $(my.arg_impl)->$(my.dependency) = NULL;
                    }
                "
            endfor

            if _Z19_has_underlying_context (my.impl)
                my.impl_cleanup_ctx = "\
                    $(my.refs.c_implementation_method_cleanup_ctx) ($(my.arg_impl));
                "
            endif

            my.impl_cleanup_info = "\
                $(my.arg_impl)->$(my.names.c_property_info:) = NULL;
            "

            my.method_body = ""
            my.method_body += format_left (my.impl_check_precondition) + terminator
            my.method_body += format_left (my.impl_cleanup_dependencies) + terminator ? ""
            my.method_body += format_left (my.impl_cleanup_dependencies_api) + terminator ? ""
            my.method_body += format_left (my.impl_cleanup_ctx) + terminator ? ""
            my.method_body += format_left (my.impl_cleanup_info)

            . = my.method_body
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_new (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.method_new
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Allocate implementation context and perform it's initialization.
        Postcondition: check memory allocation result.
        "

        _Z19_add_return_impl (method, my.meta)

        new code to method
            my.type_impl = my.refs.c_implementation_struct_impl
            my.arg_impl = my.names.c_implementation_argument_impl

            . = "\
            $(my.type_impl) *$(my.arg_impl:) = ($(my.type_impl) *) .(c_global_method_alloc) (sizeof ($(my.type_impl)));
            if (NULL == $(my.arg_impl:)) {
                return NULL;
            }

            if ($(my.refs.c_implementation_method_init) ($(my.arg_impl:)) != .(c_global_enum_error_constant_success)) {
                .(c_global_method_dealloc)($(my.arg_impl:));
                return NULL;
            }

            return $(my.arg_impl:);
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
function _Z19_add_method_delete (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.method_delete
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Delete given implementation context and it's dependencies.
        This is a reverse action of the function '$(my.refs.c_implementation_method_new) ()'.
        All dependencies that is not under ownership will be cleaned up.
        All dependencies that is under ownership will be destroyed.
        "

        _Z19_add_argument_impl (method, my.meta)

        new code
            my.arg_impl = ".(_argument_$(make_id (my.names.implementation_argument_impl)))"

            . = "\
            if ($(my.arg_impl)) {
                $(my.refs.c_implementation_method_cleanup) ($(my.arg_impl));
                .(c_global_method_dealloc) ($(my.arg_impl));
            }
            "
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
function _Z19_add_method_destroy (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        .name = my.names.method_destroy
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Destroy given implementation context and it's dependencies.
        This is a reverse action of the function '$(my.refs.c_implementation_method_new) ()'.
        All dependencies that is not under ownership will be cleaned up.
        All dependencies that is under ownership will be destroyed.
        Given reference is nullified.
        "

        _Z19_add_argument_impl (method, my.meta, "disown")

        new code
            my.arg_impl_ref = ".(_argument_$(make_id (my.names.implementation_argument_impl)))"
            my.arg_impl = my.names.c_implementation_argument_impl
            my.type_impl = my.refs.c_implementation_struct_impl

            . = "\
            .(c_class_assert_macros_ptr) ($(my.arg_impl_ref));

            $(my.type_impl) *$(my.arg_impl:) = *$(my.arg_impl_ref);
            *$(my.arg_impl_ref) = NULL;

            $(my.refs.c_implementation_method_delete) ($(my.arg_impl:));
            "
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_lifecycle_methods (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    _Z19_add_method_init (my.impl, my.declaration, my.definition, my.destination, my.meta)
    _Z19_add_method_cleanup (my.impl, my.declaration, my.definition, my.destination, my.meta)
    _Z19_add_method_new (my.impl, my.declaration, my.definition, my.destination, my.meta)
    _Z19_add_method_delete (my.impl, my.declaration, my.definition, my.destination, my.meta)
    _Z19_add_method_destroy (my.impl, my.declaration, my.definition, my.destination, my.meta)
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_init_ctx (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    new method to my.destination
        . = "Provides initialization of the implementation specific context."
        .name = my.names.method_init_ctx
        .declaration = my.declaration
        .definition = my.definition
        .visibility = "private"

        _Z19_add_argument_impl (method, my.meta)

        new return to method
            .type="error"
        endnew
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_cleanup_ctx (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    my.names = meta_names (my.meta)

    new method to my.destination
        . = "Provides cleanup of the implementation specific context."
        .name = my.names.method_cleanup_ctx
        .declaration = my.declaration
        .definition = my.definition
        .visibility = "private"

        _Z19_add_argument_impl (method, my.meta)
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_ctx_lifecycle_methods (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    _Z19_add_method_init_ctx (my.impl, my.declaration, my.definition, my.destination, my.meta)
    _Z19_add_method_cleanup_ctx (my.impl, my.declaration, my.definition, my.destination, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Define interface method that accept 'api' context.
# ---------------------------------------------------------------------------
function _Z19_define_interface_method_with_api_context (method, impl, meta)
    check_arguments (my, "method, impl, meta", my)

    for my.impl.dependency
        my.after_argument = _Z19_add_dependency_argument (dependency, my.method, my.after_argument, my.meta)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Define interface method that accept 'impl' context.
# ---------------------------------------------------------------------------
function _Z19_define_interface_method_with_impl_context (method, impl, meta)
    check_arguments (my, "method, impl, meta", my)

    _Z19_add_argument_impl (my.method, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Add methods that implements interface methods.
# ---------------------------------------------------------------------------
function _Z19_add_interface_methods (impl, definition, destination, meta)
    check_arguments (my, "impl, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    for my.impl.interface
        for interface.method
            my.impl_method = item_copy_to (method, my.destination)
            my.impl_method.definition = my.definition

            if method.context = "api"
                _Z19_define_interface_method_with_api_context (my.impl_method, my.impl, my.meta)
            elsif method.context = "impl"
                _Z19_define_interface_method_with_impl_context (my.impl_method, my.impl, my.meta)
            endif
        endfor
    endfor
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_use_dependency (dependency, declaration, definition, destination, meta)
    check_arguments (my, "dependency, declaration, definition, destination, meta", my)

    meta_activate_entity (my.meta, my.dependency.interface)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Setup dependency to the interface '$(my.dependency.interface:)' and keep ownership.
        "
        .name = my.names.implementation_method_use_$(make_id (dependency.interface))
        .definition = my.definition
        .declaration = my.declaration


        my.arg_impl = _Z19_add_argument_impl (method, my.meta)
        _Z19_add_dependency_argument (my.dependency, method, my.arg_impl, my.meta)

        new code to method
            my.arg_impl = ".(_argument_$(make_id (my.names.implementation_argument_impl)))"
            my.arg_dependency = ".(_argument_$(make_id (my.dependency.name)))"
            my.property_dependency = my.refs.c_implementation_property_$(make_id (my.dependency.name))
            my.full_dependency = "$(my.arg_impl)->$(my.property_dependency)"

            my.impl_check_precondition = "\
                .(c_class_assert_macros_ptr) ($(my.arg_impl));
                .(c_class_assert_macros_ptr) ($(my.arg_dependency));
                .(c_class_assert_macros_ptr) ($(my.full_dependency) == NULL);
            "

            if my.dependency.type = "impl"
                my.impl_check_dependency_interface = "\
                .(c_class_assert_macros_assert) ($(my.refs.c_interface_method_is_implemented) ($(my.arg_dependency:)));
                "
            endif

            my.impl_setup_dependency = "\
                $(my.full_dependency) = $(my.arg_dependency);
            "

            if my.dependency.type = "impl"
                my.property_is_owning_dependency = \
                        my.refs.c_implementation_property_is_owning_$(make_id (my.dependency.name))

                my.is_owning_dependency = "$(my.arg_impl)->$(my.property_is_owning_dependency)"

                my.impl_setup_dependency_ownage = "\
                    $(my.is_owning_dependency) = 0;
                "
            endif

            my.method_body = ""
            my.method_body += format_left (my.impl_check_precondition) + terminator
            my.method_body += format_left (my.impl_check_dependency_interface) + terminator ? ""
            my.method_body += format_left (my.impl_setup_dependency) + terminator
            my.method_body += format_left (my.impl_setup_dependency_ownage) + terminator ? ""

            . = my.method_body
        endnew
    endnew

    meta_deactivate_entity (my.meta, my.dependency.interface)
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_method_take_dependency (dependency, declaration, definition, destination, meta)
    check_arguments (my, "dependency, declaration, definition, destination, meta", my)

    meta_activate_entity (my.meta, my.dependency.interface)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Setup dependency to the interface '$(my.dependency.interface)' and transfer ownership.
        "
        .name = my.names.implementation_method_take_$(make_id (dependency.interface))
        .definition = my.definition
        .declaration = my.declaration

        my.arg_impl = _Z19_add_argument_impl (method, my.meta)

        my.argument = _Z19_add_dependency_argument (my.dependency, method, my.arg_impl, my.meta)
        my.argument.access = "disown"

        new code to method
            my.arg_impl = ".(_argument_$(make_id (my.names.implementation_argument_impl)))"
            my.arg_dependency_ref = ".(_argument_$(make_id (my.dependency.name)))"
            my.type_dependency = my.refs.c_class_impl_struct_impl
            my.arg_dependency = make_id (my.dependency.name)
            my.property_dependency = my.refs.c_implementation_property_$(make_id (my.dependency.name))
            my.full_dependency = "$(my.arg_impl)->$(my.property_dependency:)"

            my.impl_check_precondition = "\
                .(c_class_assert_macros_ptr) ($(my.arg_impl));
                .(c_class_assert_macros_ptr) ($(my.arg_dependency_ref));
                .(c_class_assert_macros_ptr) ($(my.full_dependency:) == NULL);
            "

            my.impl_check_dependency = "\
                $(my.type_dependency) *$(my.arg_dependency) = *$(my.arg_dependency_ref);
                *$(my.arg_dependency_ref) = NULL;
                .(c_class_assert_macros_ptr) ($(my.arg_dependency:));
            "

            if my.dependency.type = "impl"
                my.impl_check_dependency_interface = "\
                .(c_class_assert_macros_assert) ($(my.refs.c_interface_method_is_implemented) ($(my.arg_dependency:)));
                "
            endif

            my.impl_setup_dependency = "\
                $(my.full_dependency:) = $(my.arg_dependency);
            "

            if my.dependency.type = "impl"
                my.property_is_owning_dependency = \
                        my.refs.c_implementation_property_is_owning_$(make_id (my.dependency.name))

                my.is_owning_dependency = "$(my.arg_impl)->$(my.property_is_owning_dependency)"

                my.impl_setup_dependency_ownage = "\
                    $(my.is_owning_dependency) = 1;
                "
            endif

            my.method_body = ""
            my.method_body += format_left (my.impl_check_precondition) + terminator
            my.method_body += format_left (my.impl_check_dependency) + terminator
            my.method_body += format_left (my.impl_check_dependency_interface) + terminator ? ""
            my.method_body += format_left (my.impl_setup_dependency) + terminator
            my.method_body += format_left (my.impl_setup_dependency_ownage) + terminator ? ""

            . = my.method_body
        endnew
    endnew

    meta_deactivate_entity (my.meta, my.dependency.interface)
endfunction


# ---------------------------------------------------------------------------
#   Add dependency management functions.
# ---------------------------------------------------------------------------
function _Z19_add_dependency_methods (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    for my.impl.dependency

        _Z19_add_method_use_dependency (dependency, my.declaration, my.definition, my.destination, my.meta)

        if dependency.type = "impl"
            _Z19_add_method_take_dependency (dependency, my.declaration, my.definition, my.destination, my.meta)
        endif
    endfor
endfunction


# ---------------------------------------------------------------------------
#   Add dependency management functions.
# ---------------------------------------------------------------------------
function _Z19_add_interface_api_methods (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    for my.impl.interface where ! count (method, method.context = "impl")
        meta_activate_entity (my.meta, interface.name)

        my.names = meta_names (my.meta)
        my.refs = meta_refs (my.meta)

        new method to my.destination
            . = "Returns instance of the implemented interface '$(interface.name:)'."
            .name = my.names.interface_struct_api
            .declaration = my.declaration
            .definition = my.definition

            new return to method
                .class = my.refs.interface_struct_api
            endnew

            new code to method
                . = "\
                    return &$(my.refs.c_implementation_variable_$(make_id (interface.name))_api);
                "
            endnew
        endnew

        meta_deactivate_entity (my.meta, interface.name)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add functions that are defined in the implementation itself.
# ---------------------------------------------------------------------------
function _Z19_add_constants (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    for my.impl.constant
        copy constant to my.destination
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add functions that are defined in the implementation itself.
# ---------------------------------------------------------------------------
function _Z19_add_enums (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    for my.impl.enum
        copy enum to my.destination
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add functions that are defined in the implementation itself.
# ---------------------------------------------------------------------------
function _Z19_add_macroses (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    for my.impl.macros
        copy macros to my.destination
    endfor

    for my.impl.macroses
        copy macroses to my.destination
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add functions that are defined in the implementation itself.
# ---------------------------------------------------------------------------
function _Z19_add_methods (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    for my.impl.method
        my.copied_method = item_copy_to (method, my.destination)

        if (my.copied_method.context = "impl")
            _Z19_add_argument_impl (my.copied_method, my.meta)
        endif
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Create module with:
#       - opaque declaration of the Implementation API type
#       - constants that required by interfaces
#       - lifecycle functions - declaration only
#       - functions that implements interface
#       - dependency management functions - declaration only
#       - function that returns implementation type size - declaration only
#       - function that cast implementation type to the common
#         implementation type - declaration only
# ---------------------------------------------------------------------------
function c_module_implementation_create_module_public (impl, enum_impl_tag, destination, meta)
    check_arguments (my, "impl, enum_impl_tag, destination, meta", my)

    my.names = meta_names (my.meta)

    echo_trace ("Create module: $(my.names.implementation_module)", my)

    new module to my.destination
        . = "\
        This module contains '$(my.names.implementation_module)' implementation.
        "

        .name = my.names.implementation_module
        .of_class = my.names.implementation_class
        .feature = my.impl.name

        _Z19_add_includes_for_module_public (my.impl, module, my.meta)
        _Z19_add_self_tag (my.impl, my.enum_impl_tag, my.meta)
        _Z19_add_interface_constants (my.impl, module, my.meta)

        if _Z19_has_methods_with_context_impl (my.impl)
            _Z19_add_type_impl (my.impl, "public", "external", module, my.meta)
            _Z19_add_method_impl_type_size (my.impl, "public", "external", module, my.meta)
            _Z19_add_method_impl_type_cast (my.impl, "public", "external", module, my.meta)

            if _Z19_has_underlying_context (my.impl)
                _Z19_add_ctx_lifecycle_methods (my.impl, "external", "private", module, my.meta)
            endif

            _Z19_add_lifecycle_methods (my.impl, "public", "external", module, my.meta)
            _Z19_add_dependency_methods (my.impl, "public", "external", module, my.meta)
        endif

        _Z19_add_interface_api_methods (my.impl, "public", "external", module, my.meta)
        _Z19_add_constants (my.impl, module, my.meta)
        _Z19_add_enums (my.impl, module, my.meta)
        _Z19_add_macroses (my.impl, module, my.meta)
        _Z19_add_methods (my.impl, module, my.meta)
        _Z19_add_interface_methods (my.impl, "public", module, my.meta)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Creates module with:
#       - Implementation type definition.
# ---------------------------------------------------------------------------
function c_module_implementation_create_module_impl (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)

    echo_trace ("Create module: $(my.names.implementation_module_impl)", my)

    new module to my.destination
        .= "\
        Types of the '$(my.impl.name:)' implementation.
        This types SHOULD NOT be used directly.
        The only purpose of including this module is to place implementation
        object in the stack memory.
        "

        .name = my.names.implementation_module_impl
        .of_class = my.names.implementation_class
        .scope = "private"
        .feature = my.impl.name

        new require to module
            .module = my.names.module_library
        endnew

        new require
            .module = my.names.module_error
        endnew

        new require to module
            .module = my.names.module_impl_private
        endnew

        new require to module
            .module = my.names.implementation_module
        endnew

        for my.impl.dependency where type = "api"
            new require to module
                .module = dependency.interface
            endnew
        endfor

        for my.impl.context
            for context.require where defined (require.header)
                new c_include to module
                    .file = require.header
                    .is_system = "1"
                endnew
            endfor
        endfor

        _Z19_add_type_impl (my.impl, "external", "public", module, my.meta)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Creates module with fully generated code:
#       - instantiations of the Interface API objects
#       - instantiations of the Implementation API objects
#       - lifecycle functions - definition only
#       - dependency management functions - definition only
#       - function that returns implementation type size - definition only
#       - function that cast implementation type to the common
#         implementation type - definition only
# ---------------------------------------------------------------------------
function c_module_implementation_create_module_internal (impl, source, destination, meta)
    check_arguments (my, "impl, source, destination, meta", my)

    my.names = meta_names (my.meta)

    echo_trace ("Create module: $(my.names.implementation_module_internal)", my)

    new module to my.destination
        . = "\
        This module contains logic for interface/implementation architecture.
        Do not use this module in any part of the code.
        "

        .name = my.names.implementation_module_internal
        .of_class = my.names.implementation_class
        .scope = "internal"
        .feature = my.impl.name

        if _Z19_has_methods_with_context_impl (my.impl)

            _Z19_add_includes_for_module_internal (my.impl, module, my.meta)
            _Z19_add_instances (my.impl, my.source, module, my.meta)

            if _Z19_has_underlying_context (my.impl)
                _Z19_add_ctx_lifecycle_methods (my.impl, "public", "external", module, my.meta)
            endif

            _Z19_add_lifecycle_methods (my.impl, "external", "private", module, my.meta)
            _Z19_add_interface_api_methods (my.impl, "external", "private", module, my.meta)
            _Z19_add_dependency_methods (my.impl, "external", "private", module, my.meta)
            _Z19_add_method_impl_type_size (my.impl, "external", "private", module, my.meta)
            _Z19_add_method_impl_type_cast (my.impl, "external", "private", module, my.meta)

        else
            _Z19_add_includes_for_module_internal (my.impl, module, my.meta)
            _Z19_add_instances_of_interface_api (my.impl, my.source, module, my.meta)
            _Z19_add_interface_api_methods (my.impl, "external", "private", module, my.meta)
        endif
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'Implementation Lifecycle API' module for each 'implementation'
#   within given source and put it to the destination.
# ---------------------------------------------------------------------------
function c_module_implementation_create (source, destination, meta)
    check_arguments (my, "source, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    my.module_impl = my.source->module (name = my.names.module_impl)
    my.enum_impl_tag = my.module_impl->enum (name = my.names.enum_tag)

    for my.source.implementation by name
        meta_reset_active_entity (my.meta, implementation.name)

        c_module_implementation_create_module_public (implementation, my.enum_impl_tag, my.destination, my.meta)
        c_module_implementation_create_module_internal (implementation, my.source, my.destination, my.meta)

        if _Z19_has_methods_with_context_impl (implementation)
            c_module_implementation_create_module_impl (implementation, my.destination, my.meta)
        endif

    endfor
endfunction

.endtemplate

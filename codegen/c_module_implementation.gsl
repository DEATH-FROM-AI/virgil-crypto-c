.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Create 3 modules with 'Implementation API'.
#   For details see functions description:
#       - c_module_implementation_create_public_module ()
#       - c_module_implementation_create_types_module ()
#       - c_module_implementation_create_internal_module ()
#
#   Private function prefix is: Z19.
# ---------------------------------------------------------------------------
#   This is a code generator helper built using the iMatix GSL code
#   generation language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------


gsl from "common.gsl"
gsl from "c_module_interface_api.gsl"

# ---------------------------------------------------------------------------
#   Add instance of 'Interface API' class.
#   Instance is fulfilled with implementation constants, methods,
#   and dependencies.
# ---------------------------------------------------------------------------
function _Z19_add_interface_api_instance (impl, interface_api, destination, meta)
    check_arguments (my, "impl, interface_api, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new variable to my.destination
        . = "Configuration of the interface API '$(my.interface_api.name:)'."
        .name = my.interface_api.name
        .class = ref (make_id ("class", my.interface_api.name, "struct", my.interface_api.name))
        .declaration = "private"
        .definition = "private"
        .is_reference = "0"

        for my.interface_api.property
            my.value = item_copy_to (property, variable, "value")

            scope my.value
                if property.tag = "tag"
                    .value = property.value #   Actually this attribute already there

                elsif property.tag = "api"
                    .value = my.refs.implementation_variable_$(make_id (property.name))

                elsif property.tag = "method"
                    .value = my.refs.implementation_method_$(make_id (property.name))
                    item_copy_to (property, value, "cast")

                elsif property.tag = "constant"
                    .value = my.refs.implementation_constant_$(make_id (property.name))

                else
                    my.property_dump = my.property_dump = component_dump_instance (property)
                    echo_fatal ("Can not handle attribute 'tag' of the property $(my.property_dump:).")
                endif
            endscope
        endfor

    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add instance that is array of the implemented 'Interface API' instances.
# ---------------------------------------------------------------------------
function _Z19_add_array_of_interface_api_instances (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new variable to my.destination
        . = "Null-terminated array of the implemented 'Interface API' instances."
        .name = my.names.implementation_variable_api_array
        .class = my.refs.class_api_struct_api
        .declaration = "private"
        .definition = "private"

        new array to variable
            .length = "derived"
            .access = "readonly"
        endnew

        for my.impl.interface
            new value to variable
                .value = my.refs.implementation_variable_$(make_id (interface.name))_api

                new cast to value
                    .class = my.refs.class_api_struct_api
                    .access = "readonly"
                endnew
            endnew
        endfor

        new value to variable
            .value = "NULL"
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add instance of the 'Implementation Info' class.
# ---------------------------------------------------------------------------
function _Z19_add_implementation_info_instance (impl, impl_info, destination, meta)
    check_arguments (my, "impl, impl_info, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new variable to my.destination
        . = "Compile-time known information about '$(my.impl.name:)' implementation."
        .name = my.names.implementation_variable_info
        .class = my.refs.class_impl_struct_info
        .declaration = "private"
        .definition = "private"
        .is_reference = "0"

        for my.impl_info.property
            my.value = item_copy_to (property, variable, "value")
            scope my.value
                if property.tag = "tag"
                    .value = my.refs.implementation_constant_tag

                elsif property.tag = "api_array"
                    .value = my.refs.implementation_variable_api_array

                elsif property.tag = "self_cleanup"
                    .value = my.refs.implementation_method_self_cleanup
                    item_copy_to (property, value, "cast")

                elsif property.tag = "self_destroy"
                    .value = my.refs.implementation_method_self_destroy
                    item_copy_to (property, value, "cast")

                else
                    my.property_dump = component_dump_instance (property)
                    echo_fatal ("Unsupported impl info property: $(my.property_dump:).", my)
                endif
            endscope
        endfor
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add require includes to the implementation public module.
# ---------------------------------------------------------------------------
function _Z19_add_public_module_includes (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)

    new require to my.destination
        .module = my.names.module_library
    endnew

    new require to my.destination
        .module = my.names.module_assert
        .scope = "private"
    endnew

    for my.impl.require where type = "api" as interface_api
        new require to my.destination
            .module = interface_api.name
        endnew
    endfor

    if count (my.impl.require, type = "interface") | _Z19_has_methods_with_context_impl (my.impl)
        new require to my.destination
            .module = my.names.module_impl
        endnew
    endif
endfunction

# ---------------------------------------------------------------------------
#   Add require includes to the implementation public module.
# ---------------------------------------------------------------------------
function _Z19_add_internal_module_includes (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    my.names = meta_names (my.meta)

    new require to my.destination
        .module = my.names.module_library
    endnew

    new require to my.destination
        .module = my.names.implementation_module
        .scope = "private"
    endnew

    if _Z19_has_methods_with_context_impl (my.impl)
        new require to my.destination
            .module = my.names.implementation_module_types
            .scope = "private"
        endnew
    endif

    for my.impl.interface
        new require to my.destination
            .module = cat (interface.name, my.names.module_api)
            .scope = "private"
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
function _Z19_add_argument_impl (destination, meta, access)
    check_arguments (my, "destination, meta", my)

    my.access ?= "readwrite"

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    my.argument = item_prepend_new ("argument", my.destination)

    scope my.argument
        .name = my.names.implementation_struct_impl
        .class = my.refs.implementation_struct_impl
        .access = my.access
    endscope
endfunction


# ---------------------------------------------------------------------------
function _Z19_add_return_impl (destination, meta)
    check_arguments (my, "destination, meta", my)

    my.refs = meta_refs (my.meta)

    new return to my.destination
        .class = my.refs.implementation_struct_impl
        .access = "disown"
    endnew
endfunction


# ---------------------------------------------------------------------------
function _Z19_define_dependency_argument (argument, require, meta)
    check_arguments (my, "argument, require, meta", my)

    my.refs = meta_refs (my.meta)

    my.argument.name = my.require.name
    if my.require.type = "interface"
        my.argument.class = my.refs.class_impl_struct_impl
        my.argument.access = "readwrite"
    elsif require.type = "api"
        my.argument.class = ".($(make_id ("class", require.name, "struct", require.name)))"
        my.argument.access = "readonly"
    endif
endfunction

# ---------------------------------------------------------------------------
function _Z19_has_methods_with_context_impl (impl)
    check_argument (my, "impl", my)

    for my.impl.interface
        for interface.method where context = "impl"
            return 1
        endfor
    endfor

    return 0
endfunction

# ---------------------------------------------------------------------------
function _Z19_add_self_tag (implementation, enum, meta)
    check_arguments (my, "implementation, enum, meta", my)

    my.names = meta_names (my.meta)

    my.insertion_position = my.enum->constant (name = my.names.enum_constant_end) ?
    if ! defined (my.insertion_position)
        echo_fatal ("Enum '$(my.enum.name:)' does not contain value '$(my.names.enum_constant_end:)'.", my)
    endif

    new constant before my.insertion_position
        .name = my.implementation.name
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Add type that handles implementation details.
# ---------------------------------------------------------------------------
function _Z19_add_ctx_type (impl, definition, destination, meta)
    check_arguments (my, "impl, definition, destination, meta", my)

    if ! _Z19_has_methods_with_context_impl (my.impl)
        return
    endif

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new struct to my.destination
        . = "Handles implementation context details."
        .name = my.names.class_ctx
        .definition = my.definition

        for my.impl.interface
            for interface.context
                item_copy_to (context, struct, "property")
            endfor
        endfor
    endnew
endfunction


# ---------------------------------------------------------------------------
#   Add type that handles implementation details.
# ---------------------------------------------------------------------------
function _Z19_add_impl_type (impl, definition, destination, meta)
    check_arguments (my, "impl, definition, destination, meta", my)

    if ! _Z19_has_methods_with_context_impl (my.impl)
        return
    endif

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new struct to my.destination
        . = "Handles implementation details."
        .name = my.names.class_impl
        .definition = my.definition

        new property to struct
            . = "Compile-time known information about this implementation."
            .name = my.names.property_info
            .class = my.refs.class_impl_struct_info
        endnew

        for my.impl.require where type = "interface"
            new property to struct
                . = "Dependency to the interface '$(require.name:)'."
                .name = require.name
                .class = my.refs.class_impl_struct_impl
                .access = "readwrite"
            endnew
        endfor

        for my.impl.require where type = "api"
            new property to struct
                . = "Dependency to the interface api '$(require.name:)'."
                .name = require.name
                .class = ".($(make_id ("class", require.name, "struct", require.name)))"
            endnew
        endfor

        new property to struct
            . = "Interface implementation specific context."
            .name = my.names.class_ctx
            .class = my.refs.implementation_struct_ctx
            .access = "readwrite"
            .is_value = 1
        endnew

        for my.impl.require where type = "interface"
            new property to struct
                . = "Ownership status of the dependency to the interface '$(require.name:)' ."
                .name = cat ("is", require.name, "owning")
                .type = "size"
                .bits = 1
            endnew
        endfor
    endnew
endfunction


function _Z19_add_interface_constants (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    for my.impl.interface
        for interface.constant
            copy constant to my.destination
        endfor
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add function that returns size of implementation context type.
# ---------------------------------------------------------------------------
function _Z19_add_impl_type_size_method (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    if ! _Z19_has_methods_with_context_impl (my.impl)
        return
    endif

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Return size of '$(my.refs.c_implementation_struct_impl)' type.
        "
        .name = cat (my.names.class_impl, "size")
        .declaration = my.declaration
        .definition = my.definition

        new return
            .type = "size"
        endnew

        new implementation to method
            . = "return sizeof ($(my.refs.c_implementation_struct_impl));"
        endnew

        return method
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add function that cast specific implementation context type to the
#   common implementation context type.
# ---------------------------------------------------------------------------
function _Z19_add_impl_type_cast_method (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    if ! _Z19_has_methods_with_context_impl (my.impl)
        return
    endif

    my.names = meta_names (my.meta)

    new method to my.destination
        . = "\
        Cast to the '.(c_class_impl_struct_impl)' type.
        "
        .name = my.names.class_impl
        .declaration = my.declaration
        .definition = my.definition

        _Z19_add_argument_impl (method, my.meta)

        new return
            .class = ".(c_class_impl_struct_impl)"
            .access = "readwrite"
        endnew

        new implementation to method
            . = "return (.(c_class_impl_struct_impl) *) (.(_argument_$(make_id (my.names.implementation_struct_impl))));"
        endnew

        return method
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add next methods if exists functions that require implementation context:
#       - init ()
#       - new ()
#       - cleanup ()
#       - destroy ()
# ---------------------------------------------------------------------------
function _Z19_add_lifecycle_methods (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    if ! _Z19_has_methods_with_context_impl (my.impl)
        return
    endif

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    new method to my.destination
        . = "\
        Perform initialization of preallocated implementation context.
        "
        .name = my.names.method_init
        .declaration = my.declaration
        .definition = my.definition

        _Z19_add_argument_impl (method, my.meta)

        new c_implementation
            . = "//TODO: Implement me."
        endnew
    endnew

    new method to my.destination
        .name = my.names.method_new
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Allocate implementation context and perform it's initialization.
        Return NULL if allocation fails.
        "

        _Z19_add_return_impl (method, my.meta)

        new c_implementation
            . = "//TODO: Implement me."
        endnew
    endnew

    new method to my.destination
        .name = my.names.method_cleanup
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Cleanup sensitive data within implementation context.
        Note, dependencies are cleaned up as well.
        "

        _Z19_add_argument_impl (method, my.meta)

        new c_implementation
            . = "//TODO: Implement me."
        endnew
    endnew

    new method to my.destination
        .name = my.names.method_destroy
        .declaration = my.declaration
        .definition = my.definition

        . = "\
        Destroy given implementation context and it's dependencies.
        This function SHOULD be called even if context was statically allocated,
        because it automatically detect this fact for context itself and
        dependencies as well and destroy them appropriately.
        "

        _Z19_add_argument_impl (method, my.meta, "disown")

        new c_implementation
            . = "//TODO: Implement me."
        endnew
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Define interface method that accept 'api' context.
# ---------------------------------------------------------------------------
function _Z19_define_interface_method_with_api_context (method, impl, meta)
    check_arguments (my, "method, impl, meta", my)

    for my.impl.require
        my.dependency_argument = item_prepend_new ("argument", my.method, my.dependency_argument)
        _Z19_define_dependency_argument (my.dependency_argument, require, my.meta)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Define interface method that accept 'impl' context.
# ---------------------------------------------------------------------------
function _Z19_define_interface_method_with_impl_context (method, impl, meta)
    check_arguments (my, "method, impl, meta", my)

    _Z19_add_argument_impl (my.method, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Add methods that implements interface methods.
# ---------------------------------------------------------------------------
function _Z19_add_interface_methods (impl, definition, destination, meta)
    check_arguments (my, "impl, definition, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    for my.impl.interface
        for interface.method
            my.impl_method = item_copy_to (method, my.destination)
            my.impl_method.definition = my.definition

            if method.context = "api"
                _Z19_define_interface_method_with_api_context (my.impl_method, my.impl, my.meta)
            elsif method.context = "impl"
                _Z19_define_interface_method_with_impl_context (my.impl_method, my.impl, my.meta)
            endif
        endfor
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add dependency management functions.
# ---------------------------------------------------------------------------
function _Z19_add_dependency_methods (impl, declaration, definition, destination, meta)
    check_arguments (my, "impl, declaration, definition, destination, meta", my)

    if ! _Z19_has_methods_with_context_impl (my.impl)
        return
    endif

    my.names = meta_names (my.meta)

    for my.impl.require
        new method to my.destination
            . = "\
            Setup dependency '$(require.name)' and keep ownership.
            "
            .name = cat (my.names.method_use, require.name)
            .definition = my.definition
            .declaration = my.declaration


            _Z19_add_argument_impl (method, my.meta)

            new argument to method
                _Z19_define_dependency_argument (argument, require, my.meta)
            endnew
        endnew

        if require.type = "interface"
            new method to my.destination
                . = "\
                Setup dependency '$(require.name)' and transfer ownership.
                "
                .name = cat (my.names.method_take, require.name)
                .definition = my.definition
                .declaration = my.declaration

                _Z19_add_argument_impl (method, my.meta)

                new argument to method
                    _Z19_define_dependency_argument (argument, require, my.meta)
                    argument.access = "disown"
                endnew
            endnew
        endif
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add next instances:
#       - implemented interface api instance
#       - implemented interface api instances as array
#       - implementation info instance
#       - implementation instance
# ---------------------------------------------------------------------------
function _Z19_add_instances (impl, source, destination, meta)
    check_arguments (my, "impl, source, destination, meta", my)

    if ! _Z19_has_methods_with_context_impl (my.impl)
        return
    endif

    my.names = meta_names (my.meta)

    for my.impl.interface
        my.interface_api = c_module_interface_api_find_type (interface.name, my.source, my.meta)
        _Z19_add_interface_api_instance (my.impl, my.interface_api, my.destination, my.meta)
    endfor

    _Z19_add_array_of_interface_api_instances (my.impl, my.destination, my.meta)

    my.impl_info_module = my.source->module (name = my.names.module_impl_private)
    my.impl_info = my.impl_info_module->struct (name = my.names.struct_info)
    _Z19_add_implementation_info_instance (my.impl, my.impl_info, my.destination, my.meta)
endfunction

# ---------------------------------------------------------------------------
#   Create module with:
#       - opaque declaration of the Implementation API type
#       - constants that required by interfaces
#       - lifecycle functions - declaration only
#       - functions that implements interface
#       - dependency management functions - declaration only
#       - function that returns implementation type size - declaration only
#       - function that cast implementation type to the common
#         implementation type - declaration only
# ---------------------------------------------------------------------------
function c_module_implementation_create_public_module (impl, enum_impl_tag, destination, meta)
    check_arguments (my, "impl, enum_impl_tag, destination, meta", my)

    my.names = meta_names (my.meta)

    new module to my.destination
        . = "\
        This module contains '$(my.names.implementation_module)' implementation.
        "

        .name = my.names.implementation_module
        .class = my.names.implementation_class

        _Z19_add_public_module_includes (my.impl, module, my.meta)
        _Z19_add_self_tag (my.impl, my.enum_impl_tag, my.meta)
        _Z19_add_impl_type (my.impl, "external", module, my.meta)
        _Z19_add_impl_type_size_method (my.impl, "public", "external", module, my.meta)
        _Z19_add_impl_type_cast_method (my.impl, "public", "external", module, my.meta)
        _Z19_add_interface_constants (my.impl, module, my.meta)
        _Z19_add_interface_methods (my.impl, "public", module, my.meta)
        _Z19_add_lifecycle_methods (my.impl, "public", "external", module, my.meta)
        _Z19_add_dependency_methods (my.impl, "public", "external", module, my.meta)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Creates module with:
#       - Implementation API types definition
# ---------------------------------------------------------------------------
function c_module_implementation_create_types_module (impl, destination, meta)
    check_arguments (my, "impl, destination, meta", my)

    if ! _Z19_has_methods_with_context_impl (my.impl)
        return
    endif

    my.names = meta_names (my.meta)

    new module to my.destination
        .= "\
        Types of the '$(my.impl.name:)' implementation.
        This types SHOULD NOT be used directly.
        The only purpose of including this module is to place implementation
        object in the stack memory.
        "

        .name = my.names.implementation_module_types
        .of_class = my.names.implementation_class
        .scope = "private"

        new require to module
            .module = my.names.module_library
        endnew

        new require to module
            .module = my.names.module_impl_private
        endnew

        _Z19_add_ctx_type (my.impl, "public", module, my.meta)
        _Z19_add_impl_type (my.impl, "public", module, my.meta)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Creates module with fully generated code:
#       - instantiations of the Interface API objects
#       - instantiations of the Implementation API objects
#       - lifecycle functions - definition only
#       - dependency management functions - definition only
#       - function that returns implementation type size - definition only
#       - function that cast implementation type to the common
#         implementation type - definition only
#       - function that returns pointer to implementation specific context
# ---------------------------------------------------------------------------
function c_module_implementation_create_internal_module (impl, source, destination, meta)
    check_arguments (my, "impl, source, destination, meta", my)

    my.names = meta_names (my.meta)

    new module to my.destination
        . = "\
        "

        .name = my.names.implementation_module_internal
        .of_class = my.names.implementation_class
        .scope = "internal"

        _Z19_add_internal_module_includes (my.impl, module, my.meta)
        _Z19_add_instances (my.impl, my.source, module, my.meta)
        _Z19_add_impl_type_size_method (my.impl, "external", "private", module, my.meta)
        _Z19_add_impl_type_cast_method (my.impl, "external", "private", module, my.meta)
        _Z19_add_lifecycle_methods (my.impl, "external", "private", module, my.meta)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Create 'Implementation Lifecycle API' module for each 'implementation'
#   within given source and put it to the destination.
# ---------------------------------------------------------------------------
function c_module_implementation_create (source, destination, meta)
    check_arguments (my, "source, destination, meta", my)

    my.names = meta_names (my.meta)
    my.refs = meta_refs (my.meta)

    my.module_impl = my.source->module (name = my.names.module_impl)
    my.enum_impl_tag = my.module_impl->enum (name = my.names.enum_tag)

    for my.source.implementation
        meta_reset_active_entity (my.meta, implementation.name)

        c_module_implementation_create_public_module (implementation, my.enum_impl_tag, my.destination, my.meta)
        c_module_implementation_create_types_module (implementation, my.destination, my.meta)
        c_module_implementation_create_internal_module (implementation, my.source, my.destination, my.meta)
    endfor
endfunction

.endtemplate

.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   Create language "C" specific 'c_module' components from the generic
#   'component' components.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------

gsl from "common.gsl"
gsl from "c_component.gsl"
gsl from "c_formatter.gsl"


# ###########################################################################
#   Functions that create 'c_module' components from the 'module' components.
# ###########################################################################

# ---------------------------------------------------------------------------
#   Add 'c_license' to destination.
# ---------------------------------------------------------------------------
function c_module_add_license (project, destination)
    check_arguments (my, "project, destination", my)

    new c_license to my.destination
        . = c_format_comment (my.project->license.)
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_caution' to destination.
# ---------------------------------------------------------------------------
function c_module_add_caution (module, destination)
    check_arguments (my, "module, destination", my)

    new c_caution to my.destination
        . = c_format_comment ("\
            This file is partially generated.
            Generated blocks are enclosed between tags [@<tag>, @end].
            User's code can be added between tags [@end, @<tag>].
        ")
    endnew
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_include' to destination.
# ---------------------------------------------------------------------------
function c_module_add_includes (module, destination)
    check_arguments (my, "module, destination", my)

    for my.module.c_include as source
        my.c_include = item_copy_to (source, my.destination)
        c_component_resolve_include (my.c_include)
    endfor

    for my.module.require
        c_component_create_include (require, my.c_module)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_visibility' to 'c_method' and define correspond attributes.
# ---------------------------------------------------------------------------
function c_module_add_visbility (method, c_method)
    check_argument (my, "method")
    check_argument (my, "c_method")

    scope my.c_method
        if string_equal (0.visibility, "public")
            new c_visibility
                .value = ".(c_global_macros_public)"
            endnew
        endif

        if string_equal (0.visibility, "private")
            new c_visibility
                .value = ".(c_global_macros_private)"
            endnew
        endif
    endscope
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_section' to component.
# ---------------------------------------------------------------------------
function c_module_add_section (component, c_component)
    check_argument (my, "component")
    check_argument (my, "c_component")

    for my.component.section
        copy section to my.c_component as c_section
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_return' to 'c_method'.
# ---------------------------------------------------------------------------
function c_module_add_return (method, c_method)
    check_argument (my, "method")
    check_argument (my, "c_method")

    scope my.c_method
        # TODO: continue here
        #if my.method->return.

        new c_return
            .value = my.method->return.c_type
        endnew
    endscope
endfunction

# ---------------------------------------------------------------------------
#   Convert string representation of the logical operation to the symbols.
# ---------------------------------------------------------------------------
function c_module_symbolise_operation (operation)
    check_argument (my, "operation")

    if my.operation = "greater_then"
        return ">"
    elsif my.operation = "greater_or_equal_to"
        return ">="
    elsif my.operation = "less_then"
        return "<"
    elsif my.operation = "less_or_equal_to"
        return "<="
    elsif my.operation = "equal_to"
        return "=="
    endif
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_precondition' to 'c_method'.
# ---------------------------------------------------------------------------
function c_module_add_preconditions (method, c_method)
    check_argument (my, "method")
    check_argument (my, "c_method")

    for my.method.precondition
        my.operation = 0.unary ? 0.binary

        for precondition. as term where is_item (term)
            if term.name () = "argument"
                my.target_argument = my.method->argument (name = term.name)
                my.uid$(index ()) = ref (my.target_argument.uid)
            elsif term.name () = "uid"
                my.uid$(index ()) = term.name
            else
                echo_fatal ("Forbidden term '<$(name (term))>' within '<precondition>'.", my)
            endif
            my.uid$(index ()) = string.replace (my.uid$(index ()), ".(|.(c_")
        endfor


        new c_precondition to my.c_method
            .is_default = precondition.is_default ?
            if my.operation = "not_null_obj"
                . = "\
                $(ref ("c_class_assert_macros")) ($(my.uid1:));
                "
            elsif my.operation = "not_null_ref"
                . = "\
                $(ref ("c_class_assert_macros")) ($(my.uid1:));
                $(ref ("c_class_assert_macros")) (*$(my.uid1:));
                "
            elsif defined (precondition.binary)
                my.operation_symbol = c_module_symbolise_operation (my.operation)
                . = "\
                $(ref ("c_class_assert_macros")) ($(my.uid1:) $(my.operation_symbol:) $(my.uid2));
                "
            else
                echo_fatal ("Unsupported precondition operation: $(my.operation:)", my)
            endif

        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_argument' to 'c_method'
# ---------------------------------------------------------------------------
function c_module_add_arguments (method, c_method)
    check_argument (my, "method")
    check_argument (my, "c_method")

    for my.method.argument
        new c_argument to my.c_method
            .name = argument.c_name
            .type = argument.c_type
            .is_mutable = argument.is_mutable ?
            .is_object = argument.is_object ?
            .is_reference = argument.is_reference ?
            .is_callback = argument.is_callback ?
            .has_size = string_in (argument.size ? "", "given, known")
            my.argument_has_size = .has_size
        endnew

        if my.argument.has_size
            new c_argument to my.c_method
                .name = c_format_name (argument.c_name, "size")
                .type = "size_t"
            endnew
        endif
    else
        #   C language requires to specify void argument
        #   if function has no arguments.
        new c_argument to my.c_method
            .type = "void"
            .value = "void"
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_implementation' to 'c_method'.
# ---------------------------------------------------------------------------
function c_module_add_implementation (method, c_method)
    check_argument (my, "method")
    check_argument (my, "c_method")

    for my.method.c_implementation
        copy c_implementation to my.c_method
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_callback' to destination.
# ---------------------------------------------------------------------------
function c_module_add_callbacks (component, c_module)
    check_argument (my, "component")
    check_argument (my, "c_module")

    for my.component.callback
        new c_callback to my.c_module
            . = c_xml_format_comment (callback., 2, 2) ?

            .name = callback.c_name

            c_module_add_section (callback, c_callback)
            c_module_copy_attributes (callback, c_callback)
            c_module_add_return (callback, c_callback)
            c_module_add_arguments (callback, c_callback)
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_value' to 'c_object'.
# ---------------------------------------------------------------------------
function c_module_add_object_values (object, c_object)
    check_argument (my, "object")
    check_argument (my, "c_object")

    for my.object.value
        if ! defined (value.value)
            echo_fatal ("One of the object's values is not defined.", my)
        endif
        new c_value to my.c_object
            . = c_xml_format_comment (value., 2, 2) ?
            .value = c_resolve_ref (value.value)
            .type = c_resolve_ref (value.type) ?
            .is_pointer = value.is_pointer ?
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_object' to destination.
# ---------------------------------------------------------------------------
function c_module_add_objects (component, c_module)
    check_argument (my, "component")
    check_argument (my, "c_module")

    for my.component.object
        new c_object to my.c_module
            . = c_xml_format_comment (object., 2, 2) ?

            .name = object.c_name
            .type = object.c_type

            c_module_add_section (object, c_object)
            c_module_copy_attributes (object, c_object)
            c_module_add_object_values (object, c_object)
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_value' to 'c_enum'.
# ---------------------------------------------------------------------------
function c_module_add_enum_values (enum, c_enum)
    check_argument (my, "enum")
    check_argument (my, "c_enum")

    for my.enum.value
        new c_value to my.c_enum
            . = c_xml_format_comment (value., 2, 2) ?
            .name = value.c_name
            .value = value.value ?
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_enum' to destination.
# ---------------------------------------------------------------------------
function c_module_add_enums (component, c_module)
    check_arguments (my, "component, c_module")
    check_argument (my, "c_module")

    for my.component.enum
        new c_enum to my.c_module
            . = c_xml_format_comment (enum., 2, 2) ?

            .name = enum.c_name ?
            .type = enum.c_type ?

            c_module_add_section (enum, c_enum)
            c_module_copy_attributes (enum, c_enum)
            c_module_add_enum_values (enum, c_enum)
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_poperty' to 'c_struct'.
# ---------------------------------------------------------------------------
function c_module_add_struct_properties (struct, c_struct)
    check_argument (my, "struct")
    check_argument (my, "c_struct")

    for my.struct.property
        new c_property to my.c_struct
            . = c_xml_format_comment (property., 2, 2) ?

            .name = property.c_name
            .is_callback = property.is_callback ?
            .bits = property.bits ?

            if is_true (property.is_callback)
                c_module_copy_attributes (property, c_property)
                c_module_add_return (property, c_property)
                c_module_add_arguments (property, c_property)
            else
                .type = property.c_type
                if defined (.bits)
                    .value += ":" + .bits
                endif
            endif
        endnew
    endfor
endfunction


# ---------------------------------------------------------------------------
#   Add 'c_struct' to destination.
# ---------------------------------------------------------------------------
function c_module_add_structs (component, c_module)
    check_argument (my, "component")
    check_argument (my, "c_module")

    for my.component.struct
        new c_struct to my.c_module
            . = c_xml_format_comment (struct., 2, 2) ?

            .name = struct.c_name ?
            .type = struct.c_type ?

            c_module_add_section (struct, c_struct)
            c_module_copy_attributes (struct, c_struct)
            c_module_add_struct_properties (struct, c_struct)
        endnew
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Add 'c_macros' to destination.
# ---------------------------------------------------------------------------
function c_module_add_macroses (component, c_module)
    check_argument (my, "component")
    check_argument (my, "c_module")
    for my.component.macros
        new c_macros to my.c_module
            . = c_xml_format_comment (macros., 2, 2) ?

            .name = macros.c_name ?

            c_module_add_section (macros, c_macros)
            c_module_copy_attributes (macros, c_macros)
            c_module_add_implementation (macros, c_macros)
        endnew
    endfor
endfunction

# ###########################################################################
#   Root component functions.
# ###########################################################################

# ---------------------------------------------------------------------------
#   For each 'module' component create 'c_module'.
# ---------------------------------------------------------------------------
function c_module_create (source, destination, project)
    check_arguments (my, "source, destination, project", my)

    for my.source.module
        component_require_attr_name (module, my)
        component_require_attr_of_class (module, my)

        echo_trace ("Createing <c_module/> from \
                <$(name (module)) name = \"$(module.name:)/>\"", my)

        new c_module to my.destination
            .lang = "C"
            .name = c_format_name (module.c_prefix, module.name)
            .class = c_format_name (module.class)

            c_component_map_attr_uid (c_module, module)

            my.resolved_header_path = string_in (module.scope, "public") ?? \
                     my.project.inc_path ? my.project.src_path

            . = c_format_comment (module.) ?

            .c_include_file = 0.name + ".h"
            .c_source_file = 0.name + ".c"
            .header_file = my.resolved_header_path + 0.c_include_file
            .source_file = my.project.src_path + 0.c_source_file
            .once_guard = c_format_name (0.c_include_file, "included")

            new c_include
                .file = .c_include_file
                .is_system = "0"
                .scope = "private"
            endnew

            c_module_add_license (my.project, c_module)
            c_module_add_caution (module, c_module)
            c_module_add_includes (module, c_module)

            for module.c_alias
                copy c_alias to c_module
            endfor

            for module.macros
                c_component_create_macros (macros, c_module)
            endfor

            for module.macroses
                c_component_create_macroses (macroses, c_module)
            endfor

            for module.callback
                c_component_create_callback (callback, c_module)
            endfor

            for module.enum
                c_component_create_enum (enum, c_module)
            endfor

            for module.struct
                c_component_create_struct (struct, c_module)
            endfor

            for module.method
                c_component_create_method (method, c_module)
            endfor
            #c_module_add_variables (module, c_module)
        endnew
    else
        echo_warning ("Source does not contain any <module/> item", my)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Function that resolves undefined properties within 'c_module'.
# ---------------------------------------------------------------------------
function c_module_resolve (source)
    #   Components are created already resolved at this moment,
    #   but this can be chnged in the future, so keep this function alive.
endfunction

.endtemplate

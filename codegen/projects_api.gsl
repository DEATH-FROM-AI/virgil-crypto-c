.template 0
#   Copyright (C) 2015-2018 Virgil Security Inc.
#
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are
#   met:
#
#       (1) Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#       (2) Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#       (3) Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR
#   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
#   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
#   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.
#
#   Lead Maintainer: Virgil Security Inc. <support@virgilsecurity.com>

# ---------------------------------------------------------------------------
#   This is GSL file that maintain information about projects API and
#   projects resolution context.
#
#   Private function prefix is: F17.
# ---------------------------------------------------------------------------
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
# ---------------------------------------------------------------------------


gsl from "common.gsl"
gsl from "context.gsl"


# ---------------------------------------------------------------------------
#   Return active project.
# ---------------------------------------------------------------------------
function _F17_get_active_project (projects_api)
    check_arguments (my, "projects_api", my)

    assert_attribute (my.projects_api, "active_project", my)

    my.project = my.projects_api->project (name = my.projects_api.active_project) ?

    if ! defined (my.project)
        echo_fatal ("Active project is defined, but missed within 'projects_api'.", my)
    endif

    return my.project
endfunction

# ---------------------------------------------------------------------------
#   Load existing <projects_api/> entity or create new one.
# ---------------------------------------------------------------------------
function projects_api_load (work_path)
    my.dir_path = directory.resolve (my.work_path) ?
    my.file_path = "$(my.dir_path?:)projects_api.xml"

    if file.exists (my.file_path)
        my.projects_api = item_load_from_file(my.file_path)
    else
        my.projects_api = XML.new("projects_api")
    endif

    return my.projects_api
endfunction


# ---------------------------------------------------------------------------
#   Save <projects_api/> entity to the file at given path.
# ---------------------------------------------------------------------------
function projects_api_save (projects_api, work_path)
    check_arguments (my, "projects_api", my)

    item_save_to_file(my.projects_api, "projects_api.xml", my.work_path)
endfunction


# ---------------------------------------------------------------------------
#   Reset all information about given project and set this project as active.
# ---------------------------------------------------------------------------
function projects_api_reset_project (projects_api, project)
    check_arguments (my, "projects_api, project", my)

    my.project_entry = my.projects_api->project (name = my.project.name) ?

    if defined (my.project_entry)
        delete my.project_entry
    endif

    new project to my.projects_api
        .name = my.project.name
        .namespace = my.project.namespace
        .namespace_dir = my.project.namespace_dir
        .framework = my.project.framework

        for my.project.require where defined (require.project) & string_equal (require.feature, "library")
            new require to project
                .project = -1.project
            endnew
        endfor

        context_append_project (project, my.project)
    endnew

    my.projects_api.active_project = my.project.name
endfunction


# ---------------------------------------------------------------------------
#   Return global resolution context, that contains all uid to name maps.
# ---------------------------------------------------------------------------
function projects_api_build_type_resolution_map (projects_api)
    check_arguments (my, "projects_api", my)

    my.resolution_map = XML.new ("type_resolution_map")

    for my.projects_api.project

        #   Process uids.
        my.project_prefix = (project.name <> my.projects_api.active_project) ?? make_id ("project", project.name) ?

        for project.uid
            if defined (my.project_prefix) & defined (uid.full_ref)
                my.resolution_map.$(uid_insert_prefix (uid.uid, my.project_prefix)) = uid.full_ref
            else
                my.resolution_map.$(uid_insert_prefix (uid.uid, my.project_prefix)) = uid.ref
            endif
        endfor

        #   Process headers.
        my.is_external_project = (project.name = my.projects_api.active_project) ?? "0" ? "1"
        my.public_prefix = my.is_external_project ?? project.namespace_dir ?
        my.private_prefix = my.is_external_project ?? cat_path (project.namespace_dir, "private") ?

        for project.header
            if my.is_external_project & header.scope = "internal"
                next
            endif

            if header.scope = "public"
                my.header_file = cat_path (my.public_prefix, header.file)

            elsif header.scope = "private"
                my.header_file = cat_path (my.private_prefix, header.file)
            else
                my.header_file = header.file
            endif

            my.key = make_id ("c", my.project_prefix, "header", header.name)
            my.resolution_map.$(my.key:) = my.header_file
        endfor
    endfor

    return my.resolution_map
endfunction


# ---------------------------------------------------------------------------
#   Traverse all known entries within source and collect meta information
#   about types.
# ---------------------------------------------------------------------------
function projects_api_collect_info (projects_api, source)
    check_arguments (my, "projects_api, source", my)

    my.project = _F17_get_active_project (my.projects_api)

    context_append_hierarchy (my.project, my.source)

    #   Process <c_module/> entries.
    for my.source.c_module
        my.header = my.project->header (file = c_module.c_include_file) ?

        if ! defined (my.header)
            new header to my.project
                .name = c_module.id
                .file = c_module.c_include_file
                .scope = c_module.scope

                my.header = header
            endnew
        endif

        for c_module. as c_type where item_in(c_type, "c_enum, c_struct, c_callback, c_method") & defined(c_type.name)
            if string_equal(c_type.declaration, "public")
                new declaration to my.header
                    .type = c_type.name
                endnew
            endif

            if string_equal(c_type.definition, "public")
                new definition to my.header
                    .type = c_type.name
                endnew
            endif

            for c_type.c_constant
                new declaration to my.header
                    .type = c_constant.name
                endnew

                new definition to my.header
                    .type = c_constant.name
                endnew
            endfor
        endfor
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Find resolved name based on the given UID in within active project.
# ---------------------------------------------------------------------------
function projects_api_find_resolved_name (projects_api, uid)
    check_arguments (my, "projects_api, uid", my)

    my.active_project = _F17_get_active_project (my.projects_api)

    for my.active_project.uid where uid.uid = my.uid
        return uid.ref
    else
        echo_fatal ("Requested UID '$(my.uid)' is not found", my)
    endfor
endfunction

# ---------------------------------------------------------------------------
#   Return new XML item with information about header file that contains
#   given type declaration.
# ---------------------------------------------------------------------------
function projects_api_find_declaration_header (projects_api, type_name)
    check_arguments (my, "projects_api, type_name", my)

    for my.projects_api.project
        for project.header
            for header.declaration
                if declaration.type = my.type_name
                    my.header_info = XML.new ("header_info")

                    scope my.header_info
                        .name = header.name
                        .file = header.file
                        .system = cat_path (project.namespace_dir, header.file)
                        .framework = cat_path (project.framework, header.file)
                        .project = project.name
                        .is_external = project.name <> my.projects_api.active_project
                    endscope

                    return my.header_info
                endif
            endfor
        endfor
    endfor

    return
endfunction

# ---------------------------------------------------------------------------
#   Return new XML item with information about header file that contains
#   given type definition.
# ---------------------------------------------------------------------------
function projects_api_find_definition_header (projects_api, type_name)
    check_arguments (my, "projects_api, type_name", my)

    for my.projects_api.project
        for project.header
            for header.definition
                if definition.type = my.type_name
                    my.header_info = XML.new ("header_info")

                    scope my.header_info
                        .name = header.name
                        .file = header.file
                        .system = cat_path (project.namespace_dir, header.file)
                        .framework = cat_path (project.framework, header.file)
                        .project = project.name
                        .is_external = project.name <> my.projects_api.active_project
                    endscope

                    return my.header_info
                endif
            endfor
        endfor
    endfor

    return
endfunction

.endtemplate
